<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>WEBCRAFT</title>
    <meta name="description" content="WEBCRAFT - A browser-based voxel game" />
    <link rel="icon" id="dynamic-favicon" href="https://github.com/Matko802/WebCraft/blob/main/textures/grass_side.png?raw=true" type="image/png">
    <script>
        // Cache favicon to IndexedDB
        (function() {
            const FAVICON_URL = 'https://github.com/Matko802/WebCraft/blob/main/textures/grass_side.png?raw=true';
            const DB_NAME = 'WebCraftFavicon';
            const STORE_NAME = 'favicon';
            
            function openDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(DB_NAME, 1);
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => resolve(request.result);
                    request.onupgradeneeded = (e) => {
                        e.target.result.createObjectStore(STORE_NAME);
                    };
                });
            }
            
            async function getCachedFavicon() {
                try {
                    const db = await openDB();
                    return new Promise((resolve) => {
                        const tx = db.transaction(STORE_NAME, 'readonly');
                        const store = tx.objectStore(STORE_NAME);
                        const request = store.get('favicon');
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => resolve(null);
                    });
                } catch { return null; }
            }
            
            async function cacheFavicon(blob) {
                try {
                    const db = await openDB();
                    const tx = db.transaction(STORE_NAME, 'readwrite');
                    tx.objectStore(STORE_NAME).put(blob, 'favicon');
                } catch (e) { console.warn('Failed to cache favicon:', e); }
            }
            
            function setFavicon(blobUrl) {
                const link = document.getElementById('dynamic-favicon');
                if (link) link.href = blobUrl;
            }
            
            async function loadFavicon() {
                const cached = await getCachedFavicon();
                if (cached) {
                    setFavicon(URL.createObjectURL(cached));
                    return;
                }
                
                try {
                    const response = await fetch(FAVICON_URL);
                    const blob = await response.blob();
                    await cacheFavicon(blob);
                    setFavicon(URL.createObjectURL(blob));
                } catch (e) { console.warn('Failed to load favicon:', e); }
            }
            
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', loadFavicon);
            } else {
                loadFavicon();
            }
        })();
    </script>
    <style>
        /* ===== FLAT MINIMAL DARK GRAY UI ===== */
        
        /* General Setup */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif; 
            background: #1a1a1a;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        canvas { display: block; cursor: crosshair; }
        
        /* CSS Variables - Flat Dark Gray Theme */
        :root {
            --bg-darkest: #121212;
            --bg-dark: #1a1a1a;
            --bg-medium: #242424;
            --bg-light: #2e2e2e;
            --bg-lighter: #3a3a3a;
            --border-color: #404040;
            --border-light: #4a4a4a;
            --text-primary: #e0e0e0;
            --text-secondary: #a0a0a0;
            --text-muted: #666666;
            --accent: #5a5a5a;
            --accent-hover: #6a6a6a;
            --danger: #b04040;
            --success: #408040;
        }
        
        /* Hide starfield background */
        #starfield-bg { display: none !important; }
        
        /* Information Overlays */
        #ui, #fps { 
            position: absolute; 
            color: var(--text-primary); 
            background: none; 
            padding: 4px 8px; 
            border: none;
            pointer-events: none; 
            z-index: 5; 
            font-size: 12px;
            font-family: 'Courier New', monospace;
            line-height: 1.5;
            display: none;
        }
        #ui { top: 50px; left: 4px; white-space: pre; }
        #fps { top: 4px; left: 4px; }
        
        /* Health Container */
        #health-container {
            position: absolute;
            bottom: 88px;
            left: 50%;
            transform: translateX(-232px);
            display: none;
            z-index: 5;
        }
        
        .heart {
            display: inline-block;
            width: 18px;
            height: 18px;
            margin: 0 1px;
            position: relative;
        }
        
        .heart::before {
            content: '';
            position: absolute;
            width: 2px;
            height: 2px;
            background: currentColor;
            box-shadow: 
                0px 0px 0 0px currentColor, 4px 0px 0 0px currentColor,
                10px 0px 0 0px currentColor, 14px 0px 0 0px currentColor,
                -2px 2px 0 0px currentColor, 0px 2px 0 0px currentColor,
                2px 2px 0 0px currentColor, 4px 2px 0 0px currentColor,
                6px 2px 0 0px currentColor, 8px 2px 0 0px currentColor,
                10px 2px 0 0px currentColor, 12px 2px 0 0px currentColor,
                14px 2px 0 0px currentColor, 16px 2px 0 0px currentColor,
                -2px 4px 0 0px currentColor, 0px 4px 0 0px currentColor,
                2px 4px 0 0px currentColor, 4px 4px 0 0px currentColor,
                6px 4px 0 0px currentColor, 8px 4px 0 0px currentColor,
                10px 4px 0 0px currentColor, 12px 4px 0 0px currentColor,
                14px 4px 0 0px currentColor, 16px 4px 0 0px currentColor,
                -2px 6px 0 0px currentColor, 0px 6px 0 0px currentColor,
                2px 6px 0 0px currentColor, 4px 6px 0 0px currentColor,
                6px 6px 0 0px currentColor, 8px 6px 0 0px currentColor,
                10px 6px 0 0px currentColor, 12px 6px 0 0px currentColor,
                14px 6px 0 0px currentColor, 16px 6px 0 0px currentColor,
                0px 8px 0 0px currentColor, 2px 8px 0 0px currentColor,
                4px 8px 0 0px currentColor, 6px 8px 0 0px currentColor,
                8px 8px 0 0px currentColor, 10px 8px 0 0px currentColor,
                12px 8px 0 0px currentColor, 14px 8px 0 0px currentColor,
                2px 10px 0 0px currentColor, 4px 10px 0 0px currentColor,
                6px 10px 0 0px currentColor, 8px 10px 0 0px currentColor,
                10px 10px 0 0px currentColor, 12px 10px 0 0px currentColor,
                4px 12px 0 0px currentColor, 6px 12px 0 0px currentColor,
                8px 12px 0 0px currentColor, 10px 12px 0 0px currentColor,
                6px 14px 0 0px currentColor, 8px 14px 0 0px currentColor;
        }
        
        .heart.full { color: #cc4444; }
        .heart.half { color: #aa6666; }
        .heart.empty { color: #444; }
        
        /* Oxygen Bubbles */
        #oxygen-container {
            position: absolute;
            bottom: 88px;
            left: 50%;
            transform: translateX(32px);
            display: none;
            z-index: 5;
            text-align: left;
        }
        
        .bubble {
            display: inline-block;
            width: 18px;
            height: 18px;
            margin: 0 1px;
            position: relative;
        }
        
        .bubble::before {
            content: '';
            position: absolute;
            width: 2px;
            height: 2px;
            background: currentColor;
            box-shadow: 
                4px 0px 0 0px currentColor, 6px 0px 0 0px currentColor,
                8px 0px 0 0px currentColor, 10px 0px 0 0px currentColor,
                2px 2px 0 0px currentColor, 4px 2px 0 0px currentColor,
                10px 2px 0 0px currentColor, 12px 2px 0 0px currentColor,
                0px 4px 0 0px currentColor, 2px 4px 0 0px currentColor,
                12px 4px 0 0px currentColor, 14px 4px 0 0px currentColor,
                0px 6px 0 0px currentColor, 2px 6px 0 0px currentColor,
                12px 6px 0 0px currentColor, 14px 6px 0 0px currentColor,
                0px 8px 0 0px currentColor, 2px 8px 0 0px currentColor,
                12px 8px 0 0px currentColor, 14px 8px 0 0px currentColor,
                0px 10px 0 0px currentColor, 2px 10px 0 0px currentColor,
                12px 10px 0 0px currentColor, 14px 10px 0 0px currentColor,
                2px 12px 0 0px currentColor, 4px 12px 0 0px currentColor,
                10px 12px 0 0px currentColor, 12px 12px 0 0px currentColor,
                4px 14px 0 0px currentColor, 6px 14px 0 0px currentColor,
                8px 14px 0 0px currentColor, 10px 14px 0 0px currentColor;
        }
        
        .bubble::after { display: none; }
        .bubble { color: #4488aa; }
        .bubble.popped { color: #333; opacity: 0.5; }
        
        /* Movement Status */
        #movement-status {
            position: absolute;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-medium);
            padding: 8px 16px;
            font-size: 12px;
            font-weight: 500;
            z-index: 5;
            pointer-events: none;
            display: none;
            opacity: 0;
            border: 1px solid var(--border-color);
        }
        
        #movement-status.sprinting {
            color: #6699cc;
            border-color: #6699cc;
            display: block;
            opacity: 1;
        }
        
        #movement-status.sneaking {
            color: #cc9966;
            border-color: #cc9966;
            display: block;
            opacity: 1;
        }
        
        /* Held Item Info */
        #held-item-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: var(--bg-medium);
            padding: 12px 16px;
            border: 1px solid var(--border-color);
            z-index: 5;
            pointer-events: none;
            display: none;
            text-align: right;
        }
        
        #held-item-info .item-name {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
        }
        
        #held-item-info .item-count {
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        #held-item-info .durability-bar-container {
            margin-top: 8px;
            width: 100%;
            height: 4px;
            background: var(--bg-darkest);
            overflow: hidden;
        }
        
        #held-item-info .durability-bar {
            height: 100%;
        }
        
        #held-item-info .durability-bar.high { background: var(--success); }
        #held-item-info .durability-bar.medium { background: #aa8800; }
        #held-item-info .durability-bar.low { background: var(--danger); }
        #held-item-info .durability-text { font-size: 10px; color: var(--text-muted); margin-top: 4px; }
        
        /* Death Screen */
        #death-screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(80, 20, 20, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1500;
        }
        
        #death-screen h1 {
            font-size: 48px;
            color: var(--text-primary);
            margin-bottom: 20px;
            font-weight: 700;
        }
        
        #death-screen p {
            font-size: 18px;
            color: var(--text-secondary);
            margin-bottom: 30px;
        }
        
        #death-respawn-btn {
            padding: 14px 32px;
            font-size: 16px;
            background: var(--bg-light);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            cursor: pointer;
            font-family: inherit;
            font-weight: 500;
        }
        
        #death-respawn-btn:hover {
            background: var(--bg-lighter);
        }
        
        /* Crosshair */
        #crosshair { 
            position: absolute; 
            top: 50%; left: 50%; 
            transform: translate(-50%, -50%); 
            pointer-events: none; 
            width: 20px; height: 20px; 
            z-index: 5;
            mix-blend-mode: difference;
            display: none;
        }
        #crosshair::before { content: ''; position: absolute; background: white; width: 20px; height: 2px; left: 0; top: 9px; }
        #crosshair::after { content: ''; position: absolute; background: white; width: 2px; height: 20px; left: 9px; top: 0; }
        
        /* Fake Cursor */
        #fake-cursor {
            position: fixed;
            width: 20px; height: 20px; 
            z-index: 2500;
            pointer-events: none; 
            display: none; 
            transform: translate(-50%, -50%); 
        }
        #fake-cursor::before { content: ''; position: absolute; background: white; width: 20px; height: 2px; left: 0; top: 9px; }
        #fake-cursor::after { content: ''; position: absolute; background: white; width: 2px; height: 20px; left: 9px; top: 0; }
        
        /* Toolbar (Hotbar) */
        #toolbar { 
            position: absolute; 
            bottom: 20px; 
            left: 50%; 
            transform: translateX(-50%); 
            display: none;
            gap: 0; 
            z-index: 5;
            background: var(--bg-medium);
            border: 1px solid var(--border-color);
            padding: 4px;
        }
        
        #toolbar button { 
            width: 52px; height: 52px; 
            border: 1px solid var(--border-color); 
            cursor: pointer; 
            font-size: 10px; 
            color: var(--text-primary); 
            background: var(--bg-dark); 
            display: flex;
            flex-direction: column; 
            justify-content: center; 
            align-items: center;
            position: relative;
        }
        
        #toolbar button:not(:last-child) { border-right: none; }
        #toolbar button.selected { background: var(--bg-lighter); border-color: var(--text-muted); }
        #toolbar button:hover:not(.selected) { background: var(--bg-light); }
        
        #toolbar button .slot-item { font-size: 10px; font-weight: 500; line-height: 1.1; }
        #toolbar button .slot-count {
            position: absolute;
            bottom: 2px; right: 4px; 
            font-size: 9px;
            font-weight: 600;
            color: var(--text-primary);
            background: rgba(0,0,0,0.5);
            padding: 1px 3px;
        }
        
        /* Menu Containers */
        #main-menu, #pause-menu { 
            position: absolute; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            background: rgba(20, 20, 20, 0.95);
            display: flex; 
            flex-direction: column;
            align-items: center; 
            justify-content: center; 
            color: var(--text-primary); 
            z-index: 1000;
        }
        
        #main-menu.in-game-overlay::before {
            content: '';
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: -1;
        }
        
        #main-controls {
            background: var(--bg-medium);
            padding: 40px 50px;
            border: 1px solid var(--border-color);
        }
        
        #main-menu h1 {
            font-size: 48px;
            margin-bottom: 30px;
            letter-spacing: 2px;
            color: var(--text-primary);
            font-weight: 700;
        }
        
        #main-menu h1::after {
            content: 'WEB EDITION';
            display: block;
            font-size: 12px;
            color: var(--text-muted);
            letter-spacing: 4px;
            margin-top: 8px;
            font-weight: 400;
        }
        
        /* Inventory Screen */
        #inventory-screen {
            position: absolute; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            background: transparent;
            display: none;
            align-items: center; 
            justify-content: center; 
            color: var(--text-primary); 
            z-index: 1000;
            padding: 20px;
            overflow-y: auto;
        }
        
        #inventory-screen::before {
            content: '';
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: -1;
        }
        
        .inventory-container {
            padding: 20px; 
            background: var(--bg-medium);
            border: 1px solid var(--border-color);
            max-width: 920px;
            width: 95%;
            display: flex;
            flex-direction: column;
            gap: 15px;
            position: relative;
            margin: auto;
        }
        
        .inventory-container h2 { 
            text-align: center; 
            margin: 0 0 5px 0; 
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .inventory-main-section {
            display: flex;
            gap: 15px;
            align-items: flex-start;
        }
        
        .inventory-storage-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
            border: 1px solid var(--border-color);
            padding: 12px;
            background: var(--bg-dark);
        }
        
        #main-inventory-grid {
            display: grid;
            grid-template-columns: repeat(8, 48px); 
            gap: 4px;
            padding: 10px;
            background: var(--bg-darkest);
            border: 1px solid var(--border-color);
            pointer-events: all; 
            justify-content: center;
        }
        
        #hud-inventory-grid {
            display: grid;
            grid-template-columns: repeat(8, 48px); 
            gap: 4px;
            padding: 10px;
            background: var(--bg-dark);
            border: 1px solid var(--border-color);
            pointer-events: all;
            justify-content: center;
            position: relative;
        }
        
        .inventory-section-label {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
            text-align: left;
            margin: 0;
            padding: 4px 6px;
            background: var(--bg-darkest);
            border-left: 2px solid var(--text-muted);
        }
        
        /* Game Mode Toggle */
        #gameModeToggleBtn {
            width: 100%;
            padding: 12px 20px;
            font-size: 13px;
            font-family: inherit;
            background: var(--bg-light);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            cursor: pointer;
            margin-top: 10px;
            font-weight: 500;
        }
        
        #gameModeToggleBtn:hover { background: var(--bg-lighter); }
        
        /* Creative Panel */
        #creative-panel {
            display: none;
            flex-direction: row;
            gap: 12px;
            align-items: flex-start;
            padding: 10px;
            background: var(--bg-dark);
            border: 1px solid var(--border-color);
        }
        
        #inventory-screen.creative-mode #creative-panel { display: flex; }
        
        #creative-block-picker {
            display: grid;
            grid-template-columns: repeat(8, 48px);
            gap: 4px;
            padding: 10px;
            background: var(--bg-darkest);
            border: 1px solid var(--border-color);
            height: 200px;
            overflow-y: scroll;
            justify-content: start;
            align-content: start;
        }
        
        #creative-block-picker .inventory-slot { width: 48px; height: 48px; }
        #creative-block-picker .inventory-slot .slot-item { font-size: 11px; }
        #creative-block-picker .inventory-slot .slot-count { font-size: 10px; }
        
        #creative-picker-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 5px;
            min-width: 440px;
        }
        
        #category-tabs {
            display: flex;
            gap: 2px;
            margin-bottom: 5px;
            flex-wrap: wrap;
        }
        
        .category-tab {
            flex: 1;
            min-width: 70px;
            padding: 8px 12px;
            font-size: 11px;
            font-weight: 500;
            color: var(--text-primary);
            background: var(--bg-light);
            border: 1px solid var(--border-color);
            cursor: pointer;
            text-align: center;
            font-family: inherit;
        }
        
        .category-tab:hover { background: var(--bg-lighter); }
        .category-tab.active { background: var(--accent); border-color: var(--text-muted); }
        
        /* Scrollbars */
        #creative-block-picker::-webkit-scrollbar { width: 8px; }
        #creative-block-picker::-webkit-scrollbar-track { background: var(--bg-darkest); }
        #creative-block-picker::-webkit-scrollbar-thumb { background: var(--bg-lighter); }
        #creative-block-picker::-webkit-scrollbar-thumb:hover { background: var(--accent); }
        
        #delete-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        
        #delete-slot {
            width: 48px;
            height: 48px;
            background: var(--bg-light);
            border: 1px solid var(--danger);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
        }
        
        #delete-slot::before, #delete-slot::after {
            content: '';
            position: absolute;
            background: var(--danger);
        }
        
        #delete-slot::before { width: 4px; height: 24px; transform: rotate(45deg); }
        #delete-slot::after { width: 4px; height: 24px; transform: rotate(-45deg); }
        #delete-slot:hover { background: var(--bg-lighter); }
        
        /* Inventory Slots */
        .inventory-slot {
            width: 48px;
            height: 48px;
            border: 1px solid var(--border-color);
            background: var(--bg-dark);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            color: var(--text-secondary);
            position: relative; 
            cursor: pointer;
        }
        
        .inventory-slot:hover {
            border-color: var(--text-muted);
            background: var(--bg-light);
        }
        
        .inventory-slot.hud-slot {
            background: var(--bg-dark); 
            border: 1px solid var(--border-color);
            width: 48px;
            height: 48px;
        }
        
        .slot-selected {
            border-color: var(--text-secondary) !important; 
            background: var(--bg-lighter);
        }
        
        .inventory-slot .slot-item { 
            font-size: 10px; 
            font-weight: 500;
            color: var(--text-primary); 
            text-align: center;
            line-height: 1;
            pointer-events: none;
        }
        
        .inventory-slot .slot-count { 
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 10px; 
            font-weight: 600;
            color: var(--text-primary); 
            background: rgba(0, 0, 0, 0.6);
            padding: 1px 4px;
            min-width: 16px;
            text-align: center;
            pointer-events: none;
        }
        
        .inventory-slot .slot-durability {
            position: absolute;
            bottom: 10px;
            left: 4px;
            right: 4px;
            height: 3px;
            background: var(--bg-darkest);
            overflow: hidden;
            pointer-events: none;
        }
        
        .inventory-slot .slot-durability-fill {
            height: 100%;
            background: var(--success);
        }
        
        .inventory-slot-tooltip {
            position: absolute;
            bottom: 110%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-darkest);
            color: var(--text-primary);
            padding: 6px 10px;
            font-size: 11px;
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            z-index: 3000;
            border: 1px solid var(--border-color);
        }
        
        .inventory-slot:hover .inventory-slot-tooltip { opacity: 1; }
        .inventory-slot-tooltip::after { display: none; }
        
        /* Picked Up Item */
        #picked-up-item {
            width: 48px;
            height: 48px;
            border: 1px solid var(--accent);
            background: var(--bg-dark);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: var(--text-secondary);
            position: fixed;
            z-index: 2600;
            pointer-events: none;
            transform: translate(-50%, -50%);
        }
        
        /* Menu View */
        .menu-view { 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            padding: 40px 50px; 
            background: var(--bg-medium); 
            border: 1px solid var(--border-color);
            max-width: 90%;
            width: auto;
        }
        
        
        #creation-view, #saved-worlds-view, #settings-view, #credits-view, 
        #video-settings-view, #controls-settings-view, #audio-settings-view, #theme-settings-view {
            background: var(--bg-medium);
            border: 1px solid var(--border-color);
            position: relative;
            overflow: hidden;
        }
        
        #settings-view {
            max-height: 80vh;
            overflow-y: auto;
            overflow-x: hidden;
            padding-right: 50px;
        }
        
        #settings-view::-webkit-scrollbar { width: 10px; }
        #settings-view::-webkit-scrollbar-track { background: var(--bg-darkest); }
        #settings-view::-webkit-scrollbar-thumb { background: var(--bg-lighter); }
        #settings-view::-webkit-scrollbar-thumb:hover { background: var(--accent); }
        
        #settings-history::-webkit-scrollbar { width: 10px; }
        #settings-history::-webkit-scrollbar-track { background: var(--bg-darkest); }
        #settings-history::-webkit-scrollbar-thumb { background: var(--bg-lighter); }
        #settings-history::-webkit-scrollbar-thumb:hover { background: var(--accent); }
        
        #video-settings-view::-webkit-scrollbar,
        #audio-settings-view::-webkit-scrollbar,
        #controls-settings-view::-webkit-scrollbar,
        #theme-settings-view::-webkit-scrollbar,
        #credits-view::-webkit-scrollbar { width: 10px; }
        
        #video-settings-view::-webkit-scrollbar-track,
        #audio-settings-view::-webkit-scrollbar-track,
        #controls-settings-view::-webkit-scrollbar-track,
        #theme-settings-view::-webkit-scrollbar-track,
        #credits-view::-webkit-scrollbar-track { background: var(--bg-darkest); }
        
        #video-settings-view::-webkit-scrollbar-thumb,
        #audio-settings-view::-webkit-scrollbar-thumb,
        #controls-settings-view::-webkit-scrollbar-thumb,
        #theme-settings-view::-webkit-scrollbar-thumb,
        #credits-view::-webkit-scrollbar-thumb { background: var(--bg-lighter); }
        
        #video-settings-view::-webkit-scrollbar-thumb:hover,
        #audio-settings-view::-webkit-scrollbar-thumb:hover,
        #controls-settings-view::-webkit-scrollbar-thumb:hover,
        #theme-settings-view::-webkit-scrollbar-thumb:hover,
        #credits-view::-webkit-scrollbar-thumb:hover { background: var(--accent); }
        
        #graphicsPreset {
            background: var(--bg-dark);
            z-index: 100;
        }
        
        #graphicsPreset:hover { border-color: var(--accent); }
        #graphicsPreset:focus { outline: none; border-color: var(--accent); }
        #graphicsPreset option { background: var(--bg-dark); color: var(--text-primary); padding: 10px; }
        
        #saved-worlds-list::-webkit-scrollbar { width: 10px; }
        #saved-worlds-list::-webkit-scrollbar-track { background: var(--bg-darkest); }
        #saved-worlds-list::-webkit-scrollbar-thumb { background: var(--bg-lighter); }
        #saved-worlds-list::-webkit-scrollbar-thumb:hover { background: var(--accent); }
        
        /* Saved World Card */
        .saved-world-card {
            background: var(--bg-light);
            border: 1px solid var(--border-color);
            padding: 15px;
            margin-bottom: 12px;
            display: flex;
            gap: 15px;
            align-items: center;
        }
        
        .saved-world-card:hover { border-color: var(--text-muted); }
        
        .world-preview {
            width: 100px;
            height: 75px;
            border: 1px solid var(--border-color);
            object-fit: cover;
            background: var(--bg-darkest);
            flex-shrink: 0;
        }
        
        .world-info { flex: 1; text-align: left; }
        
        .world-name {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 6px;
            cursor: pointer;
            display: inline-block;
        }
        
        .world-name:hover { color: var(--text-secondary); }
        .world-details { font-size: 11px; color: var(--text-secondary); line-height: 1.6; }
        .world-actions { display: flex; flex-direction: column; gap: 6px; }
        
        .world-action-btn {
            padding: 10px 18px;
            font-size: 12px;
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            cursor: pointer;
            white-space: nowrap;
            font-family: inherit;
            font-weight: 500;
            background: var(--bg-light);
        }
        
        .world-action-btn:hover { background: var(--bg-lighter); }
        .world-action-btn.load { background: var(--bg-light); border-color: var(--success); }
        .world-action-btn.load:hover { background: var(--bg-lighter); }
        .world-action-btn.delete { background: var(--bg-light); border-color: var(--danger); }
        .world-action-btn.delete:hover { background: var(--bg-lighter); }
        
        /* Rename Modal */
        .rename-modal {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-medium);
            border: 1px solid var(--border-color);
            padding: 30px;
            z-index: 3000;
        }
        
        .rename-modal h3 { margin-bottom: 20px; font-size: 18px; }
        
        .rename-modal input {
            width: 280px;
            padding: 12px;
            font-size: 14px;
            border: 1px solid var(--border-color);
            background: var(--bg-dark);
            color: var(--text-primary);
            margin-bottom: 20px;
            font-family: inherit;
        }
        
        .rename-modal input:focus { outline: none; border-color: var(--accent); }
        
        .rename-modal button {
            padding: 10px 20px;
            font-size: 13px;
            border: 1px solid var(--border-color);
            background: var(--bg-light);
            color: var(--text-primary);
            cursor: pointer;
            font-family: inherit;
            margin: 0 5px;
        }
        
        .rename-modal button:hover { background: var(--bg-lighter); }
        .rename-modal button:first-of-type { background: var(--accent); }
        
        /* Main Menu Buttons */
        .main-menu-btn { 
            padding: 14px 28px; 
            font-size: 14px;
            border: 1px solid var(--border-color); 
            cursor: pointer;
            margin: 8px 0; 
            width: 280px;
            background: var(--bg-light);
            font-family: inherit;
            font-weight: 500;
            color: var(--text-primary);
            letter-spacing: 0.5px;
        }
        
        .main-menu-btn:hover {
            background: var(--bg-lighter);
            border-color: var(--text-muted);
        }
        
        .fixed-back-btn {
            position: fixed !important;
            bottom: 30px !important;
            left: 50% !important;
            transform: translateX(-50%) !important;
            z-index: 10000 !important;
            margin: 0 !important;
        }
        
        .fixed-back-btn:hover { transform: translateX(-50%) !important; }
        
        .settings-category-btn {
            background: var(--bg-light);
            border: 1px solid var(--border-color);
            padding: 16px;
        }
        
        .settings-category-btn:hover { background: var(--bg-lighter); }
        .settings-category-btn > div { position: relative; z-index: 1; }
        
        #settingsSearchInput::placeholder { color: var(--text-muted); }
        #settingsSearchInput:focus { outline: none; border-color: var(--accent); }
        
        #main-controls button:first-child { background: var(--accent); border-color: var(--accent-hover); }
        #main-controls button:first-child:hover { background: var(--accent-hover); }
        
        /* Credits */
        .epic-credits-view {
            background: var(--bg-medium);
            border: 1px solid var(--border-color);
            padding: 40px;
        }
        
        .credits-particles { display: none; }
        
        .credits-title {
            font-size: 24px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 24px;
        }
        
        .credits-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 100%;
            max-width: 350px;
            padding: 10px;
        }
        
        .music-visualizer { display: none !important; }
        .visualizer-bar { display: none; }
        
        .credit-card {
            background: var(--bg-light);
            border: 1px solid var(--border-color);
            padding: 16px;
            opacity: 1;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .credit-card:hover { background: var(--bg-lighter); }
        .credit-glow { display: none; }
        .credit-icon { font-size: 28px; flex-shrink: 0; }
        .credit-content { display: flex; flex-direction: column; gap: 2px; flex: 1; text-align: left; }
        
        .credit-role {
            font-weight: 500;
            font-size: 11px;
            color: var(--text-muted);
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 1;
        }
        
        .credit-name {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            opacity: 1;
            line-height: 1.4;
        }
        
        .credits-back-btn {
            margin-top: 24px;
            padding: 12px 20px;
            font-size: 13px;
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            cursor: pointer;
            font-family: inherit;
            font-weight: 500;
            background: var(--bg-light);
            opacity: 1;
        }
        
        .credits-back-btn:hover { background: var(--bg-lighter); }
        
        /* Pause Menu */
        #pause-menu { 
            position: absolute; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            background: transparent;
            display: none;
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            color: var(--text-primary); 
            z-index: 1000;
            font-size: 14px;
        }
        
        #pause-menu::before {
            content: '';
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: -1;
        }
        
        #pause-menu .menu-view {
            padding: 35px 45px; 
            background: var(--bg-medium);
            border: 1px solid var(--border-color);
            width: 380px;
            text-align: center;
            position: relative;
        }
        
        #pause-menu h2 { font-size: 22px; margin-bottom: 20px; color: var(--text-secondary); font-weight: 600; }
        #pause-menu p { max-width: 350px; text-align: center; margin-top: 8px; font-size: 13px; color: var(--text-muted); }
        #pause-menu .menu-control { margin: 12px 0; width: 100%; }
        
        #progress-warning { 
            color: var(--text-primary);
            background: var(--danger); 
            padding: 8px 12px;
            font-weight: 500; 
            margin-top: 16px; 
            margin-bottom: 20px;
        }
        
        /* Version Text */
        #version-text { 
            position: absolute; 
            bottom: 5px; right: 5px; 
            color: var(--text-muted); 
            font-size: 10px; 
            pointer-events: none; 
            z-index: 5; 
            text-align: right; 
        }
        
        /* Music Toast - Hidden */
        #music-toast { display: none !important; }
        
        /* Custom Slider */
        .custom-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 6px;
            background: var(--bg-darkest);
            outline: none;
            border: 1px solid var(--border-color);
            cursor: pointer;
        }
        
        .custom-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--bg-lighter);
            cursor: pointer;
            border: 1px solid var(--text-muted);
        }
        
        .custom-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--bg-lighter);
            cursor: pointer;
            border: 1px solid var(--text-muted);
        }
        
        .custom-slider:hover::-webkit-slider-thumb { background: var(--accent); }
        .custom-slider:hover::-moz-range-thumb { background: var(--accent); }
        
        /* Toggle Switch */
        .switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 22px;
        }
        
        .switch input { opacity: 0; width: 0; height: 0; }
        
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background: var(--bg-darkest);
            border: 1px solid var(--border-color);
        }
        
        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 2px;
            bottom: 2px;
            background: var(--bg-lighter);
        }
        
        input:checked + .slider { background: var(--accent); border-color: var(--accent-hover); }
        input:checked + .slider:before { transform: translateX(22px); background: var(--text-primary); }
        .slider.round { border-radius: 22px; }
        .slider.round:before { border-radius: 50%; }
        
        /* Settings */
        .settings-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            width: 100%;
            max-width: 700px;
            margin: 20px 0;
        }
        
        .settings-category {
            background: var(--bg-dark);
            border: 1px solid var(--border-color);
            padding: 16px;
        }
        
        .settings-category h3 {
            margin: 0 0 12px 0;
            font-size: 14px;
            color: var(--text-primary);
            letter-spacing: 1px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 8px;
        }
        
        .setting-item { margin-bottom: 12px; }
        .setting-item:last-child { margin-bottom: 0; }
        
        .setting-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            font-size: 13px;
            color: var(--text-primary);
        }
        
        .setting-value { font-weight: 600; color: var(--text-secondary); min-width: 40px; text-align: right; }
        .setting-description { font-size: 10px; color: var(--text-muted); margin-top: 4px; line-height: 1.4; }
        
        .keybind-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            background: var(--bg-darkest);
            border: 1px solid var(--border-color);
        }
        
        .keybind-item label { font-size: 12px; color: var(--text-secondary); font-weight: 500; }
        
        .keybind-btn {
            padding: 8px 16px;
            background: var(--bg-light);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            cursor: pointer;
            font-family: inherit;
            font-weight: 500;
            min-width: 80px;
            text-align: center;
            font-size: 11px;
        }
        
        .keybind-btn:hover { background: var(--bg-lighter); border-color: var(--text-muted); }
        .settings-category.full-width { grid-column: 1 / -1; }
        
        /* Crafting Panel */
        #crafting-panel {
            background: transparent;
            border: none;
            padding: 12px;
            min-width: 240px;
            max-width: 240px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        #crafting-title {
            text-align: center;
            font-size: 13px;
            font-weight: 600;
            margin: 0;
            color: var(--text-secondary);
            padding-bottom: 6px;
        }
        
        .crafting-area {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 10px;
            background: transparent;
        }
        
        #crafting-grid {
            display: grid;
            grid-template-columns: repeat(3, 40px);
            grid-template-rows: repeat(3, 40px);
            gap: 3px;
        }
        
        .crafting-slot {
            width: 40px;
            height: 40px;
            border: 1px solid var(--border-color);
            background: var(--bg-dark);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            color: var(--text-secondary);
            cursor: pointer;
            position: relative;
        }
        
        .crafting-slot:hover { border-color: var(--text-muted); background: var(--bg-light); }
        
        #crafting-arrow {
            text-align: center;
            font-size: 20px;
            color: var(--text-muted);
        }
        
        #crafting-output {
            width: 44px;
            height: 44px;
            border: 1px solid var(--border-color);
            background: var(--bg-dark);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: var(--text-secondary);
            cursor: pointer;
            position: relative;
        }
        
        #crafting-output:hover { background: var(--bg-light); border-color: var(--text-muted); }
        
        #crafting-recipes-wrapper {
            margin-top: 5px;
            padding-top: 8px;
            height: 160px;
            position: relative;
        }
        
        #crafting-recipes {
            height: 100%;
            overflow: hidden;
            padding-right: 16px;
            position: relative;
        }
        
        #crafting-recipes-content { padding-right: 4px; }
        
        .custom-scrollbar {
            position: absolute;
            right: 4px;
            top: 4px;
            bottom: 4px;
            width: 8px;
            background: var(--bg-darkest);
            border: 1px solid var(--border-color);
            z-index: 1900;
            pointer-events: all;
        }
        
        .custom-scrollbar-thumb {
            position: absolute;
            width: 100%;
            background: var(--bg-lighter);
            cursor: grab;
            pointer-events: all;
        }
        
        .custom-scrollbar-thumb:hover { background: var(--accent); }
        .custom-scrollbar-thumb.dragging { background: var(--accent); cursor: grabbing; }
        
        .recipe-list-header {
            font-size: 10px;
            color: var(--text-muted);
            text-align: center;
            margin-bottom: 5px;
            letter-spacing: 0.5px;
        }
        
        .recipe-item {
            background: var(--bg-light);
            padding: 8px 10px;
            margin-bottom: 4px;
            border: 1px solid var(--border-color);
            font-size: 10px;
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            font-family: inherit;
            position: relative;
        }
        
        .recipe-item::before { content: ''; }
        .recipe-item::after { display: none; }
        .recipe-item:hover { background: var(--bg-lighter); border-color: var(--text-muted); }
        .recipe-item.unavailable { opacity: 0.4; cursor: not-allowed; }
        .recipe-item.unavailable:hover { background: var(--bg-light); border-color: var(--border-color); }
        
        /* ===== OVERRIDE INLINE STYLES & DISABLE ANIMATIONS/GLOWS ===== */
        
        /* Disable all animations globally */
        *, *::before, *::after {
            animation: none !important;
            transition: none !important;
        }
        
        /* Re-enable only essential transitions for interactivity */
        button, .main-menu-btn, .inventory-slot, .crafting-slot, .category-tab, .keybind-btn,
        input[type="range"], .slider, .switch, .world-action-btn, .credits-back-btn {
            transition: background 0.1s, border-color 0.1s !important;
        }
        
        /* Override all box-shadows to flat style */
        * {
            box-shadow: none !important;
            text-shadow: none !important;
        }
        
        /* Override inline gradient backgrounds on buttons */
        .main-menu-btn,
        #main-controls button,
        .world-action-btn,
        .keybind-btn,
        .settings-category-btn,
        #death-respawn-btn,
        .category-tab,
        .credits-back-btn {
            background: var(--bg-light) !important;
            border-color: var(--border-color) !important;
            border-radius: 0 !important;
        }
        
        .main-menu-btn:hover,
        #main-controls button:hover,
        .world-action-btn:hover,
        .keybind-btn:hover,
        .settings-category-btn:hover,
        #death-respawn-btn:hover,
        .category-tab:hover,
        .credits-back-btn:hover {
            background: var(--bg-lighter) !important;
            border-color: var(--text-muted) !important;
            transform: none !important;
        }
        
        /* Primary action button (first button in controls) */
        #main-controls button:first-child {
            background: var(--accent) !important;
        }
        
        #main-controls button:first-child:hover {
            background: var(--accent-hover) !important;
        }
        
        /* Override pseudo-element overlays */
        .main-menu-btn::before,
        .world-action-btn::before,
        .keybind-btn::before,
        .settings-category-btn::before,
        .credits-back-btn::before,
        .recipe-item::after {
            display: none !important;
        }
        
        /* Force flat borders on modals/panels with inline styles */
        #keybinds-modal > div,
        #preset-comparison-modal > div,
        #quick-settings-modal > div,
        #model-customizer-modal > div {
            background: var(--bg-medium) !important;
            border: 1px solid var(--border-color) !important;
            border-radius: 0 !important;
        }
        
        /* Override green-accent inline borders */
        [style*="rgba(121, 192, 90"],
        [style*="rgba(140, 220, 100"] {
            border-color: var(--border-color) !important;
        }
        
        /* Ensure menus/containers stay flat */
        .menu-view,
        .inventory-container,
        #pause-menu .menu-view,
        .saved-world-card,
        .credit-card,
        .settings-category,
        #creative-panel,
        .rename-modal {
            border-radius: 0 !important;
        }
        
        /* Disable filter effects */
        * {
            filter: none !important;
        }
        
        /* ===== DISABLE MOUSE FOLLOW EFFECT ON MENU ===== */
        /* Force no transform on main menu elements to disable 3D parallax/follow */
        #main-menu h1,
        #main-menu .main-menu-btn,
        #main-controls button,
        .menu-view,
        .credits-container,
        .credit-card {
            transform: none !important;
        }
        
        /* Part selector buttons in model customizer */
        .part-selector-btn,
        .side-selector-btn {
            background: var(--bg-light) !important;
            border: 1px solid var(--border-color) !important;
            border-radius: 0 !important;
        }
        
        .part-selector-btn:hover,
        .side-selector-btn:hover {
            background: var(--bg-lighter) !important;
        }
        
        /* Active state */
        .part-selector-btn[style*="var(--main-action)"],
        .side-selector-btn[style*="var(--main-action)"] {
            background: var(--accent) !important;
        }
        
        /* Inputs with inline styles */
        input[type="text"],
        input[type="number"],
        select {
            background: var(--bg-dark) !important;
            border: 1px solid var(--border-color) !important;
            border-radius: 0 !important;
            color: var(--text-primary) !important;
        }
        
        input[type="text"]:focus,
        input[type="number"]:focus,
        select:focus {
            border-color: var(--accent) !important;
            outline: none !important;
        }
        
        /* Loading screen overrides */
        #loading-screen {
            background: var(--bg-dark) !important;
        }
        
        #loading-screen .loading-bar,
        .progress-bar {
            background: var(--accent) !important;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <canvas id="c"></canvas>
    <canvas id="starfield-bg"></canvas>
    
    <div id="main-menu">
        <div id="main-controls" class="menu-view">
            <h1>WEBCRAFT</h1>
            <button id="showCreationBtn" class="main-menu-btn">CREATE WORLD</button>
            <button id="showSavedWorldsBtn" class="main-menu-btn">SAVED WORLDS</button>
            <button id="showSettingsBtn" class="main-menu-btn">SETTINGS</button>
            <button id="showCreditsBtn" class="main-menu-btn">CREDITS</button>
        </div>
        <div id="creation-view" class="menu-view" style="display: none;">
            <h2>CREATE NEW WORLD</h2>
            <p style="font-size: 12px; color: #AAA; margin-bottom: 20px;">Customize your world settings</p>
            
            <div class="menu-control" style="margin-bottom: 15px;">
                <label for="seedInput" style="display: block; margin-bottom: 5px; font-size: 14px; color: #999;">World Seed</label>
                <input type="number" id="seedInput" placeholder="Random seed" style="width: 100%; padding: 10px; background: rgba(0,0,0,0.4); border: 2px solid rgba(255,255,255,0.2); color: white; font-family: inherit; border-radius: 0;">
            </div>
            
            <div class="menu-control" style="margin-bottom: 15px;">
                <label for="worldSizeSlider" style="display: block; margin-bottom: 5px; font-size: 14px; color: #999;">
                    World Size: <span id="worldSizeValue" style="color: white;">40</span> Chunks
                </label>
                <input type="range" id="worldSizeSlider" min="20" max="100" value="40" step="10" style="width: 100%; height: 30px; cursor: pointer; background: #333; border: none; padding: 0;">
                <p style="font-size: 11px; color: #888; margin-top: 5px;">Larger worlds may impact performance</p>
            </div>
            
            <div class="menu-control" style="margin-bottom: 25px;">
                <label for="flatWorldCheckbox" style="cursor: pointer; display: flex; align-items: center; gap: 10px; background: rgba(0,0,0,0.3); padding: 12px; border-radius: 0; border: 2px solid rgba(255,255,255,0.1);">
                    <label class="switch" style="margin-left: auto;">
                        <input type="checkbox" id="flatWorldCheckbox">
                        <span class="slider round"></span>
                    </label>
                    <span>Flat World (Superflat terrain)</span>
                </label>
            </div>
            
            <div class="menu-control" style="margin-bottom: 25px;">
                <label for="worldBorderCheckbox" style="cursor: pointer; display: flex; align-items: center; gap: 10px; background: rgba(0,0,0,0.3); padding: 12px; border-radius: 0; border: 2px solid rgba(255,255,255,0.1);">
                    <label class="switch" style="margin-left: auto;">
                        <input type="checkbox" id="worldBorderCheckbox" checked>
                        <span class="slider round"></span>
                    </label>
                    <span>World Border (Invisible barrier at world edge)</span>
                </label>
                <p style="font-size: 11px; color: #888; margin-top: 5px;">Prevents falling off the edge of the world</p>
            </div>
            
            <button id="createWorldBtn" class="main-menu-btn" style="background: var(--main-action); margin-bottom: 8px;">START GAME</button>
            <button id="backFromCreationBtn" class="main-menu-btn">BACK</button>
        </div>
        
        <!-- Fixed Back Button - OUTSIDE all menus, fixed to viewport -->
        <button id="backFromSettingsBtn" class="main-menu-btn fixed-back-btn" style="display: none; padding: 16px 40px; font-size: 16px; font-weight: 700; background: var(--main-action); border: 1px solid var(--border-color);">BACK TO MAIN MENU</button>
        <button id="backToSettingsBtn" class="main-menu-btn fixed-back-btn" onclick="backToSettingsMenu()" style="display: none; padding: 16px 40px; font-size: 16px; font-weight: 700; background: var(--main-action); border: 1px solid var(--border-color);">BACK TO SETTINGS</button>
        
        <!-- Settings Main Menu -->
        <div id="settings-view" class="menu-view" style="display: none;">
            <h2>SETTINGS</h2>
            
            <!-- Search Bar -->
            <div style="margin-bottom: 20px;">
                <input 
                    type="text" 
                    id="settingsSearchInput" 
                    placeholder="Search any setting..." 
                    style="width: 100%; max-width: 1200px; padding: 12px 16px; background: rgba(0,0,0,0.6); border: 1px solid var(--border-color); border-radius: 0; color: white; font-family: inherit; font-size: 14px;"
                    oninput="searchSettings(this.value)"
                />
                <div id="searchResults" style="display: none; margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.8); border-radius: 0; max-width: 1200px;"></div>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; max-width: 1200px; width: 100%; align-items: start;">
                <!-- Left Column: Quick Settings & Detailed Settings -->
                <div>
                    <!-- Graphics Presets -->
                    <div style="margin-bottom: 25px; padding: 20px; background: rgba(0,0,0,0.4); border-radius: 0; border: 1px solid var(--border-color);">
                        <h3 style="font-size: 16px; color: var(--text-secondary); margin: 0 0 15px 0; letter-spacing: 1px;">GRAPHICS PRESETS</h3>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <select id="graphicsPreset" style="flex: 1; padding: 12px; background: rgba(0,0,0,0.6); border: 1px solid var(--border-color); border-radius: 0; color: white; font-family: inherit; font-size: 14px; cursor: pointer;">
                                <option value="">Select a preset...</option>
                                <option value="ultra">ULTRA (Best Quality)</option>
                                <option value="high">HIGH</option>
                                <option value="medium">MEDIUM</option>
                                <option value="low">LOW</option>
                                <option value="potato">POTATO (Best Performance)</option>
                            </select>
                            <button id="comparePresetBtn" class="main-menu-btn" style="margin: 0; padding: 12px 20px; font-size: 13px;" onclick="showPresetComparison()">COMPARE</button>
                        </div>
                    </div>
                    
                    <!-- Quick Settings (Customizable) - Enhanced -->
                    <div style="margin-bottom: 30px; padding: 25px; background: var(--bg-dark); border-radius: 0; border: 1px solid var(--border-color);">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 18px;">
                            <h3 style="font-size: 18px; color: var(--text-secondary); margin: 0; letter-spacing: 1px;">QUICK SETTINGS</h3>
                            <button class="main-menu-btn" style="margin: 0; padding: 10px 18px; font-size: 13px; background: var(--main-action); font-weight: 600;" onclick="customizeQuickSettings()">CUSTOMIZE</button>
                        </div>
                        <div id="quickSettingsContainer" style="display: grid; grid-template-columns: 1fr; gap: 18px;">
                            <!-- Quick settings will be dynamically populated -->
                        </div>
                    </div>
                    
        <!-- Detailed Settings Categories - Redesigned Grid -->
        <div style="margin-bottom: 20px;">
            <h3 style="font-size: 16px; color: var(--text-secondary); margin: 0 0 15px 0; letter-spacing: 1px;">DETAILED SETTINGS</h3>
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">
                <button class="main-menu-btn" onclick="showVideoSettings()" style="padding: 20px 15px; font-size: 14px; display: flex; flex-direction: column; align-items: center; gap: 8px;">
                    <span style="font-weight: 600;">VIDEO</span>
                </button>
                <button class="main-menu-btn" onclick="showControlSettings()" style="padding: 20px 15px; font-size: 14px; display: flex; flex-direction: column; align-items: center; gap: 8px;">
                    <span style="font-weight: 600;">CONTROLS</span>
                </button>
                <button class="main-menu-btn" onclick="showAudioSettings()" style="padding: 20px 15px; font-size: 14px; display: flex; flex-direction: column; align-items: center; gap: 8px;">
                    <span style="font-weight: 600;">AUDIO</span>
                </button>
                <button class="main-menu-btn" onclick="openModelCustomizer()" style="padding: 20px 15px; font-size: 14px; display: flex; flex-direction: column; align-items: center; gap: 8px;">
                    <span style="font-weight: 600;">CUSTOMIZE MODEL</span>
                </button>
            </div>
        </div>
                </div>
                
                <!-- Right Column: History & Backup -->
                <div>
                    <!-- Settings History -->
                    <div style="margin-bottom: 20px; padding: 20px; background: rgba(0,0,0,0.4); border-radius: 0; border: 1px solid var(--border-color);">
                        <h3 style="font-size: 16px; color: var(--text-secondary); margin: 0 0 15px 0; letter-spacing: 1px;">CHANGE HISTORY</h3>
                        <div id="settings-history" style="max-height: 350px; overflow-y: auto; font-size: 12px; margin-bottom: 12px;">
                            <p style="font-size: 12px; color: #666; text-align: center; padding: 20px;">No recent changes</p>
                        </div>
                        <button class="main-menu-btn" onclick="clearSettingsHistory()" style="width: 100%; font-size: 12px; padding: 10px; margin-top: 8px;">CLEAR HISTORY</button>
                    </div>
                    
                    <!-- Backup & Restore -->
                    <div style="padding: 15px; background: rgba(0,0,0,0.4); border-radius: 0; border: 1px solid var(--border-color);">
                        <h3 style="font-size: 14px; color: var(--text-secondary); margin: 0 0 10px 0; letter-spacing: 1px;">BACKUP</h3>
                        <div style="display: flex; flex-direction: column; gap: 6px;">
                            <button class="main-menu-btn" onclick="exportSettings()" style="width: 100%; font-size: 11px; padding: 8px;">
                                EXPORT SETTINGS
                            </button>
                            <button class="main-menu-btn" onclick="exportWorlds()" style="width: 100%; font-size: 11px; padding: 8px;">
                                EXPORT WORLDS
                            </button>
                            <button class="main-menu-btn" onclick="exportAll()" style="width: 100%; font-size: 11px; padding: 8px; background: var(--main-action);">
                                EXPORT ALL DATA
                            </button>
                            <button class="main-menu-btn" onclick="document.getElementById('importFileInput').click()" style="width: 100%; font-size: 11px; padding: 8px;">
                                IMPORT
                            </button>
                        </div>
                        <input type="file" id="importFileInput" accept=".json" style="display: none;" onchange="importData(event)">
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Video Settings Category -->
        <div id="video-settings-view" class="menu-view" style="display: none;">
            <h2>VIDEO SETTINGS</h2>
            
            <div class="settings-category" style="margin: 20px 0; max-width: 1000px; width: 100%;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <div class="setting-item">
                        <div class="setting-label">
                            <span>Render Distance</span>
                            <span class="setting-value" id="renderDistanceValue">20</span><span style="color: #999;"> blocks</span>
                            <span style="color: #888; font-size: 0.9em; margin-left: 8px;" id="renderDistanceDefault">Default</span>
                        </div>
                        <input type="range" class="custom-slider" id="renderDistanceSlider" min="10" max="50" value="20" step="1">
                        <div class="setting-description">How far you can see. Higher values impact performance.</div>
                    </div>
                    
                    <div class="setting-item">
                        <div class="setting-label">
                            <span>Field of View</span>
                            <span class="setting-value" id="fovValue">75</span><span style="color: #999;"></span>
                            <span style="color: #888; font-size: 0.9em; margin-left: 8px;" id="fovDefault">Default</span>
                        </div>
                        <input type="range" class="custom-slider" id="fovSlider" min="50" max="110" value="75" step="1">
                        <div class="setting-description">Camera zoom. Higher values show more.</div>
                    </div>
                </div>
                
                <div style="margin-top: 30px;">
                    <div class="setting-item">
                        <div style="display: flex; align-items: center; justify-content: space-between;">
                            <div>
                                <div class="setting-label">
                                    <span>Enable Shadows</span>
                                    <span style="color: #ff6b6b; font-size: 0.8em; margin-left: 8px;">EXPERIMENTAL</span>
                                </div>
                                <div class="setting-description">Toggle shadows (experimental and buggy).</div>
                            </div>
                            <label class="switch">
                                <input type="checkbox" id="shadowsToggle">
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Reset Button -->
            <button class="main-menu-btn" id="resetVideoBtn" style="margin-top: 20px; max-width: 800px; width: 100%; margin-bottom: 80px;">RESET TO DEFAULTS</button>
        </div>
        
        <!-- Controls Settings Category -->
        <div id="controls-settings-view" class="menu-view" style="display: none;">
            <h2>CONTROLS</h2>
            
            <div class="settings-category" style="margin: 20px 0; max-width: 1000px; width: 100%;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <div class="setting-item">
                        <div class="setting-label">
                            <span>Mouse Sensitivity</span>
                            <span class="setting-value" id="sensitivityValue">100</span><span style="color: #999;">%</span>
                            <span style="color: #888; font-size: 0.9em; margin-left: 8px;" id="sensitivityDefault">Default</span>
                        </div>
                        <input type="range" class="custom-slider" id="sensitivitySlider" min="25" max="200" value="100" step="1">
                        <div class="setting-description">Camera rotation speed when moving mouse.</div>
                    </div>
                    
                    <div class="setting-item">
                        <div class="setting-label">
                            <span>Keybinds</span>
                            <button id="openKeybindsModalBtn" style="padding: 10px 20px; background: var(--bg-light); color: white; border: 1px solid var(--border-color); border-radius: 0; cursor: pointer; font-family: inherit; font-weight: 600; font-size: 14px;">CUSTOMIZE</button>
                        </div>
                        <div class="setting-description">Customize movement and action keys.</div>
                    </div>
                    
                    <div class="setting-item">
                        <div class="setting-label">
                            <span>Fullscreen Mode</span>
                            <button id="fullscreenBtn" style="padding: 10px 20px; background: var(--bg-light); color: white; border: 1px solid var(--border-color); border-radius: 0; cursor: pointer; font-family: inherit; font-weight: 600; font-size: 14px;">ENTER FULLSCREEN</button>
                        </div>
                        <div class="setting-description">Press F11 or click to toggle. Locks keyboard for game controls.</div>
                    </div>
                </div>
                
                <h3 style="margin: 30px 0 20px 0; color: var(--text-secondary); text-align: center;">Hand Settings</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px;">
                    <div class="setting-item">
                        <div class="setting-label">
                            <span>Bob Intensity</span>
                            <span class="setting-value" id="handBobIntensityValue">100</span><span style="color: #999;">%</span>
                            <span style="color: #888; font-size: 0.9em; margin-left: 8px;" id="handBobIntensityDefault">Default</span>
                        </div>
                        <input type="range" class="custom-slider" id="handBobIntensitySlider" min="0" max="200" value="100" step="1">
                        <div class="setting-description">How much the hand moves while walking.</div>
                    </div>
                </div>
            </div>
            
            <!-- Reset Button -->
            <button class="main-menu-btn" id="resetControlsBtn" style="margin-top: 20px; max-width: 800px; width: 100%; margin-bottom: 80px;">RESET TO DEFAULTS</button>
        </div>
        
        <!-- Audio Settings Category -->
        <div id="audio-settings-view" class="menu-view" style="display: none;">
            <h2>AUDIO SETTINGS</h2>
            
            <div class="settings-category" style="margin: 20px 0; max-width: 1000px; width: 100%;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <div class="setting-item">
                        <div class="setting-label">
                            <span>Master Volume</span>
                            <span class="setting-value" id="masterVolumeValue">100</span><span style="color: #999;">%</span>
                            <span style="color: #888; font-size: 0.9em; margin-left: 8px;" id="masterVolumeDefault">Default</span>
                        </div>
                        <input type="range" class="custom-slider" id="masterVolumeSlider" min="0" max="100" value="100" step="1">
                        <div class="setting-description">Controls all game audio.</div>
                    </div>
                    
                    <div class="setting-item">
                        <div class="setting-label">
                            <span>Music Volume</span>
                            <span class="setting-value" id="musicVolumeValue">50</span><span style="color: #999;">%</span>
                            <span style="color: #888; font-size: 0.9em; margin-left: 8px;" id="musicVolumeDefault">Default</span>
                        </div>
                        <input type="range" class="custom-slider" id="musicVolumeSlider" min="0" max="100" value="50" step="1">
                        <div class="setting-description">Background music in menus and pause.</div>
                    </div>
                    
                    <div class="setting-item">
                        <div class="setting-label">
                            <span>SFX Volume</span>
                            <span class="setting-value" id="sfxVolumeValue">70</span><span style="color: #999;">%</span>
                            <span style="color: #888; font-size: 0.9em; margin-left: 8px;" id="sfxVolumeDefault">Default</span>
                        </div>
                        <input type="range" class="custom-slider" id="sfxVolumeSlider" min="0" max="100" value="70" step="1">
                        <div class="setting-description">Button clicks and game sounds.</div>
                    </div>
                    
                    <div class="setting-item">
                        <div class="setting-label">
                            <span>Tab Out Mute</span>
                            <span class="setting-value" id="tabOutMuteValue">100</span><span style="color: #999;">%</span>
                            <span style="color: #888; font-size: 0.9em; margin-left: 8px;" id="tabOutMuteDefault">Default</span>
                        </div>
                        <input type="range" class="custom-slider" id="tabOutMuteSlider" min="0" max="100" value="100" step="1">
                        <div class="setting-description">Audio reduction when tabbed out (0% = no mute, 100% = silent).</div>
                    </div>
                    
                    <div class="setting-item">
                        <div class="setting-label">
                            <span>Show Music Toast</span>
                            <label class="switch" style="margin-left: auto;">
                                <input type="checkbox" id="showMusicToastToggle" checked>
                                <span class="slider round"></span>
                            </label>
                        </div>
                        <div class="setting-description">Show/hide music notification during gameplay. Can only be disabled from pause menu.</div>
                    </div>
                    
                    <div class="setting-item">
                        <div class="setting-label">
                            <span>Music Toast Position</span>
                            <select id="musicToastPositionSelector" style="padding: 8px 12px; background: rgba(0,0,0,0.6); color: white; border: 2px solid rgba(255,255,255,0.3); border-radius: 4px; cursor: pointer; font-family: inherit; font-size: 14px; min-width: 150px; margin-left: auto;">
                                <option value="top-left"> Top Left</option>
                                <option value="top-right"> Top Right</option>
                                <option value="bottom-left"> Bottom Left</option>
                                <option value="bottom-right"> Bottom Right</option>
                            </select>
                        </div>
                        <div class="setting-description">Choose where the music toast appears on screen</div>
                    </div>
                    
                    <div class="setting-item">
                        <div class="setting-label">
                            <span>Music Track</span>
                            <select id="musicTrackSelector" style="padding: 8px 12px; background: rgba(0,0,0,0.6); color: white; border: 2px solid rgba(255,255,255,0.3); border-radius: 4px; cursor: pointer; font-family: inherit; font-size: 14px; min-width: 200px;">
                                <option value="random"> Random</option>
                                <option value="0"> Peaceful Dawn</option>
                                <option value="1"> Sunny Meadow</option>
                                <option value="2"> Moonlit Cave</option>
                                <option value="3"> Starry Night</option>
                                <option value="4"> Autumn Forest</option>
                                <option value="5"> Mountain Peak</option>
                            </select>
                        </div>
                        <div class="setting-description">Choose which music track plays in menus.</div>
                    </div>
                </div>
            </div>
            
            <!-- Reset Button -->
            <button class="main-menu-btn" id="resetAudioBtn" style="margin-top: 20px; max-width: 800px; width: 100%; margin-bottom: 80px;">RESET TO DEFAULTS</button>
        </div>
        
        <!-- Theme Settings Category -->
        <div id="theme-settings-view" class="menu-view" style="display: none;">
            <h2>THEME SETTINGS</h2>
            
            <div class="settings-category" style="margin: 20px 0; max-width: 1000px; width: 100%;">
                <div style="display: grid; grid-template-columns: 1fr; gap: 25px;">
                    <div class="setting-item">
                        <div class="setting-label">
                            <span>Parallax Effect Color</span>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-top: 10px;">
                            <button class="theme-color-btn" data-color="transparent" style="background: transparent; height: 50px; border: 1px solid #666; border-radius: 0; cursor: pointer;" onclick="setParallaxColor('transparent')">Clear</button>
                            <button class="theme-color-btn" data-color="rgba(50, 0, 100, 0.7)" style="background: rgba(50, 0, 100, 0.7); height: 50px; border: 1px solid #666; border-radius: 0; cursor: pointer;" onclick="setParallaxColor('rgba(50, 0, 100, 0.7)')">Purple</button>
                            <button class="theme-color-btn" data-color="rgba(0, 100, 50, 0.7)" style="background: rgba(0, 100, 50, 0.7); height: 50px; border: 1px solid #666; border-radius: 0; cursor: pointer;" onclick="setParallaxColor('rgba(0, 100, 50, 0.7)')">Green</button>
                            <button class="theme-color-btn" data-color="rgba(0, 50, 100, 0.7)" style="background: rgba(0, 50, 100, 0.7); height: 50px; border: 1px solid #666; border-radius: 0; cursor: pointer;" onclick="setParallaxColor('rgba(0, 50, 100, 0.7)')">Blue</button>
                            <button class="theme-color-btn" data-color="rgba(100, 100, 0, 0.7)" style="background: rgba(100, 100, 0, 0.7); height: 50px; border: 1px solid #666; border-radius: 0; cursor: pointer;" onclick="setParallaxColor('rgba(100, 100, 0, 0.7)')">Yellow</button>
                            <button class="theme-color-btn" data-color="rgba(100, 50, 0, 0.7)" style="background: rgba(100, 50, 0, 0.7); height: 50px; border: 1px solid #666; border-radius: 0; cursor: pointer;" onclick="setParallaxColor('rgba(100, 50, 0, 0.7)')">Orange</button>
                            <button class="theme-color-btn" data-color="rgba(50, 50, 50, 0.7)" style="background: rgba(50, 50, 50, 0.7); height: 50px; border: 1px solid #666; border-radius: 0; cursor: pointer;" onclick="setParallaxColor('rgba(50, 50, 50, 0.7)')">Gray</button>
                            <button class="theme-color-btn" data-color="rgba(0, 0, 0, 0.9)" style="background: rgba(0, 0, 0, 0.9); height: 50px; border: 1px solid #666; border-radius: 0; cursor: pointer;" onclick="setParallaxColor('rgba(0, 0, 0, 0.9)')">Black</button>
                        </div>
                        <div class="setting-description">Choose the background color for parallax animation.</div>
                    </div>
                    
                    <div class="setting-item">
                        <div class="setting-label">
                            <span>Parallax Speed</span>
                            <span class="setting-value" id="parallaxSpeedValue">120</span><span style="color: #999;">s</span>
                        </div>
                        <input type="range" class="custom-slider" id="parallaxSpeedSlider" min="20" max="200" value="120" step="10">
                        <div class="setting-description">Animation speed (lower = faster, higher = slower).</div>
                    </div>
                    
                    
                </div>
            </div>
            
            <!-- Reset Button -->
            <button class="main-menu-btn" onclick="resetThemeSettings()" style="margin-top: 20px; max-width: 800px; width: 100%; margin-bottom: 80px;">RESET TO DEFAULTS</button>
        </div>
        
        <div id="saved-worlds-view" class="menu-view" style="display: none;">
            <h2>SAVED WORLDS</h2>
            <p style="font-size: 12px; color: #AAA; margin-bottom: 20px;">Load or manage your saved worlds</p>
            <div id="saved-worlds-list" style="max-height: 400px; overflow-y: auto; width: 100%; margin-bottom: 20px; padding: 5px;">
                <!-- Saved worlds will be listed here -->
            </div>
            <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                <button id="backFromSavedWorldsBtn" class="main-menu-btn">BACK</button>
                <button id="deleteAllWorldsBtn" class="main-menu-btn" style="background: var(--warning-color);">DELETE ALL WORLDS</button>
            </div>
        </div>
        <div id="credits-view" class="menu-view epic-credits-view" style="display: none;">
            <h2 class="credits-title">CREDITS</h2>
            <div class="credits-container">
                <div class="credit-card">
                    <div class="credit-content">
                        <div class="credit-role">Concept</div>
                        <div class="credit-name">Matko802</div>
                    </div>
                </div>
                
                <div class="credit-card">
                    <div class="credit-content">
                        <div class="credit-role">Code</div>
                        <div class="credit-name">Gemini, Lovable</div>
                    </div>
                </div>
                
                <div class="credit-card">
                    <div class="credit-content">
                        <div class="credit-role">Inspired By</div>
                        <div class="credit-name">Minecraft (Mojang AB)</div>
                    </div>
                </div>
            </div>
            <button id="backFromCreditsBtn" class="main-menu-btn credits-back-btn">BACK</button>
        </div>
    </div>
    
    <div id="inventory-screen">
        <div class="inventory-container">
            <h2>INVENTORY & CRAFTING</h2>
            
            <div class="inventory-main-section">
                <!-- Left Side: Storage & Hotbar -->
                <div class="inventory-storage-area">
                    <div class="inventory-section-label">Storage (24 slots)</div>
                    <div id="main-inventory-grid"></div>
                    
                    <div class="inventory-section-label">Hotbar (Quick Access)</div>
                    <div id="hud-inventory-grid"></div>
                    
                    <div id="creative-panel">
                        <div id="creative-picker-wrapper">
                            <div class="inventory-section-label">Creative Items</div>
                            <div id="category-tabs">
                                <button class="category-tab active" data-category="all">All</button>
                                <button class="category-tab" data-category="blocks">Blocks</button>
                                <button class="category-tab" data-category="nature">Nature</button>
                                <button class="category-tab" data-category="decorative">Decorative</button>
                                <button class="category-tab" data-category="tools">Tools</button>
                                <button class="category-tab" data-category="liquids">Liquids</button>
                            </div>
                            <div id="creative-block-picker"></div>
                        </div>
                        <div id="delete-wrapper">
                            <div class="inventory-section-label" style="color: var(--warning-color);">Delete</div>
                            <div id="delete-slot"></div>
                        </div>
                    </div>
                </div>
                
                <!-- Right Side: Crafting -->
                <div id="crafting-panel">
                    <div id="crafting-title">CRAFTING TABLE</div>
                    
                    <div class="crafting-area">
                        <div id="crafting-grid"></div>
                        <div id="crafting-arrow">-></div>
                        <div id="crafting-output"></div>
                    </div>
                    
                    <div class="recipe-list-header">AVAILABLE RECIPES</div>
                    <div id="crafting-recipes-wrapper">
                        <div id="crafting-recipes">
                            <div id="crafting-recipes-content"></div>
                        </div>
                        <div class="custom-scrollbar">
                            <div class="custom-scrollbar-thumb"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <button id="gameModeToggleBtn">Switch to Survival</button>
            
            <!-- Helper Text -->
            <div style="text-align: center; font-size: 10px; color: #888; margin-top: 5px; line-height: 1.4;">
                <strong>Tips:</strong> Click items to pick up - Right-click to split stacks - Hover for details
            </div>
        </div>
        
        <div id="picked-up-item"></div> 
    </div>

    
    <div id="fake-cursor"></div> <div id="ui"></div>
    <div id="fps"></div>
    <div id="debug-info" style="position: absolute; top: 4px; right: 4px; color: #ffffff; background: none; padding: 4px 8px; border: none; font-size: 12px; font-family: monospace; line-height: 1.5; text-shadow: 1px 1px 0px rgba(0, 0, 0, 0.8); display: none; z-index: 5; pointer-events: none; text-align: right;">DEBUG MODE: Hitbox ON</div>
    <div id="looking-at-info" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, calc(-50% + 40px)); color: #ffffff; background: rgba(0, 0, 0, 0.7); padding: 4px 12px; border-radius: 4px; font-size: 14px; display: none; z-index: 5; pointer-events: none; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8); border: 1px solid rgba(255, 255, 255, 0.3);"></div>
    <div id="crosshair"></div>
    <div id="health-container"></div>
    <div id="oxygen-container"></div>
    <div id="movement-status"></div>
    <div id="toolbar"></div>
    <div id="held-item-info">
        <div class="item-name"></div>
        <div class="item-count"></div>
        <div class="durability-bar-container" style="display: none;">
            <div class="durability-bar"></div>
        </div>
        <div class="durability-text"></div>
    </div>
    
    <div id="death-screen">
        <h1>YOU DIED</h1>
        <p>Score: <span id="death-score">0</span></p>
        <button id="death-respawn-btn">RESPAWN</button>
    </div>
    
    <div id="pause-menu">
        <div class="menu-view">
            <h2>GAME STOPPED</h2>
            <div class="menu-control" style="width: 300px;">
                <label for="settingsSeedInput">Current Seed:</label>
                <input type="number" id="settingsSeedInput" readonly>
            </div>
            <p id="current-world-name" style="font-size: 14px; color: #aaa; margin-top: 10px;"></p>
            
            <button id="main-menu-btn-pause" class="main-menu-btn" style="background: var(--main-action); width: 300px; margin-top: 20px;">
                CONTINUE GAME (ESC)
            </button>
            <button id="respawn-btn" class="main-menu-btn" style="background: #FF9800; width: 300px; margin-top: 10px;">
                RESPAWN
            </button>
            <button id="save-world-btn" class="main-menu-btn" style="background: #2196F3; width: 300px; margin-top: 10px;">
                SAVE WORLD
            </button>
            <button id="pause-settings-btn" class="main-menu-btn" style="width: 300px; margin-top: 10px;">
                 SETTINGS
            </button>
            <button id="exit-to-menu-btn" class="main-menu-btn" style="background: var(--warning-color); width: 300px; margin-top: 10px;">
                EXIT TO MAIN MENU
            </button>
        </div>
    </div>

    <div id="version-text">Dev Test v1.8.0</div>
    
    <!-- Music Toast - REMOVED (music will be added later) -->

    <!-- Keybinds Customization Modal -->
    <div id="keybinds-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 3000; align-items: center; justify-content: center;">
        <div style="background: var(--menu-bg-accent); padding: 40px; border-radius: 8px; border: 3px solid #666; max-width: 700px; width: 90%; text-align: center;">
            <h2 style="color: white; margin-bottom: 10px;">CUSTOMIZE KEYBINDS</h2>
            <p style="color: #aaa; margin-bottom: 30px; font-size: 14px;">Click any button below and press a key to rebind</p>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 30px;">
                <div class="keybind-item">
                    <label style="color: white; display: block; margin-bottom: 8px; font-size: 14px;">Forward:</label>
                    <button class="keybind-btn" data-action="forward" style="width: 100%; padding: 12px; background: rgba(0, 191, 255, 0.2); color: white; border: 2px solid var(--main-action); border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; font-size: 14px; transition: all 0.2s;">W</button>
                </div>
                
                <div class="keybind-item">
                    <label style="color: white; display: block; margin-bottom: 8px; font-size: 14px;">Backward:</label>
                    <button class="keybind-btn" data-action="backward" style="width: 100%; padding: 12px; background: rgba(0, 191, 255, 0.2); color: white; border: 2px solid var(--main-action); border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; font-size: 14px; transition: all 0.2s;">S</button>
                </div>
                
                <div class="keybind-item">
                    <label style="color: white; display: block; margin-bottom: 8px; font-size: 14px;">Left:</label>
                    <button class="keybind-btn" data-action="left" style="width: 100%; padding: 12px; background: rgba(0, 191, 255, 0.2); color: white; border: 2px solid var(--main-action); border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; font-size: 14px; transition: all 0.2s;">A</button>
                </div>
                
                <div class="keybind-item">
                    <label style="color: white; display: block; margin-bottom: 8px; font-size: 14px;">Right:</label>
                    <button class="keybind-btn" data-action="right" style="width: 100%; padding: 12px; background: rgba(0, 191, 255, 0.2); color: white; border: 2px solid var(--main-action); border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; font-size: 14px; transition: all 0.2s;">D</button>
                </div>
                
                <div class="keybind-item">
                    <label style="color: white; display: block; margin-bottom: 8px; font-size: 14px;">Jump / Swim Up:</label>
                    <button class="keybind-btn" data-action="jump" style="width: 100%; padding: 12px; background: rgba(0, 191, 255, 0.2); color: white; border: 2px solid var(--main-action); border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; font-size: 14px; transition: all 0.2s;">SPACE</button>
                </div>
                
                <div class="keybind-item">
                    <label style="color: white; display: block; margin-bottom: 8px; font-size: 14px;">Sneak / Swim Down:</label>
                    <button class="keybind-btn" data-action="sneak" style="width: 100%; padding: 12px; background: rgba(0, 191, 255, 0.2); color: white; border: 2px solid var(--main-action); border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; font-size: 14px; transition: all 0.2s;">SHIFT</button>
                </div>
                
                <div class="keybind-item">
                    <label style="color: white; display: block; margin-bottom: 8px; font-size: 14px;">Inventory:</label>
                    <button class="keybind-btn" data-action="inventory" style="width: 100%; padding: 12px; background: rgba(0, 191, 255, 0.2); color: white; border: 2px solid var(--main-action); border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; font-size: 14px; transition: all 0.2s;">E</button>
                </div>
                
                <div class="keybind-item">
                    <label style="color: white; display: block; margin-bottom: 8px; font-size: 14px;">Pause Menu:</label>
                    <button class="keybind-btn" data-action="pause" style="width: 100%; padding: 12px; background: rgba(0, 191, 255, 0.2); color: white; border: 2px solid var(--main-action); border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; font-size: 14px; transition: all 0.2s;">ESC</button>
                </div>
            </div>
            
            <div style="display: flex; gap: 15px; justify-content: center;">
                <button class="main-menu-btn" id="resetKeybindsBtn" style="width: 200px; padding: 12px;">RESET KEYBINDS</button>
                <button class="main-menu-btn" id="closeKeybindsModalBtn" style="width: 200px; padding: 12px; background: var(--main-action);">DONE</button>
            </div>
        </div>
    </div>

    <!-- Preset Comparison Modal -->
    <div id="preset-comparison-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 3000; align-items: center; justify-content: center;">
        <div style="background: var(--menu-bg-accent); padding: 30px; border-radius: 8px; border: 3px solid #666; max-width: 700px; width: 90%;">
            <h2 style="color: white; margin-bottom: 20px; text-shadow: 3px 3px 0 rgba(0, 0, 0, 0.8);"> PRESET COMPARISON</h2>
            
            <div style="margin-bottom: 20px;">
                <label style="color: white; display: block; margin-bottom: 10px;">Select Preset to Compare:</label>
                <select id="presetCompareSelect" style="width: 100%; padding: 12px; background: rgba(0,0,0,0.6); border: 2px solid rgba(255,255,255,0.3); border-radius: 4px; color: white; font-family: inherit; font-size: 14px;">
                    <option value="ultra">ULTRA</option>
                    <option value="high">HIGH</option>
                    <option value="medium">MEDIUM</option>
                    <option value="low">LOW</option>
                    <option value="potato">POTATO</option>
                </select>
            </div>
            
            <div id="comparisonTable" style="background: rgba(0,0,0,0.4); padding: 15px; border-radius: 4px; margin-bottom: 20px;">
                <!-- Comparison table will be generated here -->
            </div>
            
            <div style="display: flex; gap: 15px; justify-content: center;">
                <button class="main-menu-btn" onclick="applyComparedPreset()" style="width: 200px; padding: 12px; background: var(--main-action);"> APPLY PRESET</button>
                <button class="main-menu-btn" onclick="closePresetComparison()" style="width: 200px; padding: 12px;"> CANCEL</button>
            </div>
        </div>
    </div>

    <!-- Quick Settings Customization Modal -->
    <div id="quick-settings-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 3000; align-items: center; justify-content: center;">
        <div style="background: var(--menu-bg-accent); padding: 30px; border-radius: 8px; border: 3px solid #666; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto;">
            <h2 style="color: white; margin-bottom: 20px; text-shadow: 3px 3px 0 rgba(0, 0, 0, 0.8);"> CUSTOMIZE QUICK SETTINGS</h2>
            <p style="color: #aaa; margin-bottom: 20px; font-size: 13px;">Select up to 6 settings to show in Quick Settings</p>
            
            <div id="quickSettingsOptions" style="display: grid; grid-template-columns: 1fr; gap: 10px;">
                <!-- Options will be generated here -->
            </div>
            
            <div style="display: flex; gap: 15px; justify-content: center; margin-top: 20px;">
                <button class="main-menu-btn" onclick="saveQuickSettings()" style="width: 200px; padding: 12px; background: var(--main-action);"> SAVE</button>
                <button class="main-menu-btn" onclick="closeQuickSettingsModal()" style="width: 200px; padding: 12px;"> CANCEL</button>
            </div>
        </div>
    </div>

    <!-- Model Texture Customization Modal -->
    <div id="model-customizer-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 3000; align-items: center; justify-content: center;">
        <div style="background: var(--menu-bg-accent); padding: 30px; border-radius: 8px; border: 3px solid #666; max-width: 800px; width: 95%; max-height: 90vh; overflow-y: auto;">
            <h2 style="color: white; margin-bottom: 15px; text-shadow: 3px 3px 0 rgba(0, 0, 0, 0.8);"> CUSTOMIZE MODEL TEXTURES</h2>
            <p style="color: #aaa; margin-bottom: 20px; font-size: 13px;">Paint textures for each body part and side. Click pixels to paint!</p>
            
            <!-- Body Part Selector -->
            <div style="margin-bottom: 20px; text-align: center;">
                <label style="color: white; display: block; margin-bottom: 10px; font-weight: 600;">Select Body Part:</label>
                <div style="display: flex; gap: 8px; justify-content: center; flex-wrap: wrap;">
                    <button class="part-selector-btn" data-part="head" onclick="selectBodyPart('head')" style="padding: 10px 20px; background: var(--main-action); color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; transition: all 0.2s;">Head</button>
                    <button class="part-selector-btn" data-part="headLayer" onclick="selectBodyPart('headLayer')" style="padding: 10px 20px; background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; transition: all 0.2s;">Hat</button>
                    <button class="part-selector-btn" data-part="torso" onclick="selectBodyPart('torso')" style="padding: 10px 20px; background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; transition: all 0.2s;">Torso</button>
                    <button class="part-selector-btn" data-part="torsoLayer" onclick="selectBodyPart('torsoLayer')" style="padding: 10px 20px; background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; transition: all 0.2s;">Jacket</button>
                    <button class="part-selector-btn" data-part="leftArm" onclick="selectBodyPart('leftArm')" style="padding: 10px 20px; background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; transition: all 0.2s;">Left Arm</button>
                    <button class="part-selector-btn" data-part="leftArmLayer" onclick="selectBodyPart('leftArmLayer')" style="padding: 10px 20px; background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; transition: all 0.2s;">L Sleeve</button>
                    <button class="part-selector-btn" data-part="rightArm" onclick="selectBodyPart('rightArm')" style="padding: 10px 20px; background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; transition: all 0.2s;">Right Arm</button>
                    <button class="part-selector-btn" data-part="rightArmLayer" onclick="selectBodyPart('rightArmLayer')" style="padding: 10px 20px; background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; transition: all 0.2s;">R Sleeve</button>
                    <button class="part-selector-btn" data-part="leftLeg" onclick="selectBodyPart('leftLeg')" style="padding: 10px 20px; background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; transition: all 0.2s;">Left Leg</button>
                    <button class="part-selector-btn" data-part="leftLegLayer" onclick="selectBodyPart('leftLegLayer')" style="padding: 10px 20px; background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; transition: all 0.2s;">L Pants</button>
                    <button class="part-selector-btn" data-part="rightLeg" onclick="selectBodyPart('rightLeg')" style="padding: 10px 20px; background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; transition: all 0.2s;">Right Leg</button>
                    <button class="part-selector-btn" data-part="rightLegLayer" onclick="selectBodyPart('rightLegLayer')" style="padding: 10px 20px; background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; transition: all 0.2s;">R Pants</button>
                </div>
            </div>
            
            <!-- Side Selector -->
            <div style="margin-bottom: 20px; text-align: center;">
                <label style="color: white; display: block; margin-bottom: 10px; font-weight: 600;">Select Side:</label>
                <div style="display: flex; gap: 8px; justify-content: center; flex-wrap: wrap;">
                    <button class="side-selector-btn" data-side="front" onclick="selectTextureSide('front')" style="padding: 8px 16px; background: var(--main-action); color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; transition: all 0.2s; font-size: 12px;">Front</button>
                    <button class="side-selector-btn" data-side="back" onclick="selectTextureSide('back')" style="padding: 8px 16px; background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; transition: all 0.2s; font-size: 12px;">Back</button>
                    <button class="side-selector-btn" data-side="left" onclick="selectTextureSide('left')" style="padding: 8px 16px; background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; transition: all 0.2s; font-size: 12px;">Left</button>
                    <button class="side-selector-btn" data-side="right" onclick="selectTextureSide('right')" style="padding: 8px 16px; background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; transition: all 0.2s; font-size: 12px;">Right</button>
                    <button class="side-selector-btn" data-side="top" onclick="selectTextureSide('top')" style="padding: 8px 16px; background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; transition: all 0.2s; font-size: 12px;">Top</button>
                    <button class="side-selector-btn" data-side="bottom" onclick="selectTextureSide('bottom')" style="padding: 8px 16px; background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 600; transition: all 0.2s; font-size: 12px;">Bottom</button>
                </div>
            </div>
            
            <!-- Display Options -->
            <div style="margin-bottom: 20px; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 8px; border: 2px solid rgba(121, 192, 90, 0.3);">
                <h3 style="color: white; margin-bottom: 15px; font-size: 14px; text-align: center; text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.8);">Display Options</h3>
                
                <!-- Show Skin Layers -->
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 4px;">
                    <span style="color: white; font-size: 13px;">Show Skin Layers</span>
                    <label class="switch" style="margin-left: auto;">
                        <input type="checkbox" id="showSkinLayersToggle" checked>
                        <span class="slider round"></span>
                    </label>
                </div>
                
                <!-- Always Show FPS -->
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 4px;">
                    <span style="color: white; font-size: 13px;">Always Show FPS</span>
                    <label class="switch" style="margin-left: auto;">
                        <input type="checkbox" id="fpsAlwaysVisibleToggle">
                        <span class="slider round"></span>
                    </label>
                </div>
                
                <!-- Player Skin Upload -->
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 4px; gap: 8px;">
                    <span style="color: white; font-size: 13px;">Player Skin</span>
                    <div style="display: flex; gap: 8px; margin-left: auto;">
                        <button id="uploadSkinBtn" style="padding: 6px 12px; background: var(--main-action); color: white; border: none; border-radius: 4px; cursor: pointer; font-family: 'Pixelify Sans', monospace; font-size: 12px;"> Upload</button>
                        <button id="exportSkinBtn" style="padding: 6px 12px; background: #7C7C7C; color: white; border: none; border-radius: 4px; cursor: pointer; font-family: 'Pixelify Sans', monospace; font-size: 12px;"> Export</button>
                    </div>
                    <input type="file" id="skinFileInput" accept="image/png" style="display: none;">
                </div>
                
                <!-- Slim Skin Toggle -->
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 4px;">
                    <span style="color: white; font-size: 13px;">Slim Arms (2px)</span>
                    <label class="switch" style="margin-left: auto;">
                        <input type="checkbox" id="slimSkinToggle">
                        <span class="slider round"></span>
                    </label>
                </div>
                
                <!-- Show Item in Hand -->
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 4px;">
                    <span style="color: white; font-size: 13px;">Show Item in Hand</span>
                    <label class="switch" style="margin-left: auto;">
                        <input type="checkbox" id="showHandToggle">
                        <span class="slider round"></span>
                    </label>
                </div>
            </div>
            
            <!-- Texture Editor with 3D Preview -->
            <div style="display: flex; gap: 30px; justify-content: center; margin-bottom: 20px; flex-wrap: wrap; align-items: flex-start;">
                <!-- Left Panel: 2D Texture Editor -->
                <div style="background: rgba(0,0,0,0.4); padding: 20px; border-radius: 10px; border: 2px solid rgba(121, 192, 90, 0.4);">
                    <h3 style="color: white; text-align: center; margin-bottom: 15px; font-size: 14px;">2D Texture Editor</h3>
                    <div style="display: flex; flex-direction: column; gap: 15px; align-items: center;">
                        <!-- Pixel Grid -->
                        <div style="text-align: center;">
                            <canvas id="texturePixelGrid" width="192" height="192" style="border: 3px solid #666; cursor: crosshair; image-rendering: pixelated; background: repeating-conic-gradient(#555 0% 25%, #444 0% 50%) 50% / 16px 16px; box-shadow: 0 4px 10px rgba(0,0,0,0.5);"></canvas>
                            <p style="color: #aaa; font-size: 11px; margin-top: 8px;">Click to paint  Shift+Click to erase</p>
                        </div>
                        
                        <!-- Color Palette -->
                        <div style="text-align: center; width: 100%;">
                            <label style="color: white; font-size: 12px; display: block; margin-bottom: 8px; font-weight: 600;">Color Palette</label>
                            <div id="textureColorPalette" style="display: grid; grid-template-columns: repeat(8, 28px); gap: 4px; margin-bottom: 10px; justify-content: center;">
                                <!-- Colors will be generated -->
                            </div>
                            <input type="color" id="textureCustomColor" value="#d4a574" style="width: 100%; height: 40px; cursor: pointer; border: 2px solid #666; border-radius: 6px; background: #222;">
                            <label style="color: white; font-size: 11px; display: block; margin-top: 5px;">Custom Color Picker</label>
                        </div>
                    </div>
                </div>
                
                <!-- Right Panel: 3D Preview -->
                <div style="background: rgba(0,0,0,0.4); padding: 20px; border-radius: 10px; border: 2px solid rgba(121, 192, 90, 0.4);">
                    <h3 style="color: white; text-align: center; margin-bottom: 15px; font-size: 14px;">3D Preview</h3>
                    <div style="position: relative;">
                        <canvas id="texturePreview3D" width="300" height="400" style="border: 3px solid #666; background: linear-gradient(180deg, #87CEEB 0%, #B0E0E6 50%, #98D8C8 100%); border-radius: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.5);"></canvas>
                        <div style="position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.7); padding: 6px 10px; border-radius: 4px; font-size: 10px; color: white;">
                             Auto-Rotating
                        </div>
                    </div>
                    <div style="margin-top: 12px; text-align: center;">
                        <label class="switch" style="display: inline-flex; align-items: center; gap: 8px;">
                            <span style="color: white; font-size: 11px;">Auto-Rotate</span>
                            <input type="checkbox" id="autoRotateToggle" checked>
                            <span class="slider round"></span>
                        </label>
                    </div>
                </div>
            </div>
            
            <div style="display: flex; gap: 12px; justify-content: center; margin-top: 20px; flex-wrap: wrap;">
                <button class="main-menu-btn" onclick="clearCurrentTexture()" style="padding: 10px 20px; background: rgba(255,100,100,0.8); font-size: 13px;"> CLEAR</button>
                <button class="main-menu-btn" onclick="resetAllTextures()" style="padding: 10px 20px; background: rgba(255,150,50,0.8); font-size: 13px;"> RESET ALL</button>
                <button class="main-menu-btn" onclick="saveModelTextures()" style="padding: 10px 20px; background: var(--main-action); font-size: 13px;"> SAVE</button>
                <button class="main-menu-btn" onclick="closeModelCustomizer()" style="padding: 10px 20px; font-size: 13px;"> CANCEL</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== INDEXEDDB STORAGE SYSTEM ====================
        
        const DB_NAME = 'WebcraftDB';
        const DB_VERSION = 1;
        let db = null;
        let dbReady = false;
        let dbReadyPromise = null;
        
        // Initialize IndexedDB
        function initDB() {
            if (dbReadyPromise) return dbReadyPromise;
            
            dbReadyPromise = new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                
                request.onerror = (event) => {
                    console.error(' IndexedDB error:', event.target.error);
                    reject(event.target.error);
                };
                
                request.onsuccess = (event) => {
                    db = event.target.result;
                    dbReady = true;
                    console.log(' IndexedDB opened successfully');
                    resolve(db);
                };
                
                request.onupgradeneeded = (event) => {
                    const database = event.target.result;
                    
                    // Create object stores
                    if (!database.objectStoreNames.contains('worlds')) {
                        const worldsStore = database.createObjectStore('worlds', { keyPath: 'name' });
                        worldsStore.createIndex('savedAt', 'savedAt', { unique: false });
                        console.log(' Created "worlds" object store');
                    }
                    
                    if (!database.objectStoreNames.contains('settings')) {
                        database.createObjectStore('settings', { keyPath: 'id' });
                        console.log(' Created "settings" object store');
                    }
                };
            });
            
            return dbReadyPromise;
        }
        
        // Migrate data from localStorage to IndexedDB (one-time migration)
        async function migrateFromLocalStorage() {
            try {
                // Check if already migrated
                const migrated = localStorage.getItem('webcraftMigrated');
                if (migrated === 'true') {
                    console.log(' Already migrated from localStorage');
                    return;
                }
                
                // Migrate worlds
                const oldWorlds = localStorage.getItem('minecraftSaves');
                if (oldWorlds) {
                    const worlds = JSON.parse(oldWorlds);
                    for (const name in worlds) {
                        await dbSaveWorld(worlds[name]);
                    }
                    console.log(' Migrated worlds from localStorage');
                }
                
                // Migrate settings
                const oldSettings = localStorage.getItem('minecraftSettings');
                if (oldSettings) {
                    const settings = JSON.parse(oldSettings);
                    await dbSaveSettings(settings);
                    console.log(' Migrated settings from localStorage');
                }
                
                // Mark as migrated
                localStorage.setItem('webcraftMigrated', 'true');
                console.log(' Migration complete!');
            } catch (e) {
                console.error(' Migration error:', e);
            }
        }
        
        // Save world to IndexedDB
        async function dbSaveWorld(worldData) {
            await initDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['worlds'], 'readwrite');
                const store = transaction.objectStore('worlds');
                const request = store.put(worldData);
                
                request.onsuccess = () => resolve(worldData.name);
                request.onerror = () => reject(request.error);
            });
        }
        
        // Load world from IndexedDB
        async function dbLoadWorld(worldName) {
            await initDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['worlds'], 'readonly');
                const store = transaction.objectStore('worlds');
                const request = store.get(worldName);
                
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }
        
        // Get all worlds from IndexedDB
        async function dbGetAllWorlds() {
            await initDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['worlds'], 'readonly');
                const store = transaction.objectStore('worlds');
                const request = store.getAll();
                
                request.onsuccess = () => resolve(request.result || []);
                request.onerror = () => reject(request.error);
            });
        }
        
        // Delete world from IndexedDB
        async function dbDeleteWorld(worldName) {
            await initDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['worlds'], 'readwrite');
                const store = transaction.objectStore('worlds');
                const request = store.delete(worldName);
                
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }
        
        // Delete all worlds from IndexedDB
        async function dbDeleteAllWorlds() {
            await initDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['worlds'], 'readwrite');
                const store = transaction.objectStore('worlds');
                const request = store.clear();
                
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }
        
        // Save settings to IndexedDB
        async function dbSaveSettings(settings) {
            await initDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['settings'], 'readwrite');
                const store = transaction.objectStore('settings');
                const request = store.put({ id: 'userSettings', ...settings });
                
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }
        
        // Load settings from IndexedDB
        async function dbLoadSettings() {
            await initDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['settings'], 'readonly');
                const store = transaction.objectStore('settings');
                const request = store.get('userSettings');
                
                request.onsuccess = () => {
                    const result = request.result;
                    if (result) {
                        delete result.id; // Remove the key before returning
                    }
                    resolve(result || null);
                };
                request.onerror = () => reject(request.error);
            });
        }
        
        // Initialize DB and migrate on page load
        initDB().then(() => {
            migrateFromLocalStorage();
        });
        
        // ==================== AUDIO SYSTEM (WEB AUDIO API) ====================
        
        // Audio Context
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();
        
        // Master volumes
        let masterVolume = 1.0;
        let musicVolume = 0.5;
        let sfxVolume = 0.7;
        
        // Default values for reset functionality
        const DEFAULT_MASTER_VOLUME = 100;
        const DEFAULT_MUSIC_VOLUME = 50;
        const DEFAULT_SFX_VOLUME = 70;
        const DEFAULT_TAB_OUT_MUTE = 100;
        
        // Video settings defaults
        const DEFAULT_RENDER_DISTANCE = 20;
        const DEFAULT_FOV = 75;
        
        // Controls settings defaults
        const DEFAULT_MOUSE_SENSITIVITY = 100;
        const DEFAULT_HAND_BOB_INTENSITY = 100;
        
        // Tab-out mute settings
        let tabOutMuteLevel = 1.0; // 100% mute by default (0 = no mute, 1 = full mute)
        let isWindowFocused = true;
        let activeVolumeTransition = null;
        
        // FPS Display Setting
        var fpsAlwaysVisible = true; // Always visible during gameplay, hidden in menus
        
        // Keybind System - Define before loadSettings
        const DEFAULT_KEYBINDS = {
            forward: 'KeyW',
            backward: 'KeyS',
            left: 'KeyA',
            right: 'KeyD',
            jump: 'Space',
            sneak: 'ShiftLeft',
            inventory: 'KeyE',
            pause: 'Escape'
        };
        let keybinds = {...DEFAULT_KEYBINDS};
        
        // Background music gain node
        const musicGainNode = audioCtx.createGain();
        musicGainNode.connect(audioCtx.destination);
        musicGainNode.gain.value = musicVolume * masterVolume;
        
        // SFX gain node
        const sfxGainNode = audioCtx.createGain();
        sfxGainNode.connect(audioCtx.destination);
        sfxGainNode.gain.value = sfxVolume * masterVolume;
        
        // Background music REMOVED - will add later
        let musicOscillators = [];
        let isMusicPlaying = false;
        let selectedMusicTrack = 'random';
        const musicTrackNames = ['No Music'];
        
        // Function to create button click sound (satisfying and pleasant)
        function playClickSound() {
            const now = audioCtx.currentTime;
            
            // Create a rich, layered click sound
            // Base tone - warm and full
            const osc1 = audioCtx.createOscillator();
            const gain1 = audioCtx.createGain();
            osc1.connect(gain1);
            gain1.connect(sfxGainNode);
            osc1.type = 'sine';
            osc1.frequency.setValueAtTime(520, now); // C5 note
            osc1.frequency.exponentialRampToValueAtTime(260, now + 0.15);
            gain1.gain.setValueAtTime(0.25, now);
            gain1.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
            osc1.start(now);
            osc1.stop(now + 0.15);
            
            // Harmonic layer - adds richness
            const osc2 = audioCtx.createOscillator();
            const gain2 = audioCtx.createGain();
            osc2.connect(gain2);
            gain2.connect(sfxGainNode);
            osc2.type = 'triangle';
            osc2.frequency.setValueAtTime(780, now); // G5 note (perfect fifth)
            osc2.frequency.exponentialRampToValueAtTime(390, now + 0.12);
            gain2.gain.setValueAtTime(0.15, now);
            gain2.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
            osc2.start(now);
            osc2.stop(now + 0.12);
            
            // Transient click - adds punch
            const osc3 = audioCtx.createOscillator();
            const gain3 = audioCtx.createGain();
            osc3.connect(gain3);
            gain3.connect(sfxGainNode);
            osc3.type = 'square';
            osc3.frequency.setValueAtTime(1200, now);
            osc3.frequency.exponentialRampToValueAtTime(100, now + 0.04);
            gain3.gain.setValueAtTime(0.2, now);
            gain3.gain.exponentialRampToValueAtTime(0.001, now + 0.04);
            osc3.start(now);
            osc3.stop(now + 0.04);
        }
        
        // Function to create button hover sound (gentle and inviting)
        function playHoverSound() {
            const now = audioCtx.currentTime;
            
            // Soft, pleasant hover tone
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            osc.connect(gainNode);
            gainNode.connect(sfxGainNode);
            
            osc.type = 'sine';
            osc.frequency.setValueAtTime(880, now); // A5 note
            osc.frequency.exponentialRampToValueAtTime(1320, now + 0.08); // E6 note (rises up)
            
            gainNode.gain.setValueAtTime(0.08, now);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
            
            osc.start(now);
            osc.stop(now + 0.08);
        }
        
        // Music functions removed - will add later
        let currentLoopCount = 0;
        const LOOPS_PER_TRACK = 5;
        let musicStartTime = 0;
        let currentTrackDuration = 0;
        let currentTrackIndex = 0;
        let progressUpdateInterval = null;
        let isInMenu = true;
        
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        function updateMusicProgress() {}
        function startMusicKeepalive() {}
        
        // Game State Management for Toast
        const GAME_STATE = {
            MAIN_MENU: 'main_menu',
            CREATE_WORLD: 'create_world',
            SAVED_WORLDS: 'saved_worlds',
            CREDITS: 'credits',
            LOADING: 'loading',
            IN_GAME: 'in_game',
            PAUSE_MENU: 'pause_menu',
            SETTINGS: 'settings'
        };
        
        let currentGameState = GAME_STATE.MAIN_MENU;
        
        // Set game state and update toast
        function setGameState(newState) {
            if (currentGameState === newState) return;
            
            console.log(` State: ${currentGameState}  ${newState}`);
            currentGameState = newState;
            
            // Immediately update toast when entering/leaving game
            updateToastVisibility();
        }
        
        // Show/hide toast based on game state
        function updateToastVisibility() {
            const toast = document.getElementById('music-toast');
            const showMusicToastToggle = document.getElementById('showMusicToastToggle');
            
            if (!toast) return;
            
            // Hide toast completely if music volume is 0%
            if (musicVolume === 0) {
                toast.style.display = 'none';
                toast.style.opacity = '0';
                toast.style.visibility = 'hidden';
                console.log(' Hiding toast - Music volume is 0%');
                return;
            }
            
            // Check if user disabled toast (only affects IN_GAME state)
            const isToastEnabledInGame = !showMusicToastToggle || showMusicToastToggle.checked;
            
            console.log(' Toast Visibility Update - State:', currentGameState, 'Toggle:', isToastEnabledInGame);
            
            // Remove mode classes but preserve position classes
            toast.classList.remove('menu-mode', 'pill-mode', 'hiding', 'expanded');
            
            // Apply appropriate mode based on state
            switch (currentGameState) {
                case GAME_STATE.MAIN_MENU:
                case GAME_STATE.PAUSE_MENU:
                    // Main menu and pause menu: ALWAYS show in expanded mode (ignore toggle)
                    toast.classList.add('menu-mode');
                    toast.style.display = 'flex';
                    toast.style.opacity = '1';
                    toast.style.visibility = 'visible';
                    isInMenu = true;
                    console.log(' Showing toast in MENU MODE (always visible)');
                    break;
                    
                case GAME_STATE.CREATE_WORLD:
                case GAME_STATE.SAVED_WORLDS:
                case GAME_STATE.CREDITS:
                case GAME_STATE.SETTINGS:
                    // Submenus: ALWAYS show in compact pill mode (ignore toggle)
                    toast.classList.add('pill-mode');
                    toast.style.display = 'flex';
                    toast.style.opacity = '1';
                    toast.style.visibility = 'visible';
                    isInMenu = false;
                    console.log(' Showing toast in PILL MODE (always visible)');
                    break;
                    
                case GAME_STATE.LOADING:
                case GAME_STATE.IN_GAME:
                default:
                    // IN-GAME: Only here does the toggle matter
                    if (isToastEnabledInGame) {
                        toast.classList.add('pill-mode');
                        toast.style.display = 'flex';
                        toast.style.opacity = '1';
                        toast.style.visibility = 'visible';
                        console.log(' Showing toast IN-GAME (toggle ON)');
                    } else {
                        // Completely invisible during gameplay
                        toast.style.display = 'none';
                        toast.style.opacity = '0';
                        toast.style.visibility = 'hidden';
                        console.log(' Hiding toast IN-GAME (toggle OFF)');
                    }
                    isInMenu = false;
                    break;
            }
        }
        
        // Music functions removed - will add later
        function startBackgroundMusic() {
            // Music removed - will add later
            isMusicPlaying = false;
        }
        
        function stopBackgroundMusic() {
            isMusicPlaying = false;
            musicOscillators = [];
        }
        
        // Update volume functions
        function updateMasterVolume(value) {
            masterVolume = value / 100;
            // Update both music and SFX with master volume (and tab-out mute if applicable)
            const muteMultiplier = isWindowFocused ? 1 : (1 - tabOutMuteLevel);
            musicGainNode.gain.value = musicVolume * masterVolume * muteMultiplier;
            sfxGainNode.gain.value = sfxVolume * masterVolume * muteMultiplier;
            
            if (masterVolume === 0 && isMusicPlaying) {
                stopBackgroundMusic();
            } else if (masterVolume > 0 && musicVolume > 0 && !isMusicPlaying) {
                startBackgroundMusic();
            }
        }
        
        function updateMusicVolume(value) {
            musicVolume = value / 100;
            const muteMultiplier = isWindowFocused ? 1 : (1 - tabOutMuteLevel);
            musicGainNode.gain.value = musicVolume * masterVolume * muteMultiplier;
            
            // Update toast visibility when volume changes
            updateToastVisibility();
            
            if (musicVolume === 0 && isMusicPlaying) {
                stopBackgroundMusic();
            } else if (musicVolume > 0 && masterVolume > 0 && !isMusicPlaying) {
                startBackgroundMusic();
            }
        }
        
        function updateSFXVolume(value) {
            sfxVolume = value / 100;
            sfxGainNode.gain.value = sfxVolume * masterVolume * (isWindowFocused ? 1 : (1 - tabOutMuteLevel));
        }
        
        function updateTabOutMuteLevel(value) {
            tabOutMuteLevel = value / 100;
            // Apply immediately if window is not focused
            if (!isWindowFocused) {
                applyTabOutMute(false);
            }
        }
        
        // Smooth volume transition function
        function smoothVolumeTransition(targetMusicVolume, targetSfxVolume, duration = 1000) {
            // Cancel any existing transition
            if (activeVolumeTransition) {
                clearInterval(activeVolumeTransition);
            }
            
            const startMusicVolume = musicGainNode.gain.value;
            const startSfxVolume = sfxGainNode.gain.value;
            const startTime = Date.now();
            
            activeVolumeTransition = setInterval(() => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Ease-in-out cubic for smooth transition
                const eased = progress < 0.5 
                    ? 4 * progress * progress * progress 
                    : 1 - Math.pow(-2 * progress + 2, 3) / 2;
                
                musicGainNode.gain.value = startMusicVolume + (targetMusicVolume - startMusicVolume) * eased;
                sfxGainNode.gain.value = startSfxVolume + (targetSfxVolume - startSfxVolume) * eased;
                
                if (progress >= 1) {
                    clearInterval(activeVolumeTransition);
                    activeVolumeTransition = null;
                }
            }, 16); // ~60fps
        }
        
        // Apply tab-out mute
        function applyTabOutMute(smooth = true) {
            const muteMultiplier = 1 - tabOutMuteLevel;
            const targetMusicVolume = musicVolume * masterVolume * muteMultiplier;
            const targetSfxVolume = sfxVolume * masterVolume * muteMultiplier;
            
            if (smooth) {
                smoothVolumeTransition(targetMusicVolume, targetSfxVolume, 1000);
            } else {
                musicGainNode.gain.value = targetMusicVolume;
                sfxGainNode.gain.value = targetSfxVolume;
            }
        }
        
        // Remove tab-out mute (restore normal volume)
        function removeTabOutMute(smooth = true) {
            const targetMusicVolume = musicVolume * masterVolume;
            const targetSfxVolume = sfxVolume * masterVolume;
            
            if (smooth) {
                smoothVolumeTransition(targetMusicVolume, targetSfxVolume, 1000);
            } else {
                musicGainNode.gain.value = targetMusicVolume;
                sfxGainNode.gain.value = targetSfxVolume;
            }
        }
        
        // Window focus/blur event listeners
        window.addEventListener('focus', () => {
            isWindowFocused = true;
            removeTabOutMute(true);
        });
        
        window.addEventListener('blur', () => {
            isWindowFocused = false;
            applyTabOutMute(true);
        });
        
        // ==================== SETTINGS VARIABLES (MUST BE DECLARED FIRST) ====================
        var renderDistance = 20;
        var mouseSensitivity = 1.0;
        var fieldOfView = 75;
        var handBobEnabled = true;
        var handBobIntensity = 100; // 0-200%
        var showItemInHand = true;
        var customHandTexture = null; // Will store 16x16 custom texture data for the arm
        var customSkinTexture = null; // Will store full 64x64 skin texture with layers
        var showSkinLayers = true; // Toggle for second layer visibility
        var shadowsEnabled = false; // Enable/disable shadows (OFF by default - experimental)
        
        // Flag to track if we opened settings from pause menu
        var openedSettingsFromPause = false;
        
        // ==================== INDEXEDDB SAVE/LOAD SYSTEM ====================
        
        // Save settings to IndexedDB
        function saveSettings() {
            const settings = {
                renderDistance: renderDistance,
                mouseSensitivity: mouseSensitivity,
                fieldOfView: fieldOfView,
                masterVolume: masterVolume * 100,
                musicVolume: musicVolume * 100,
                sfxVolume: sfxVolume * 100,
                tabOutMuteLevel: tabOutMuteLevel * 100,
                handBobEnabled: handBobEnabled,
                handBobIntensity: handBobIntensity,
                showItemInHand: showItemInHand,
                customHandTexture: customHandTexture,
                customSkinTexture: customSkinTexture,
                showSkinLayers: showSkinLayers,
                keybinds: keybinds,
                shadowsEnabled: shadowsEnabled,
                selectedMusicTrack: selectedMusicTrack,
                fpsAlwaysVisible: fpsAlwaysVisible,
                isSlimSkin: isSlimSkin
            };
            dbSaveSettings(settings).then(() => {
                console.log(' SAVED SETTINGS to IndexedDB:', settings);
            }).catch(e => {
                console.error('Failed to save settings:', e);
            });
        }
        
        // Load settings from IndexedDB
        async function loadSettingsAsync() {
            try {
                const settings = await dbLoadSettings();
                if (settings) {
                    applyLoadedSettings(settings);
                }
            } catch (e) {
                console.error('Failed to load settings from IndexedDB:', e);
            }
        }
        
        // Synchronous wrapper for backward compatibility (uses cached/default values initially)
        function loadSettings() {
            loadSettingsAsync();
        }
        
        // Apply loaded settings to game variables
        function applyLoadedSettings(settings) {
            console.log(' LOADED SETTINGS from IndexedDB:', settings);
            renderDistance = settings.renderDistance || 20;
            mouseSensitivity = settings.mouseSensitivity || 1.0;
            fieldOfView = settings.fieldOfView || 75;
            handBobEnabled = settings.handBobEnabled !== undefined ? settings.handBobEnabled : true;
            handBobIntensity = settings.handBobIntensity || 100;
            showItemInHand = settings.showItemInHand !== undefined ? settings.showItemInHand : true;
            customHandTexture = settings.customHandTexture || null;
            customSkinTexture = settings.customSkinTexture || null;
            showSkinLayers = settings.showSkinLayers !== undefined ? settings.showSkinLayers : true;
            shadowsEnabled = settings.shadowsEnabled !== undefined ? settings.shadowsEnabled : false;
            fpsAlwaysVisible = settings.fpsAlwaysVisible !== undefined ? settings.fpsAlwaysVisible : false;
            isSlimSkin = settings.isSlimSkin !== undefined ? settings.isSlimSkin : false;
            
            // Load keybinds
            if (settings.keybinds) {
                keybinds = {...DEFAULT_KEYBINDS, ...settings.keybinds};
            }
            
            // Load audio settings
            if (settings.masterVolume !== undefined) {
                masterVolume = settings.masterVolume / 100;
                console.log(' Loaded masterVolume:', masterVolume);
            }
            if (settings.musicVolume !== undefined) {
                musicVolume = settings.musicVolume / 100;
                console.log(' Loaded musicVolume:', musicVolume);
            }
            if (settings.sfxVolume !== undefined) {
                sfxVolume = settings.sfxVolume / 100;
                console.log(' Loaded sfxVolume:', sfxVolume);
            }
            if (settings.tabOutMuteLevel !== undefined) {
                tabOutMuteLevel = settings.tabOutMuteLevel / 100;
                console.log(' Loaded tabOutMuteLevel:', tabOutMuteLevel);
            }
            
            // Load music track selection
            if (settings.selectedMusicTrack !== undefined) {
                selectedMusicTrack = settings.selectedMusicTrack;
                console.log(' Loaded selectedMusicTrack:', selectedMusicTrack);
            }
            
            console.log(' FINAL VOLUME VALUES - Master:', masterVolume, 'Music:', musicVolume, 'SFX:', sfxVolume, 'TabMute:', tabOutMuteLevel);
            
            // Update audio gain nodes with loaded values
            musicGainNode.gain.value = musicVolume * masterVolume;
            sfxGainNode.gain.value = sfxVolume * masterVolume;
            
            // Load hand settings UI
            const handBobToggle = document.getElementById('handBobToggle');
            const handBobSlider = document.getElementById('handBobIntensitySlider');
            const showHandToggle = document.getElementById('showHandToggle');
            const showSkinLayersToggle = document.getElementById('showSkinLayersToggle');
            
            if (handBobToggle) handBobToggle.checked = handBobEnabled;
            if (handBobSlider) {
                handBobSlider.value = handBobIntensity;
                const handBobIntensityValue = document.getElementById('handBobIntensityValue');
                if (handBobIntensityValue) handBobIntensityValue.textContent = handBobIntensity;
            }
            if (showHandToggle) showHandToggle.checked = showItemInHand;
            if (showSkinLayersToggle) showSkinLayersToggle.checked = showSkinLayers;
            
            // Load music track selector UI
            const musicTrackSelector = document.getElementById('musicTrackSelector');
            if (musicTrackSelector) {
                musicTrackSelector.value = selectedMusicTrack;
            }
            
            // Update camera FOV
            if (camera) {
                camera.fov = fieldOfView;
                camera.updateProjectionMatrix();
            }
            
            // Load shadows toggle UI
            const shadowsToggle = document.getElementById('shadowsToggle');
            if (shadowsToggle) {
                shadowsToggle.checked = shadowsEnabled;
            }
            
            // Load FPS always visible toggle UI
            const fpsToggle = document.getElementById('fpsAlwaysVisibleToggle');
            if (fpsToggle) {
                fpsToggle.checked = fpsAlwaysVisible;
            }
            
            // Apply shadows setting to renderer if it exists
            if (renderer) {
                renderer.shadowMap.enabled = shadowsEnabled;
            }
        }
        
        // ==================== EXPORT/IMPORT SYSTEM ====================
        
        // Helper function to download data as JSON file
        function downloadJSON(data, filename) {
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // Export settings only
        async function exportSettings() {
            try {
                const settings = await dbLoadSettings();
                if (!settings) {
                    alert(' No settings found to export!');
                    return;
                }
                const data = {
                    type: 'settings',
                    exportedAt: new Date().toISOString(),
                    settings: settings
                };
                downloadJSON(data, `webcraft-settings-${Date.now()}.json`);
                alert(' Settings exported successfully!');
            } catch (e) {
                console.error('Error exporting settings:', e);
                alert(' Error exporting settings');
            }
        }
        
        // Export worlds only
        async function exportWorlds() {
            try {
                const worlds = await dbGetAllWorlds();
                if (!worlds || worlds.length === 0) {
                    alert(' No worlds found to export!');
                    return;
                }
                const worldsMap = {};
                worlds.forEach(w => worldsMap[w.name] = w);
                const data = {
                    type: 'worlds',
                    exportedAt: new Date().toISOString(),
                    worldCount: worlds.length,
                    worlds: worldsMap
                };
                downloadJSON(data, `webcraft-worlds-${Date.now()}.json`);
                alert(` ${worlds.length} world(s) exported successfully!`);
            } catch (e) {
                console.error('Error exporting worlds:', e);
                alert(' Error exporting worlds');
            }
        }
        
        // Export everything (settings + worlds)
        async function exportAll() {
            try {
                const settings = await dbLoadSettings();
                const worlds = await dbGetAllWorlds();
                
                if (!settings && (!worlds || worlds.length === 0)) {
                    alert(' No data found to export!');
                    return;
                }
                
                const worldsMap = {};
                if (worlds) worlds.forEach(w => worldsMap[w.name] = w);
                
                const data = {
                    type: 'complete',
                    exportedAt: new Date().toISOString(),
                    settings: settings || null,
                    worlds: Object.keys(worldsMap).length > 0 ? worldsMap : null
                };
                
                downloadJSON(data, `webcraft-complete-backup-${Date.now()}.json`);
                alert(' Complete backup exported successfully!');
            } catch (e) {
                console.error('Error exporting all:', e);
                alert(' Error exporting data');
            }
        }
        
        // Import data from JSON file
        async function importData(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    // Validate data type
                    if (!data.type || !['settings', 'worlds', 'complete'].includes(data.type)) {
                        alert(' Invalid file format! Please select a valid export file.');
                        return;
                    }
                    
                    let importedItems = [];
                    
                    // Import settings
                    if ((data.type === 'settings' || data.type === 'complete') && data.settings) {
                        await dbSaveSettings(data.settings);
                        loadSettings(); // Reload settings immediately
                        importedItems.push('Settings');
                    }
                    
                    // Import worlds
                    if ((data.type === 'worlds' || data.type === 'complete') && data.worlds) {
                        const existingWorlds = await dbGetAllWorlds();
                        const worldCount = Object.keys(data.worlds).length;
                        
                        // Ask user about merge or replace
                        const hasExisting = existingWorlds.length > 0;
                        let shouldMerge = true;
                        
                        if (hasExisting) {
                            shouldMerge = confirm(
                                `You have existing worlds. Do you want to merge them with imported worlds?\n\n` +
                                `Click OK to MERGE (keep both)\n` +
                                `Click Cancel to REPLACE (overwrite existing)`
                            );
                        }
                        
                        if (!shouldMerge) {
                            // Replace: delete all existing first
                            await dbDeleteAllWorlds();
                        }
                        
                        // Save all imported worlds
                        for (const name in data.worlds) {
                            await dbSaveWorld(data.worlds[name]);
                        }
                        
                        cachedWorlds = await dbGetAllWorlds();
                        importedItems.push(`${worldCount} World(s)`);
                    }
                    
                    if (importedItems.length > 0) {
                        alert(` Successfully imported:\n${importedItems.join(', ')}\n\nExported: ${new Date(data.exportedAt).toLocaleString()}`);
                        displaySavedWorlds();
                    } else {
                        alert(' No data was imported.');
                    }
                    
                } catch (error) {
                    console.error('Import error:', error);
                    alert(' Failed to import data. Please check the file format.');
                }
            };
            
            reader.readAsText(file);
            // Reset file input so same file can be imported again
            event.target.value = '';
        }
        
        // Capture world preview screenshot
        function captureWorldPreview() {
            try {
                renderer.render(scene, camera);
                return renderer.domElement.toDataURL('image/jpeg', 0.5);
            } catch (e) {
                console.error('Failed to capture preview:', e);
                return null;
            }
        }
        
        // Save world data to IndexedDB
        function saveWorld(worldName) {
            if (!worldName) {
                worldName = 'World_' + WORLD_SEED + '_' + Date.now();
            }
            
            // Convert world object to serializable format
            const worldData = {};
            const doorData = {}; // Store door-specific data
            for (let k in world) {
                worldData[k] = world[k].userData.blockType;
                
                // Save door rotation and state
                if (world[k].userData.isDoor) {
                    doorData[k] = {
                        rotation: world[k].userData.doorRotation,
                        open: world[k].userData.doorOpen
                    };
                }
            }
            
            // Capture preview image
            const previewImage = captureWorldPreview();
            
            const saveData = {
                name: worldName,
                seed: WORLD_SEED,
                worldSize: ws,
                isFlatWorld: isFlatWorld,
                worldBorderEnabled: worldBorderEnabled,
                worldData: worldData,
                doorData: doorData, // Save door metadata
                playerPosition: { px, py, pz, rx, ry },
                inventory: inventoryData,
                isCreativeMode: isCreativeMode,
                dayTime: dayTime,
                dayCounter: dayCounter,
                moonPhase: moonPhase,
                preview: previewImage,
                savedAt: new Date().toISOString()
            };
            
            // Save to IndexedDB (async but we return the name immediately)
            dbSaveWorld(saveData).then(() => {
                console.log('World saved to IndexedDB:', worldName);
            }).catch(e => {
                console.error('Error saving world to IndexedDB:', e);
                alert(' Error saving world: ' + e.message);
            });
            
            return worldName;
        }
        
        // Load world data from IndexedDB (async version)
        async function loadWorldAsync(worldName) {
            try {
                const saveData = await dbLoadWorld(worldName);
                
                if (!saveData) {
                    console.error('World not found:', worldName);
                    return false;
                }
                
                // Clear existing world
                for(var k in world) { 
                    scene.remove(world[k]); 
                }
                world = {};
                
                // Restore world settings
                WORLD_SEED = saveData.seed;
                ws = saveData.worldSize;
                isFlatWorld = saveData.isFlatWorld || false;
                worldBorderEnabled = saveData.worldBorderEnabled !== undefined ? saveData.worldBorderEnabled : true;
                isCreativeMode = saveData.isCreativeMode || false;
                dayTime = saveData.dayTime || (6 / 24) * 1440;
                dayCounter = saveData.dayCounter || 1;
                moonPhase = saveData.moonPhase || 0;
                
                // Restore world blocks
                for (let k in saveData.worldData) {
                    const [x, y, z] = k.split(',').map(Number);
                    add(x, y, z, saveData.worldData[k]);
                }
                
                // Restore door states and rotations
                if (saveData.doorData) {
                    for (let k in saveData.doorData) {
                        const [x, y, z] = k.split(',').map(Number);
                        const doorMesh = world[k];
                        if (doorMesh && doorMesh.userData.isDoor) {
                            doorMesh.userData.doorRotation = saveData.doorData[k].rotation;
                            doorMesh.rotation.y = saveData.doorData[k].rotation;
                            doorMesh.userData.doorOpen = saveData.doorData[k].open;
                            
                            if (saveData.doorData[k].open) {
                                doorMesh.rotation.y = saveData.doorData[k].rotation + Math.PI / 2;
                            }
                        }
                    }
                }
                
                // Restore player position
                if (saveData.playerPosition) {
                    px = saveData.playerPosition.px;
                    py = saveData.playerPosition.py;
                    pz = saveData.playerPosition.pz;
                    rx = saveData.playerPosition.rx;
                    ry = saveData.playerPosition.ry;
                    camera.position.set(px, py, pz);
                    camera.rotation.set(rx, ry, 0, 'YXZ');
                }
                
                // Restore inventory
                if (saveData.inventory) {
                    inventoryData = saveData.inventory;
                }
                
                // Update UI
                updateGameModeButtonText();
                inventoryScreen.classList.toggle('creative-mode', isCreativeMode);
                updateInventoryUI();
                updateToolbarSelection();
                
                window.gameStartTime = Date.now();
                
                console.log('World loaded from IndexedDB:', worldName);
                return true;
            } catch (e) {
                console.error('Error loading world:', e);
                return false;
            }
        }
        
        // Sync wrapper for backward compatibility
        function loadWorld(worldName) {
            // Start async load and return true (caller should handle async nature)
            loadWorldAsync(worldName);
            return true;
        }
        
        // Delete world from IndexedDB
        function deleteWorld(worldName) {
            dbDeleteWorld(worldName).then(() => {
                console.log('World deleted from IndexedDB:', worldName);
            }).catch(e => {
                console.error('Error deleting world:', e);
            });
        }
        
        // Cache for saved worlds (for sync access)
        let cachedWorlds = [];
        
        // Get list of saved worlds (async)
        async function getSavedWorldsAsync() {
            try {
                const worlds = await dbGetAllWorlds();
                cachedWorlds = worlds;
                return worlds;
            } catch (e) {
                console.error('Error getting worlds:', e);
                return [];
            }
        }
        
        // Sync wrapper using cache
        function getSavedWorlds() {
            // Return cached worlds, update cache async
            getSavedWorldsAsync();
            return cachedWorlds;
        }
        
        // Delete ALL worlds from localStorage with 5 confirmation dialogs
        let deleteAllConfirmationStep = 0;
        
        async function startDeleteAllWorlds() {
            const worlds = await dbGetAllWorlds();
            if (worlds.length === 0) {
                alert('No worlds to delete!');
                return;
            }
            
            deleteAllConfirmationStep = 0;
            showDeleteConfirmationModal(1, worlds.length);
        }
        
        function showDeleteConfirmationModal(step, worldCount) {
            // Remove any existing modal
            const existingModal = document.getElementById('delete-all-modal');
            if (existingModal) existingModal.remove();
            
            const confirmationMessages = [
                ` WARNING: You are about to delete ALL ${worldCount} saved worlds!`,
                ` SECOND WARNING: This action is IRREVERSIBLE! All your progress will be lost!`,
                ` THIRD WARNING: Are you absolutely certain? There is no undo!`,
                ` FOURTH WARNING: Last chance to cancel! All worlds will be permanently deleted!`,
                ` FINAL CONFIRMATION: Click DELETE to permanently erase all ${worldCount} worlds!`
            ];
            
            const modal = document.createElement('div');
            modal.id = 'delete-all-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.95);
                z-index: 4000;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            
            const progressDots = Array(5).fill('').map((_, i) => 
                `<span style="width: 20px; height: 20px; border-radius: 50%; background: ${i < step ? 'var(--warning-color)' : 'rgba(255,255,255,0.3)'}; display: inline-block; margin: 0 5px;"></span>`
            ).join('');
            
            modal.innerHTML = `
                <div style="background: rgba(50, 0, 0, 0.95); padding: 40px 50px; border-radius: 0px; border: 4px solid var(--warning-color); max-width: 600px; width: 90%; text-align: center; box-shadow: 0 0 50px rgba(231, 76, 60, 0.5);">
                    <h2 style="color: var(--warning-color); font-size: 28px; margin-bottom: 10px; text-shadow: 3px 3px 0 rgba(0, 0, 0, 0.8);"> DELETE ALL WORLDS</h2>
                    
                    <div style="margin-bottom: 25px;">
                        ${progressDots}
                    </div>
                    
                    <p style="color: white; font-size: 14px; margin-bottom: 5px;">Confirmation ${step} of 5</p>
                    
                    <p style="color: #ff6b6b; font-size: 18px; margin-bottom: 30px; line-height: 1.6; text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.8);">
                        ${confirmationMessages[step - 1]}
                    </p>
                    
                    <div style="display: flex; gap: 20px; justify-content: center;">
                        <button class="main-menu-btn" onclick="closeDeleteAllModal()" style="background: var(--main-action); padding: 15px 40px; font-size: 16px;"> CANCEL</button>
                        <button class="main-menu-btn" onclick="confirmDeleteStep(${step}, ${worldCount})" style="background: var(--warning-color); padding: 15px 40px; font-size: 16px;">
                            ${step === 5 ? ' DELETE ALL' : ' CONTINUE'}
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            playClickSound();
        }
        
        function confirmDeleteStep(step, worldCount) {
            if (step < 5) {
                showDeleteConfirmationModal(step + 1, worldCount);
            } else {
                // Final step - delete all worlds using IndexedDB
                dbDeleteAllWorlds().then(() => {
                    cachedWorlds = [];
                    console.log('All worlds deleted from IndexedDB!');
                    closeDeleteAllModal();
                    displaySavedWorlds();
                    alert(' All worlds have been permanently deleted!');
                }).catch(e => {
                    console.error('Error deleting all worlds:', e);
                    alert(' Error deleting worlds: ' + e.message);
                });
            }
        }
        
        function closeDeleteAllModal() {
            const modal = document.getElementById('delete-all-modal');
            if (modal) modal.remove();
            deleteAllConfirmationStep = 0;
            playClickSound();
        }
        
        // Rename world function (async)
        async function renameWorldAsync(oldName, newName) {
            if (!newName || newName.trim() === '') {
                alert('World name cannot be empty');
                return false;
            }
            
            try {
                const worlds = await dbGetAllWorlds();
                const worldsMap = {};
                worlds.forEach(w => worldsMap[w.name] = w);
                
                if (worldsMap[newName] && newName !== oldName) {
                    alert('A world with this name already exists');
                    return false;
                }
                
                if (worldsMap[oldName]) {
                    const worldData = { ...worldsMap[oldName], name: newName };
                    await dbDeleteWorld(oldName);
                    await dbSaveWorld(worldData);
                    
                    if (currentWorldName === oldName) {
                        currentWorldName = newName;
                    }
                    
                    return true;
                }
                return false;
            } catch (e) {
                console.error('Error renaming world:', e);
                return false;
            }
        }
        
        // Sync wrapper
        function renameWorld(oldName, newName) {
            renameWorldAsync(oldName, newName).then(success => {
                if (success) {
                    displaySavedWorlds();
                }
            });
            return true; // Optimistic return
        }
        
        // Show rename modal
        function showRenameModal(worldName) {
            const modal = document.createElement('div');
            modal.className = 'rename-modal';
            modal.innerHTML = `
                <h3> Rename World</h3>
                <input type="text" id="rename-input" value="${worldName}" maxlength="30">
                <div class="rename-modal-buttons">
                    <button class="main-menu-btn" onclick="confirmRename('${worldName}')" style="background: var(--main-action); padding: 10px 24px;">SAVE</button>
                    <button class="main-menu-btn" onclick="closeRenameModal()" style="padding: 10px 24px;">CANCEL</button>
                </div>
            `;
            modal.id = 'rename-modal';
            document.body.appendChild(modal);
            const renameInput = document.getElementById('rename-input');
            if (renameInput) {
                renameInput.focus();
                renameInput.select();
            }
        }
        
        function confirmRename(oldName) {
            const renameInput = document.getElementById('rename-input');
            if (!renameInput) return;
            const newName = renameInput.value.trim();
            if (renameWorld(oldName, newName)) {
                closeRenameModal();
                displaySavedWorlds();
            }
        }
        
        function closeRenameModal() {
            const modal = document.getElementById('rename-modal');
            if (modal) {
                modal.remove();
            }
        }
        
        // Display saved worlds list (async)
        async function displaySavedWorlds() {
            const savedWorldsList = document.getElementById('saved-worlds-list');
            
            // Show loading state
            savedWorldsList.innerHTML = '<p style="color: #aaa; text-align: center; padding: 20px;">Loading worlds...</p>';
            
            try {
                const worlds = await dbGetAllWorlds();
                cachedWorlds = worlds;
                
                if (worlds.length === 0) {
                    savedWorldsList.innerHTML = '<p style="color: #aaa; text-align: center; padding: 20px;">No saved worlds yet. Create a world to get started!</p>';
                    return;
                }
                
                savedWorldsList.innerHTML = '';
                
                worlds.forEach(worldData => {
                    const card = document.createElement('div');
                    card.className = 'saved-world-card';
                    
                    const preview = document.createElement('img');
                    preview.className = 'world-preview';
                    preview.src = worldData.preview || 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="120" height="90"><rect width="120" height="90" fill="%23373737"/><text x="60" y="45" text-anchor="middle" fill="%23888" font-size="12" font-family="monospace">No Preview</text></svg>';
                    preview.alt = worldData.name;
                    
                    const info = document.createElement('div');
                    info.className = 'world-info';
                    
                    const name = document.createElement('div');
                    name.className = 'world-name';
                    name.textContent = worldData.name;
                    name.title = 'Click to rename';
                    name.onclick = () => showRenameModal(worldData.name);
                    
                    const details = document.createElement('div');
                    details.className = 'world-details';
                    const savedDate = new Date(worldData.savedAt).toLocaleString();
                    details.innerHTML = `
                        <div> Seed: ${worldData.seed}</div>
                        <div> Size: ${worldData.worldSize}</div>
                        <div> Mode: ${worldData.isCreativeMode ? 'Creative' : 'Survival'}</div>
                        <div> Border: ${worldData.worldBorderEnabled !== false ? 'Enabled' : 'Disabled'}</div>
                        <div> Saved: ${savedDate}</div>
                    `;
                    
                    info.appendChild(name);
                    info.appendChild(details);
                    
                    const actions = document.createElement('div');
                    actions.className = 'world-actions';
                    
                    const loadBtn = document.createElement('button');
                    loadBtn.textContent = ' LOAD';
                    loadBtn.className = 'world-action-btn load';
                    loadBtn.onclick = async () => {
                        loadBtn.textContent = ' Loading...';
                        loadBtn.disabled = true;
                        
                        const success = await loadWorldAsync(worldData.name);
                        if (success) {
                            generateInventorySlots();
                            updateToolbarSelection();
                            startAutoSave(worldData.name);
                            const mainMenu = document.getElementById('main-menu');
                            mainMenu.style.display = 'none';
                            mainMenu.style.animation = 'none';
                            mainMenu.style.backgroundColor = 'transparent';
                            
                            setGameState(GAME_STATE.IN_GAME);
                            
                            const starfieldCanvas = document.getElementById('starfield-bg');
                            if (starfieldCanvas) {
                                starfieldCanvas.classList.remove('active');
                                starfieldCanvas.style.opacity = '0';
                            }
                            
                            requestLock(renderer.domElement);
                            const crosshair = document.getElementById('crosshair');
                            const toolbar = document.getElementById('toolbar');
                            if (crosshair) crosshair.style.display = 'block';
                            if (toolbar) toolbar.style.display = 'flex';
                            if (!isCreativeMode) {
                                const healthContainer = document.getElementById('health-container');
                                const oxygenContainer = document.getElementById('oxygen-container');
                                if (healthContainer) healthContainer.style.display = 'block';
                                if (oxygenContainer) oxygenContainer.style.display = 'block';
                            }
                            const fpsElement = document.getElementById('fps');
                            if (fpsElement) {
                                fpsElement.style.display = (fpsAlwaysVisible && currentGameState === GAME_STATE.IN_GAME) || showHitbox ? 'block' : 'none';
                            }
                            if (uiElement) {
                                uiElement.style.display = showHitbox ? 'block' : 'none';
                            }
                            const debugInfoElement = document.getElementById('debug-info');
                            if (debugInfoElement) {
                                debugInfoElement.style.display = showHitbox ? 'block' : 'none';
                            }
                            
                            locked = false;
                            paused = false;
                            if (!window.gameLoopStarted) {
                                loop();
                                window.gameLoopStarted = true;
                            }
                        } else {
                            loadBtn.textContent = ' LOAD';
                            loadBtn.disabled = false;
                            alert(' Failed to load world');
                        }
                    };
                    
                    const renameBtn = document.createElement('button');
                    renameBtn.textContent = ' RENAME';
                    renameBtn.className = 'world-action-btn';
                    renameBtn.onclick = () => showRenameModal(worldData.name);
                    
                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = ' DELETE';
                    deleteBtn.className = 'world-action-btn delete';
                    deleteBtn.onclick = async () => {
                        if (confirm(`Are you sure you want to delete "${worldData.name}"?`)) {
                            await dbDeleteWorld(worldData.name);
                            displaySavedWorlds();
                        }
                    };
                    
                    actions.appendChild(loadBtn);
                    actions.appendChild(renameBtn);
                    actions.appendChild(deleteBtn);
                    
                    card.appendChild(preview);
                    card.appendChild(info);
                    card.appendChild(actions);
                    
                    savedWorldsList.appendChild(card);
                });
            } catch (e) {
                console.error('Error displaying worlds:', e);
                savedWorldsList.innerHTML = '<p style="color: #f66; text-align: center; padding: 20px;">Error loading worlds</p>';
            }
        }
        
        // Auto-save current world every 30 seconds
        let autoSaveInterval = null;
        let currentWorldName = null;
        
        function startAutoSave(worldName) {
            currentWorldName = worldName;
            if (autoSaveInterval) clearInterval(autoSaveInterval);
            
            autoSaveInterval = setInterval(() => {
                if (!paused && currentWorldName) {
                    saveWorld(currentWorldName);
                    console.log('Auto-saved world');
                }
            }, 30000); // Every 30 seconds
        }
        
        function stopAutoSave() {
            if (autoSaveInterval) {
                clearInterval(autoSaveInterval);
                autoSaveInterval = null;
            }
        }
        
        // ==================== END LOCALSTORAGE SYSTEM ====================

        // NEW: Cross-browser Pointer Lock Request function
        function requestLock(element) {
            (element.requestPointerLock ||
             element.mozRequestPointerLock ||
             element.webkitRequestPointerLock).call(element);
        }
        
        // --- GAME STATE ---
        let isCreativeMode = false; // MODIFIED: Survival is now default
        let isFlatWorld = false; // NEW: Flat world option

        // --- DAY/NIGHT CYCLE VARIABLES ---
        // Start at 6:00 AM (6 hours into the 24-hour cycle = 25% of dayLength)
        let dayTime = (6 / 24) * 1440; // Starting at 6:00 AM (360 seconds)
        const dayLength = 1440; // 24 minutes for a full day cycle (20 minutes in real Minecraft)
        let dayCounter = 1; // Track game days starting from day 1
        let moonPhase = 0; // Track moon phase (0-7, cycles through 8 phases)
        
        // --- INVENTORY CONSTANTS & DATA ---
        const MAIN_INV_WIDTH = 8;
        const MAIN_INV_HEIGHT = 3; // Rows 0, 1, 2
        const HUD_WIDTH = 8; 
        const HUD_Y = MAIN_INV_HEIGHT; // Row 3 is the HUD row
        
        const MAIN_SLOTS = MAIN_INV_WIDTH * MAIN_INV_HEIGHT; // 24
        const TOTAL_SLOTS = MAIN_SLOTS + HUD_WIDTH; // 32 slots total
        const MAX_STACK = 64;
        
        // MODIFIED: Initial Inventory Data is now empty
        let inventoryData = Array(TOTAL_SLOTS).fill(null);

        // Inventory state variables
        let cursorX = 0; 
        let cursorY = 0; 
        let pickedUpItem = null; // This is the movable part (data only)
        
        // NEW: Fake Cursor variables
        let fakeCursorX = window.innerWidth / 2;
        let fakeCursorY = window.innerHeight / 2;
        let fakeCursorElement = null; // Will be assigned after DOM loads
        
        // Element references
        const mainInventoryGrid = document.getElementById('main-inventory-grid');
        const hudInventoryGrid = document.getElementById('hud-inventory-grid');
        let pickedUpItemElement = null; // MODIFIED: Assigned later
        const gameModeToggleBtn = document.getElementById('gameModeToggleBtn');
        const creativeBlockPicker = document.getElementById('creative-block-picker');
        
        // --- SEED HANDLING VAR ---
        var WORLD_SEED; 

        var toolbar = document.getElementById('toolbar');
        
        // MODIFIED: Added 'LEAVES', 'GLASS', 'DOOR', 'TORCH', and 'PLANKS'
        var blockNames = ['GRASS', 'DIRT', 'STONE', 'WOOD', 'SAND', 'BEDROCK', 'LEAVES', 'GLASS', 'DOOR', 'TORCH', 'WATER', 'LAVA', 'PLANKS'];
        var numBlocks = blockNames.length;
        var btns = [];
        
        // --- BLOCK TYPE CONSTANTS ---
        const SAND_TYPE = 4;
        const BEDROCK_TYPE = 5;
        const WOOD_TYPE = 3; 
        const LEAVES_TYPE = 6;
        const PLANKS_TYPE = 12;
        const GLASS_TYPE = 7;
        const DOOR_TYPE = 8;
        const TORCH_TYPE = 9;
        const WATER_TYPE = 10;
        const LAVA_TYPE = 11;
        // Check every 100ms for gravity effect
        const SAND_FALL_CHECK_INTERVAL = 0.1; 
        let sandFallTimer = 0;

        // --- NEW GRASS SPREAD CONSTANTS ---
        const GRASS_TYPE = 0;   // Grass is block type 0
        const DIRT_TYPE = 1;    // Dirt is block type 1
        const GRASS_SPREAD_CHECK_INTERVAL = 1.0; // Check for growth every 1 second
        let grassSpreadTimer = 0;
        // Max time in seconds (1 to 5 minutes -> aiming for 5 minutes max average, 300 seconds)
        // Chance is 1 / 300 checks in the current setup (1 check per second)
        const GRASS_SPREAD_CHANCE_MAX_SECONDS = 3; 
        // ----------------------------------
        
        // --- LIQUID FLOW SYSTEM (Water & Lava) ---
        const LIQUID_FLOW_INTERVAL = 0.3; // Check for flow every 300ms
        let liquidFlowTimer = 0;
        const COBBLESTONE_TYPE = 2; // Stone type for cobblestone
        // ----------------------------------
        
        // --- UTILITY FUNCTIONS ---
        function getBlockDisplay(type) {
            // Check if it's an item (negative numbers) or block
            if (type < 0) {
                const item = itemDefinitions[type];
                return item ? { name: item.name, color: item.color || '#fff' } : { name: '?', color: 'red' };
            }
            return blockNames[type] ? { name: blockNames[type], color: '#fff' } : { name: '?', color: 'red' };
        }
        
        // --- CRAFTING SYSTEM ---
        // Item definitions (negative numbers for tools/items)
        const ITEM_WOODEN_PICKAXE = -1;
        const ITEM_WOODEN_AXE = -2;
        const ITEM_WOODEN_SWORD = -3;
        const ITEM_STONE_PICKAXE = -4;
        const ITEM_STONE_AXE = -5;
        const ITEM_STONE_SWORD = -6;
        const ITEM_STICK = -7;
        const ITEM_PLANKS = -8;
        
        const itemDefinitions = {
            [ITEM_WOODEN_PICKAXE]: { 
                name: 'W.PICK', 
                color: '#8b5a2b', 
                isPickaxe: true, 
                miningSpeed: 2, 
                durability: 60,
                maxDurability: 60,
                maxStack: 1,
                isTool: true
            },
            [ITEM_WOODEN_AXE]: { 
                name: 'W.AXE', 
                color: '#8b5a2b', 
                isAxe: true, 
                miningSpeed: 2, 
                durability: 60,
                maxDurability: 60,
                maxStack: 1,
                isTool: true
            },
            [ITEM_WOODEN_SWORD]: { 
                name: 'W.SWORD', 
                color: '#8b5a2b', 
                isSword: true, 
                damage: 4, 
                durability: 60,
                maxDurability: 60,
                maxStack: 1,
                isTool: true
            },
            [ITEM_STONE_PICKAXE]: { 
                name: 'S.PICK', 
                color: '#7a7a7a', 
                isPickaxe: true, 
                miningSpeed: 3, 
                durability: 132,
                maxDurability: 132,
                maxStack: 1,
                isTool: true
            },
            [ITEM_STONE_AXE]: { 
                name: 'S.AXE', 
                color: '#7a7a7a', 
                isAxe: true, 
                miningSpeed: 3, 
                durability: 132,
                maxDurability: 132,
                maxStack: 1,
                isTool: true
            },
            [ITEM_STONE_SWORD]: { 
                name: 'S.SWORD', 
                color: '#7a7a7a', 
                isSword: true, 
                damage: 6, 
                durability: 132,
                maxDurability: 132,
                maxStack: 1,
                isTool: true
            },
            [ITEM_STICK]: { 
                name: 'STICK', 
                color: '#a0826d', 
                isStick: true 
            },
            [ITEM_PLANKS]: { 
                name: 'PLANKS', 
                color: '#daa560', 
                isPlaceable: true 
            }
        };
        
        // Crafting recipes: grid is 3x3, read left-to-right, top-to-bottom
        // null means empty slot, use block type or item type
        const craftingRecipes = [
            // Wood -> Planks (any position)
            {
                pattern: [null, null, null, null, WOOD_TYPE, null, null, null, null],
                result: { type: ITEM_PLANKS, count: 4 },
                name: '4x Planks'
            },
            // Planks -> Sticks (vertical)
            {
                pattern: [null, null, null, null, ITEM_PLANKS, null, null, ITEM_PLANKS, null],
                result: { type: ITEM_STICK, count: 4 },
                name: '4x Sticks'
            },
            // Wooden Pickaxe
            {
                pattern: [ITEM_PLANKS, ITEM_PLANKS, ITEM_PLANKS, null, ITEM_STICK, null, null, ITEM_STICK, null],
                result: { type: ITEM_WOODEN_PICKAXE, count: 1 },
                name: 'Wooden Pickaxe'
            },
            // Wooden Axe
            {
                pattern: [ITEM_PLANKS, ITEM_PLANKS, null, ITEM_PLANKS, ITEM_STICK, null, null, ITEM_STICK, null],
                result: { type: ITEM_WOODEN_AXE, count: 1 },
                name: 'Wooden Axe'
            },
            // Wooden Sword
            {
                pattern: [null, ITEM_PLANKS, null, null, ITEM_PLANKS, null, null, ITEM_STICK, null],
                result: { type: ITEM_WOODEN_SWORD, count: 1 },
                name: 'Wooden Sword'
            },
            // Stone Pickaxe
            {
                pattern: [2, 2, 2, null, ITEM_STICK, null, null, ITEM_STICK, null],
                result: { type: ITEM_STONE_PICKAXE, count: 1 },
                name: 'Stone Pickaxe'
            },
            // Stone Axe
            {
                pattern: [2, 2, null, 2, ITEM_STICK, null, null, ITEM_STICK, null],
                result: { type: ITEM_STONE_AXE, count: 1 },
                name: 'Stone Axe'
            },
            // Stone Sword
            {
                pattern: [null, 2, null, null, 2, null, null, ITEM_STICK, null],
                result: { type: ITEM_STONE_SWORD, count: 1 },
                name: 'Stone Sword'
            }
        ];
        
        // Crafting grid state (9 slots)
        let craftingGrid = Array(9).fill(null);
        let craftingOutput = null;
        
        // Initialize crafting UI
        function initCraftingUI() {
            const craftingGridElement = document.getElementById('crafting-grid');
            craftingGridElement.innerHTML = '';
            
            for (let i = 0; i < 9; i++) {
                const slot = document.createElement('div');
                slot.classList.add('crafting-slot');
                slot.dataset.index = i;
                
                // Add hover sound effect
                let isHovering = false;
                slot.addEventListener('mouseenter', function() {
                    if (!isHovering) {
                        isHovering = true;
                        playHoverSound();
                    }
                });
                slot.addEventListener('mouseleave', function() {
                    isHovering = false;
                });
                
                craftingGridElement.appendChild(slot);
            }
            
            updateCraftingUI();
            updateRecipeList();
        }
        
        // Update crafting UI
        function updateCraftingUI() {
            const slots = document.querySelectorAll('.crafting-slot');
            slots.forEach((slot, i) => {
                const item = craftingGrid[i];
                if (item) {
                    const display = getBlockDisplay(item.type);
                    slot.innerHTML = `
                        <span class="slot-item" style="color:${display.color}">${display.name}</span>
                        <span class="slot-count">${item.count}</span>
                    `;
                } else {
                    slot.innerHTML = '';
                }
            });
            
            // Check for valid recipe
            craftingOutput = checkCraftingRecipe();
            const outputSlot = document.getElementById('crafting-output');
            if (craftingOutput) {
                const display = getBlockDisplay(craftingOutput.type);
                outputSlot.innerHTML = `
                    <span class="slot-item" style="color:${display.color}">${display.name}</span>
                    <span class="slot-count">${craftingOutput.count}</span>
                `;
            } else {
                outputSlot.innerHTML = '';
            }
        }
        
        // Check if current grid matches a recipe
        function checkCraftingRecipe() {
            const gridTypes = craftingGrid.map(item => item ? item.type : null);
            
            for (const recipe of craftingRecipes) {
                if (matchesPattern(gridTypes, recipe.pattern)) {
                    return { ...recipe.result };
                }
            }
            return null;
        }
        
        // Pattern matching with rotation support
        function matchesPattern(grid, pattern) {
            // Exact match
            if (grid.every((val, i) => val === pattern[i])) return true;
            
            // Try all rotations for 2x2 and 2x3 patterns
            const rotations = getPatternRotations(pattern);
            for (const rotated of rotations) {
                if (grid.every((val, i) => val === rotated[i])) return true;
            }
            
            return false;
        }
        
        // Get all rotations and flips of a pattern
        function getPatternRotations(pattern) {
            // This is simplified - in a full implementation, 
            // you'd want to support all rotations/flips
            return [pattern]; // Just return original for now
        }
        
        // Update recipe list display
        function updateRecipeList() {
            const recipesContentElement = document.getElementById('crafting-recipes-content');
            recipesContentElement.innerHTML = '<div style="font-size: 12px; color: #aaa; margin-bottom: 8px;"> Recipes:</div>';
            
            craftingRecipes.forEach((recipe, index) => {
                const recipeItem = document.createElement('div');
                recipeItem.classList.add('recipe-item');
                
                // Check if player has materials
                const canCraft = canCraftRecipe(recipe);
                if (!canCraft) {
                    recipeItem.classList.add('unavailable');
                }
                
                recipeItem.textContent = recipe.name;
                recipeItem.onclick = () => {
                    if (canCraft) {
                        showRecipeInGrid(recipe);
                    }
                };
                
                recipesContentElement.appendChild(recipeItem);
            });
            
            // Initialize custom scrollbar after recipes are loaded
            initCustomScrollbar();
        }
        
        // Custom Scrollbar Initialization
        function initCustomScrollbar() {
            const wrapper = document.getElementById('crafting-recipes-wrapper');
            const container = document.getElementById('crafting-recipes');
            const content = document.getElementById('crafting-recipes-content');
            const scrollbar = wrapper.querySelector('.custom-scrollbar');
            const thumb = wrapper.querySelector('.custom-scrollbar-thumb');
            
            if (!wrapper || !container || !content || !scrollbar || !thumb) return;
            
            let scrollPosition = 0;
            let scrollDragStartY = 0;
            let scrollDragStartScroll = 0;
            
            function updateScrollbar() {
                const containerHeight = container.clientHeight;
                const contentHeight = content.scrollHeight;
                const maxScroll = Math.max(0, contentHeight - containerHeight);
                
                if (maxScroll === 0) {
                    scrollbar.style.display = 'none';
                    return;
                }
                
                scrollbar.style.display = 'block';
                
                const thumbHeight = Math.max(20, (containerHeight / contentHeight) * containerHeight);
                const maxThumbPosition = containerHeight - thumbHeight;
                const thumbPosition = (scrollPosition / maxScroll) * maxThumbPosition;
                
                thumb.style.height = thumbHeight + 'px';
                thumb.style.transform = `translateY(${thumbPosition}px)`;
                content.style.transform = `translateY(-${scrollPosition}px)`;
            }
            
            function setScroll(newScroll) {
                const containerHeight = container.clientHeight;
                const contentHeight = content.scrollHeight;
                const maxScroll = Math.max(0, contentHeight - containerHeight);
                
                scrollPosition = Math.max(0, Math.min(newScroll, maxScroll));
                updateScrollbar();
            }
            
            // Expose scrollbar drag handler to global scope
            window.handleScrollbarDrag = function(cursorY) {
                const deltaY = cursorY - scrollDragStartY;
                const containerHeight = container.clientHeight;
                const contentHeight = content.scrollHeight;
                const maxScroll = contentHeight - containerHeight;
                const thumbHeight = Math.max(20, (containerHeight / contentHeight) * containerHeight);
                const maxThumbPosition = containerHeight - thumbHeight;
                
                const scrollDelta = (deltaY / maxThumbPosition) * maxScroll;
                setScroll(scrollDragStartScroll + scrollDelta);
            };
            
            // Scrollbar thumb drag - works with fake cursor
            thumb.addEventListener('mousedown', (e) => {
                e.preventDefault();
                e.stopPropagation();
                window.isDraggingScrollbar = true;
                scrollDragStartY = fakeCursorY; // Use fake cursor position
                scrollDragStartScroll = scrollPosition;
                thumb.classList.add('dragging');
            });
            
            document.addEventListener('mouseup', () => {
                if (window.isDraggingScrollbar) {
                    window.isDraggingScrollbar = false;
                    thumb.classList.remove('dragging');
                }
            });
            
            // Mouse wheel scrolling - detect if fake cursor is over wrapper
            document.addEventListener('wheel', (e) => {
                const rect = wrapper.getBoundingClientRect();
                const isOverWrapper = fakeCursorX >= rect.left && fakeCursorX <= rect.right &&
                                     fakeCursorY >= rect.top && fakeCursorY <= rect.bottom;
                
                if (isOverWrapper && inventoryOpen) {
                    e.preventDefault();
                    setScroll(scrollPosition + e.deltaY);
                }
            });
            
            // Click on scrollbar track
            scrollbar.addEventListener('click', (e) => {
                if (e.target === scrollbar) {
                    const rect = scrollbar.getBoundingClientRect();
                    const clickY = e.clientY - rect.top;
                    const containerHeight = container.clientHeight;
                    const contentHeight = content.scrollHeight;
                    const maxScroll = contentHeight - containerHeight;
                    
                    const targetScroll = (clickY / containerHeight) * maxScroll;
                    setScroll(targetScroll);
                }
            });
            
            updateScrollbar();
        }
        
        // Check if player has materials for a recipe
        function canCraftRecipe(recipe) {
            const required = {};
            recipe.pattern.forEach(type => {
                if (type !== null) {
                    required[type] = (required[type] || 0) + 1;
                }
            });
            
            const available = {};
            inventoryData.forEach(item => {
                if (item) {
                    available[item.type] = (available[item.type] || 0) + item.count;
                }
            });
            
            for (const type in required) {
                if ((available[type] || 0) < required[type]) {
                    return false;
                }
            }
            return true;
        }
        
        // Show recipe pattern in crafting grid (helper)
        function showRecipeInGrid(recipe) {
            // This would auto-fill the grid with the recipe pattern
            // For now, players craft manually
        }
        
        // Craft item from output
        function craftItem() {
            if (!craftingOutput) return;
            
            // Remove materials from grid
            craftingGrid = craftingGrid.map(item => {
                if (!item) return null;
                if (item.count > 1) {
                    return { ...item, count: item.count - 1 };
                }
                return null;
            });
            
            // Create result item with proper properties
            const resultType = craftingOutput.type;
            const resultCount = craftingOutput.count;
            
            // If it's a tool, initialize with full durability
            if (resultType < 0 && itemDefinitions[resultType] && itemDefinitions[resultType].isTool) {
                // Add tool to inventory with durability
                const itemDef = itemDefinitions[resultType];
                for (let i = 0; i < resultCount; i++) {
                    // Find empty slot and add tool with full durability
                    let added = false;
                    // Try hotbar first (24-31)
                    for (let j = MAIN_SLOTS; j < TOTAL_SLOTS; j++) {
                        if (!inventoryData[j]) {
                            inventoryData[j] = { 
                                type: resultType, 
                                count: 1, 
                                durability: itemDef.maxDurability 
                            };
                            added = true;
                            break;
                        }
                    }
                    // Then try main inventory (0-23)
                    if (!added) {
                        for (let j = 0; j < MAIN_SLOTS; j++) {
                            if (!inventoryData[j]) {
                                inventoryData[j] = { 
                                    type: resultType, 
                                    count: 1, 
                                    durability: itemDef.maxDurability 
                                };
                                break;
                            }
                        }
                    }
                }
            } else {
                // Regular item, use normal addToInventory
                addToInventory(resultType, resultCount);
            }
            
            // Update UI
            updateCraftingUI();
            updateInventoryUI();
            updateToolbarSelection();
            updateRecipeList();
            
            // Play crafting sound
            playPlaceSound(2); // Stone sound for crafting
        }
        
        // Get tool mining speed bonus
        function getToolMiningSpeed(toolType, blockType) {
            if (toolType === null || toolType === undefined) return 1;
            
            const tool = itemDefinitions[toolType];
            if (!tool) return 1;
            
            // Pickaxes are good for stone, axes for wood
            if (tool.isPickaxe && blockType === 2) return tool.miningSpeed;
            if (tool.isAxe && (blockType === 3 || blockType === 6)) return tool.miningSpeed;
            
            return tool.miningSpeed || 1;
        }
        
        // Maps X, Y (0-7, 0-2) to the main inventory array index (0-23)
        function getMainSlotIndex(x, y) {
            return y * MAIN_INV_WIDTH + x;
        }

        // Maps HUD selection (0-7) to the inventoryData array index (24-31)
        function getHUDIndex(hudSlot) {
            return MAIN_SLOTS + hudSlot;
        }

        // Gets the universal index (0-31) based on cursor position
        function getSlotIndexFromCursor() {
            if (cursorY < MAIN_INV_HEIGHT) {
                return getMainSlotIndex(cursorX, cursorY);
            } else {
                return getHUDIndex(cursorX);
            }
        }
        
        // Helper function to get max stack size for an item type
        function getMaxStack(type) {
            if (type < 0) {
                const itemDef = itemDefinitions[type];
                return itemDef && itemDef.maxStack ? itemDef.maxStack : MAX_STACK;
            }
            return MAX_STACK;
        }
        
        // MODIFIED: Block collection now prioritizes HUD slots (24-31) over Main Inventory slots (0-23).
        function addToInventory(type, count = 1) {
            // In creative mode, we don't need to add destroyed blocks
            if (isCreativeMode) return; 
            
            let remaining = count;
            const maxStack = getMaxStack(type);
            
            // Helper function to iterate over a range of slots
            const trySlots = (start, end, action) => {
                for (let i = start; i < end; i++) {
                    if (remaining === 0) return;
                    action(i);
                }
            };
            
            // 1. Try to stack with existing items
            
            // 1a. Prioritize HUD slots (24 to 31)
            trySlots(MAIN_SLOTS, TOTAL_SLOTS, (i) => {
                const item = inventoryData[i];
                if (item && item.type === type && item.count < maxStack) {
                    const space = maxStack - item.count;
                    const transfer = Math.min(remaining, space);
                    item.count += transfer;
                    remaining -= transfer;
                }
            });
            
            // 1b. Then Main inventory slots (0 to 23)
            trySlots(0, MAIN_SLOTS, (i) => {
                const item = inventoryData[i];
                if (item && item.type === type && item.count < maxStack) {
                    const space = maxStack - item.count;
                    const transfer = Math.min(remaining, space);
                    item.count += transfer;
                    remaining -= transfer;
                }
            });
            
            // 2. Place remaining items in empty slots
            if (remaining > 0) {
                
                // 2a. Prioritize empty HUD slots (24 to 31)
                trySlots(MAIN_SLOTS, TOTAL_SLOTS, (i) => {
                    if (!inventoryData[i]) {
                        const transfer = Math.min(remaining, maxStack);
                        inventoryData[i] = { type: type, count: transfer };
                        remaining -= transfer;
                    }
                });

                // 2b. Then empty Main inventory slots (0 to 23)
                trySlots(0, MAIN_SLOTS, (i) => {
                    if (!inventoryData[i]) {
                        const transfer = Math.min(remaining, maxStack);
                        inventoryData[i] = { type: type, count: transfer };
                        remaining -= transfer;
                    }
                });
            }
            
            updateInventoryUI();
            updateToolbarSelection(); 
        }
        
        // Find block in inventory and return slot info
        function findBlockInInventory(blockType) {
            // First check hotbar (24-31)
            for (let i = MAIN_SLOTS; i < TOTAL_SLOTS; i++) {
                const item = inventoryData[i];
                if (item && item.type === blockType) {
                    return { found: true, slotIndex: i, isHotbar: true, hotbarSlot: i - MAIN_SLOTS };
                }
            }
            
            // Then check main inventory (0-23)
            for (let i = 0; i < MAIN_SLOTS; i++) {
                const item = inventoryData[i];
                if (item && item.type === blockType) {
                    return { found: true, slotIndex: i, isHotbar: false };
                }
            }
            
            return { found: false };
        }
        
        // Middle-click block picker
        function handleMiddleClickBlockPick(blockType) {
            const result = findBlockInInventory(blockType);
            
            if (result.found) {
                if (result.isHotbar) {
                    // Block is in hotbar, just switch to it
                    sel = result.hotbarSlot;
                    updateToolbarSelection();
                } else {
                    // Block is in main inventory, move to current hotbar slot
                    const currentHotbarIndex = getHUDIndex(sel);
                    const item = inventoryData[result.slotIndex];
                    
                    if (isCreativeMode) {
                        // In creative, just place it in hotbar
                        const isTool = blockType < 0 && itemDefinitions[blockType] && itemDefinitions[blockType].isTool;
                        if (isTool) {
                            const itemDef = itemDefinitions[blockType];
                            inventoryData[currentHotbarIndex] = { 
                                type: blockType, 
                                count: 1,
                                durability: itemDef.maxDurability 
                            };
                        } else {
                            inventoryData[currentHotbarIndex] = { type: blockType, count: 64 };
                        }
                    } else {
                        // In survival, swap or move the item
                        inventoryData[currentHotbarIndex] = item;
                        inventoryData[result.slotIndex] = null;
                    }
                    
                    updateInventoryUI();
                    updateToolbarSelection();
                }
            } else {
                // Block not found in inventory
                if (isCreativeMode) {
                    // In creative, add it to current hotbar slot
                    const currentHotbarIndex = getHUDIndex(sel);
                    const isTool = blockType < 0 && itemDefinitions[blockType] && itemDefinitions[blockType].isTool;
                    if (isTool) {
                        const itemDef = itemDefinitions[blockType];
                        inventoryData[currentHotbarIndex] = { 
                            type: blockType, 
                            count: 1,
                            durability: itemDef.maxDurability 
                        };
                    } else {
                        inventoryData[currentHotbarIndex] = { type: blockType, count: 64 };
                    }
                    updateInventoryUI();
                    updateToolbarSelection();
                }
                // In survival, do nothing if block not found
            }
        }
        
        /**
         * Generates a simple tree structure.
         */
        function generateTree(startX, startY, startZ) {
            // Simple tree parameters
            const trunkHeight = Math.floor(Math.random() * 3) + 4; // 4 to 6 tall trunk
            
            // 1. Create Trunk (WOOD_TYPE = 3)
            for (let y = 0; y < trunkHeight; y++) {
                add(startX, startY + y, startZ, WOOD_TYPE);
            }
            
            // 2. Create Leaves Canopy (LEAVES_TYPE = 6)
            const leavesBaseY = startY + trunkHeight - 2; // Start leaves 2 blocks down from the top of the trunk
            
            // Layer 1 and 2 (bottom layers, 5x5-ish)
            for (let ly = 0; ly < 2; ly++) {
                for (let lx = -2; lx <= 2; lx++) {
                    for (let lz = -2; lz <= 2; lz++) {
                        // Skip corners for a diamond/rounded shape
                        if ((Math.abs(lx) === 2 && Math.abs(lz) === 2)) continue; 
                        
                        add(startX + lx, leavesBaseY + ly, startZ + lz, LEAVES_TYPE);
                    }
                }
            }

            // Layer 3 and 4 (top layers, 3x3)
            for (let ly = 2; ly < 4; ly++) {
                for (let lx = -1; lx <= 1; lx++) {
                    for (let lz = -1; lz <= 1; lz++) {
                        add(startX + lx, leavesBaseY + ly, startZ + lz, LEAVES_TYPE);
                    }
                }
            }
        }


        // --- INVENTORY UI & NAVIGATION ---
        
        function moveCursor(dx, dy) {
            // Navigable area is 8x4 (3 main rows + 1 HUD row)
            const MAX_Y = MAIN_INV_HEIGHT; // 3
            
            cursorX = Math.max(0, Math.min(MAIN_INV_WIDTH - 1, cursorX + dx));
            cursorY = Math.max(0, Math.min(MAX_Y, cursorY + dy)); 

            updateInventoryUI();
        }

        function updateToolbarSelection() {
            // Loop for the 8 HUD buttons
            btns.forEach((b, index) => {
                const hudIndex = getHUDIndex(index);
                const item = inventoryData[hudIndex];

                // 1. Update Visuals (sel is 0-7)
                b.classList.toggle('selected', index === sel);
                
                // 2. Update Content
                if (item) {
                    const display = getBlockDisplay(item.type);
                    const countDisplay = isCreativeMode ? '' : item.count; // Mode-dependent count
                    b.innerHTML = `
                        <span class="slot-item" style="color:${display.color}">${display.name}</span>
                        <span class="slot-count">${countDisplay}</span>
                    `;
                } else {
                     b.innerHTML = `<span style="font-size: 14px; opacity: 0.5;">${index + 1}</span>`;
                }
            });

            // 3. Update the global block placement variable (Active Block Type)
            const activeItem = inventoryData[getHUDIndex(sel)];
            window.activeBlockType = activeItem ? activeItem.type : null;
            
            // 4. Update held item in hand
            updateHeldItem();
        }

        function updateInventoryUI() {
            if (!mainInventoryGrid || !hudInventoryGrid) return; // Safety check
            const mainSlots = mainInventoryGrid.querySelectorAll('.inventory-slot');
            const hudSlots = hudInventoryGrid.querySelectorAll('.inventory-slot');
            const currentCursorSlotIndex = getSlotIndexFromCursor(); // Get the 0-31 index of the slot under the cursor
            
            // 1. Update all slot contents and clear selection/red classes
            const allSlots = [...mainSlots, ...hudSlots];
            allSlots.forEach((slot, index) => {
                let item = inventoryData[index]; // Item data from inventory array
                
                slot.innerHTML = '';
                slot.classList.remove('slot-selected');
                
                if (item) {
                    const display = getBlockDisplay(item.type);
                    const countDisplay = isCreativeMode ? '' : item.count; // Mode-dependent count
                    slot.innerHTML = `
                        <span class="slot-item" style="color:${display.color}">${display.name}</span>
                        <span class="slot-count">${countDisplay}</span>
                    `;
                }
            });

            // 2. NEW: Update the picked-up item element
            if (pickedUpItemElement) {
                if (pickedUpItem) {
                    const display = getBlockDisplay(pickedUpItem.type);
                    const countDisplay = isCreativeMode ? '' : pickedUpItem.count;
                    pickedUpItemElement.innerHTML = `
                        <span class="slot-item" style="color:${display.color}">${display.name}</span>
                        <span class="slot-count">${countDisplay}</span>
                    `;
                    pickedUpItemElement.style.display = 'flex';
                } else {
                    pickedUpItemElement.style.display = 'none';
                    pickedUpItemElement.innerHTML = '';
                }
            }
        }
        
        // Item categories for organized creative menu
        const itemCategories = {
            blocks: [1, 2, 5, 12], // DIRT, STONE, BEDROCK, PLANKS
            nature: [0, 3, 4, 6], // GRASS, WOOD, SAND, LEAVES
            decorative: [7, 8, 9], // GLASS, DOOR, TORCH
            tools: [-1, -2, -3, -4, -5, -6, -7, -8], // All tools and items
            liquids: [10, 11], // WATER, LAVA
        };
        
        // Current selected category
        let currentCategory = 'all';
        
        // NEW: Generate the creative block picker with category filtering
        function generateBlockPicker(category = 'all') {
            if (!creativeBlockPicker) return; // Safety check
            creativeBlockPicker.innerHTML = '';
            
            // Helper function to check if item should be shown
            const shouldShowItem = (type) => {
                if (category === 'all') return true;
                return itemCategories[category] && itemCategories[category].includes(type);
            };
            
            // Add all blocks first
            blockNames.forEach((name, type) => {
                if (!shouldShowItem(type)) return;
                
                const slot = document.createElement('div');
                slot.classList.add('inventory-slot');
                slot.dataset.type = type;

                const display = getBlockDisplay(type);
                slot.innerHTML = `
                    <span class="slot-item" style="color:${display.color}">${display.name}</span>
                    <span class="slot-count"></span>
                `;
                
                // Add hover sound effect
                let isHovering = false;
                slot.addEventListener('mouseenter', function() {
                    if (!isHovering) {
                        isHovering = true;
                        playHoverSound();
                    }
                });
                slot.addEventListener('mouseleave', function() {
                    isHovering = false;
                });
                
                creativeBlockPicker.appendChild(slot);
            });
            
            // Add all items/tools
            Object.keys(itemDefinitions).forEach(itemType => {
                const itemNum = parseInt(itemType);
                if (!shouldShowItem(itemNum)) return;
                
                const itemDef = itemDefinitions[itemNum];
                
                const slot = document.createElement('div');
                slot.classList.add('inventory-slot');
                slot.dataset.type = itemNum;
                
                slot.innerHTML = `
                    <span class="slot-item" style="color:${itemDef.color}">${itemDef.name}</span>
                    <span class="slot-count"></span>
                `;
                
                // Add hover sound effect
                let isHovering = false;
                slot.addEventListener('mouseenter', function() {
                    if (!isHovering) {
                        isHovering = true;
                        playHoverSound();
                    }
                });
                slot.addEventListener('mouseleave', function() {
                    isHovering = false;
                });
                
                creativeBlockPicker.appendChild(slot);
            });
        }
        
        // Initialize category tabs
        function initCategoryTabs() {
            const tabs = document.querySelectorAll('.category-tab');
            tabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    const category = this.dataset.category;
                    currentCategory = category;
                    
                    // Update active tab
                    tabs.forEach(t => t.classList.remove('active'));
                    this.classList.add('active');
                    
                    // Regenerate picker with new category
                    generateBlockPicker(category);
                    
                    // Play click sound
                    playClickSound();
                });
            });
        }
        
        function generateInventorySlots() {
            if (!mainInventoryGrid || !hudInventoryGrid) return; // Safety check
            mainInventoryGrid.innerHTML = '';
            hudInventoryGrid.innerHTML = '';
            
            let slotIndexCounter = 0;

            // Generate Main Inventory Slots (8x3)
            for (let y = 0; y < MAIN_INV_HEIGHT; y++) {
                for (let x = 0; x < MAIN_INV_WIDTH; x++) {
                    const slot = document.createElement('div');
                    slot.classList.add('inventory-slot');
                    
                    slot.dataset.x = x;
                    slot.dataset.y = y;
                    slot.dataset.index = slotIndexCounter;
                    
                    // Add hover sound effect
                    let isHovering = false;
                    slot.addEventListener('mouseenter', function() {
                        if (!isHovering) {
                            isHovering = true;
                            playHoverSound();
                        }
                    });
                    slot.addEventListener('mouseleave', function() {
                        isHovering = false;
                    });
                    
                    mainInventoryGrid.appendChild(slot);
                    slotIndexCounter++;
                }
            }
            
            // Generate HUD Inventory Slots (8 slots)
            for (let i = 0; i < HUD_WIDTH; i++) {
                const slot = document.createElement('div');
                slot.classList.add('inventory-slot', 'hud-slot');
                
                slot.dataset.x = i; 
                slot.dataset.y = HUD_Y; 
                slot.dataset.index = slotIndexCounter; 

                // Add hover sound effect
                let isHovering = false;
                slot.addEventListener('mouseenter', function() {
                    if (!isHovering) {
                        isHovering = true;
                        playHoverSound();
                    }
                });
                slot.addEventListener('mouseleave', function() {
                    isHovering = false;
                });

                hudInventoryGrid.appendChild(slot);
                slotIndexCounter++;
            }

            updateInventoryUI();
            generateBlockPicker(currentCategory); // Also generate the creative picker
            initCraftingUI(); // Initialize crafting system
            initCategoryTabs(); // Initialize category tabs
        }

        
        function swapItems(slotIndex) {
             let slotItem = inventoryData[slotIndex];
             
             // --- REFACTORED: Creative and Survival inventory moving is identical ---
             // This logic *moves* items, it does not copy.
             if (pickedUpItem) {
                // SECOND CLICK/SPACE: Placing/Stacking
                const maxStack = getMaxStack(pickedUpItem.type);
                const slotMaxStack = slotItem ? getMaxStack(slotItem.type) : MAX_STACK;
                
                if (slotItem && pickedUpItem.type === slotItem.type && slotItem.count < slotMaxStack && !isCreativeMode) { // Stack only in survival
                    // Stack items (respecting maxStack)
                    const space = slotMaxStack - slotItem.count;
                    const transfer = Math.min(pickedUpItem.count, space);
                    slotItem.count += transfer;
                    pickedUpItem.count -= transfer;

                    if (pickedUpItem.count === 0) {
                        pickedUpItem = null;
                    }
                } else {
                    // Standard Swap
                    const tempItem = pickedUpItem;
                    pickedUpItem = slotItem;
                    inventoryData[slotIndex] = tempItem;
                }

             } else {
                 // FIRST CLICK/SPACE: Picking up
                 if (slotItem) {
                     pickedUpItem = slotItem;
                     inventoryData[slotIndex] = null; // Item is now only in the pickedUpItem container
                 }
             }
             
             updateInventoryUI();
             updateToolbarSelection(); 
        }

        // --- NEW: Right-click handling function ---
        function handleInventoryRightClick(slotIndex) {
            if (isCreativeMode) {
                // Creative right-click: Same as left-click (pick up stack)
                swapItems(slotIndex);
            } else {
                // --- Survival Right-Click Logic (Split/Place One) ---
                let slotItem = inventoryData[slotIndex];
                
                if (pickedUpItem) {
                    // Placing one item down
                    const maxStack = getMaxStack(pickedUpItem.type);
                    const slotMaxStack = slotItem ? getMaxStack(slotItem.type) : MAX_STACK;
                    
                    if (!slotItem) {
                        // Place one in empty slot
                        inventoryData[slotIndex] = { type: pickedUpItem.type, count: 1 };
                        // Copy durability if it's a tool
                        if (pickedUpItem.durability !== undefined) {
                            inventoryData[slotIndex].durability = pickedUpItem.durability;
                        }
                        pickedUpItem.count--;
                    } else if (slotItem.type === pickedUpItem.type && slotItem.count < slotMaxStack) {
                        // Stack one (only if not a tool, tools have maxStack of 1)
                        slotItem.count++;
                        pickedUpItem.count--;
                    }
                    if (pickedUpItem.count === 0) pickedUpItem = null;
                    
                } else if (slotItem) {
                    // Picking up half stack (tools with maxStack 1 can't be split)
                    const maxStack = getMaxStack(slotItem.type);
                    if (maxStack === 1) {
                        // Can't split tools, pick up the whole item
                        pickedUpItem = slotItem;
                        inventoryData[slotIndex] = null;
                    } else {
                        const half = Math.ceil(slotItem.count / 2);
                        pickedUpItem = { type: slotItem.type, count: half };
                        slotItem.count -= half;
                        if (slotItem.count === 0) inventoryData[slotIndex] = null;
                    }
                }
                updateInventoryUI();
                updateToolbarSelection();
            }
        }
        
        // --- REFACTORED: Mouse Up listener ---
        document.addEventListener('mouseup', function(e) {
            if (!inventoryOpen || !pickedUpItem) return;

            // Get element under fake cursor
            fakeCursorElement.style.display = 'none';
            let elementUnderCursor = document.elementFromPoint(fakeCursorX, fakeCursorY);
            fakeCursorElement.style.display = 'block';
            
            // Check if mouse is outside all valid drop zones
            const targetInv = elementUnderCursor ? elementUnderCursor.closest('.inventory-container') : null;
            const targetPicker = elementUnderCursor ? elementUnderCursor.closest('#creative-block-picker') : null;
            const targetDelete = elementUnderCursor ? elementUnderCursor.closest('#delete-slot') : null;
            
            if (!targetInv && !targetPicker && !targetDelete) { // MODIFIED
                // Dropped item outside inventory
                if (!isCreativeMode) {
                    // In survival, add it back
                    addToInventory(pickedUpItem.type, pickedUpItem.count);
                }
                // In creative or survival, the item is dropped from cursor
                pickedUpItem = null; 
                updateInventoryUI();
                updateToolbarSelection();
            }
        });


        // --- Three.js & World Logic ---
        
        // ==================== MINECRAFT-STYLE AABB HITBOX SYSTEM ====================
        
        // AABB (Axis-Aligned Bounding Box) class for Minecraft-style collision
        class AABB {
            constructor(minX, minY, minZ, maxX, maxY, maxZ) {
                this.minX = minX;
                this.minY = minY;
                this.minZ = minZ;
                this.maxX = maxX;
                this.maxY = maxY;
                this.maxZ = maxZ;
            }
            
            // Create AABB from center position and dimensions
            static fromCenter(x, y, z, width, height, depth = null) {
                if (depth === null) depth = width;
                const halfWidth = width / 2;
                const halfDepth = depth / 2;
                return new AABB(
                    x - halfWidth,
                    y,
                    z - halfDepth,
                    x + halfWidth,
                    y + height,
                    z + halfDepth
                );
            }
            
            // Check if this AABB intersects with another
            intersects(other) {
                return this.minX < other.maxX && this.maxX > other.minX &&
                       this.minY < other.maxY && this.maxY > other.minY &&
                       this.minZ < other.maxZ && this.maxZ > other.minZ;
            }
            
            // Move the AABB by offset
            offset(dx, dy, dz) {
                return new AABB(
                    this.minX + dx,
                    this.minY + dy,
                    this.minZ + dz,
                    this.maxX + dx,
                    this.maxY + dy,
                    this.maxZ + dz
                );
            }
            
            // Expand the AABB
            expand(x, y, z) {
                return new AABB(
                    this.minX - x,
                    this.minY - y,
                    this.minZ - z,
                    this.maxX + x,
                    this.maxY + y,
                    this.maxZ + z
                );
            }
            
            // Calculate collision on X axis
            calculateXOffset(other, offsetX) {
                if (other.maxY > this.minY && other.minY < this.maxY &&
                    other.maxZ > this.minZ && other.minZ < this.maxZ) {
                    if (offsetX > 0 && other.maxX <= this.minX) {
                        const max = this.minX - other.maxX;
                        if (max < offsetX) offsetX = max;
                    } else if (offsetX < 0 && other.minX >= this.maxX) {
                        const max = this.maxX - other.minX;
                        if (max > offsetX) offsetX = max;
                    }
                }
                return offsetX;
            }
            
            // Calculate collision on Y axis
            calculateYOffset(other, offsetY) {
                if (other.maxX > this.minX && other.minX < this.maxX &&
                    other.maxZ > this.minZ && other.minZ < this.maxZ) {
                    if (offsetY > 0 && other.maxY <= this.minY) {
                        const max = this.minY - other.maxY;
                        if (max < offsetY) offsetY = max;
                    } else if (offsetY < 0 && other.minY >= this.maxY) {
                        const max = this.maxY - other.minY;
                        if (max > offsetY) offsetY = max;
                    }
                }
                return offsetY;
            }
            
            // Calculate collision on Z axis
            calculateZOffset(other, offsetZ) {
                if (other.maxX > this.minX && other.minX < this.maxX &&
                    other.maxY > this.minY && other.minY < this.maxY) {
                    if (offsetZ > 0 && other.maxZ <= this.minZ) {
                        const max = this.minZ - other.maxZ;
                        if (max < offsetZ) offsetZ = max;
                    } else if (offsetZ < 0 && other.minZ >= this.maxZ) {
                        const max = this.maxZ - other.minZ;
                        if (max > offsetZ) offsetZ = max;
                    }
                }
                return offsetZ;
            }
        }
        
        // Raycast from player's eye to detect what block they're looking at
        function raycastFromEye(eyeX, eyeY, eyeZ, dirX, dirY, dirZ, maxDistance) {
            const step = 0.1;
            const steps = Math.floor(maxDistance / step);
            
            for (let i = 0; i < steps; i++) {
                const t = i * step;
                const x = eyeX + dirX * t;
                const y = eyeY + dirY * t;
                const z = eyeZ + dirZ * t;
                
                const bx = Math.floor(x / bs);
                const by = Math.floor(y / bs);
                const bz = Math.floor(z / bs);
                
                const blockKey = key(bx, by, bz);
                const block = world[blockKey];
                
                if (block && !block.userData.isTorch) {
                    // Skip transparent blocks
                    if (block.userData.blockType === WATER_TYPE || 
                        block.userData.blockType === LAVA_TYPE) {
                        continue;
                    }
                    
                    // Skip open doors
                    if (block.userData.blockType === DOOR_TYPE && block.userData.doorOpen) {
                        continue;
                    }
                    
                    // Found a solid block
                    return {
                        hit: true,
                        blockX: bx,
                        blockY: by,
                        blockZ: bz,
                        block: block,
                        distance: t,
                        hitX: x,
                        hitY: y,
                        hitZ: z
                    };
                }
            }
            
            return { hit: false };
        }
        
        // Get all block AABBs that could collide with the given AABB
        function getCollidingBlockAABBs(aabb) {
            const blockAABBs = [];
            
            const minBlockX = Math.floor(aabb.minX / bs);
            const minBlockY = Math.floor(aabb.minY / bs);
            const minBlockZ = Math.floor(aabb.minZ / bs);
            const maxBlockX = Math.ceil(aabb.maxX / bs);
            const maxBlockY = Math.ceil(aabb.maxY / bs);
            const maxBlockZ = Math.ceil(aabb.maxZ / bs);
            
            for (let bx = minBlockX; bx <= maxBlockX; bx++) {
                for (let by = minBlockY; by <= maxBlockY; by++) {
                    for (let bz = minBlockZ; bz <= maxBlockZ; bz++) {
                        const blockKey = key(bx, by, bz);
                        const block = world[blockKey];
                        
                        if (!block) continue;
                        
                        // Skip non-solid blocks
                        if (block.userData.isTorch) continue;
                        if (block.userData.blockType === WATER_TYPE || 
                            block.userData.blockType === LAVA_TYPE) continue;
                        if (block.userData.blockType === DOOR_TYPE && block.userData.doorOpen) continue;
                        
                        // Create AABB for this block
                        const blockAABB = new AABB(
                            bx * bs - bs/2,
                            by * bs - bs/2,
                            bz * bs - bs/2,
                            bx * bs + bs/2,
                            by * bs + bs/2,
                            bz * bs + bs/2
                        );
                        
                        blockAABBs.push(blockAABB);
                    }
                }
            }
            
            return blockAABBs;
        }
        
        // Minecraft-style per-axis collision with step-up
        function moveWithCollision(aabb, dx, dy, dz, stepHeight = 0) {
            const originalY = dy;
            
            // Get all potentially colliding blocks
            const expandedAABB = aabb.expand(
                Math.abs(dx) + 0.1,
                Math.abs(dy) + stepHeight + 0.1,
                Math.abs(dz) + 0.1
            );
            const blockAABBs = getCollidingBlockAABBs(expandedAABB);
            
            // Y axis first (vertical)
            let newDY = dy;
            for (const blockAABB of blockAABBs) {
                newDY = blockAABB.calculateYOffset(aabb, newDY);
            }
            const afterYAABB = aabb.offset(0, newDY, 0);
            
            // X axis
            let newDX = dx;
            for (const blockAABB of blockAABBs) {
                newDX = blockAABB.calculateXOffset(afterYAABB, newDX);
            }
            const afterXAABB = afterYAABB.offset(newDX, 0, 0);
            
            // Z axis
            let newDZ = dz;
            for (const blockAABB of blockAABBs) {
                newDZ = blockAABB.calculateZOffset(afterXAABB, newDZ);
            }
            
            // Step-up logic (Minecraft-style)
            let onGround = (originalY < 0 && newDY !== originalY);
            
            if (stepHeight > 0 && onGround && (newDX !== dx || newDZ !== dz)) {
                // Try to step up
                const stepUpAABB = aabb.offset(0, stepHeight, 0);
                
                let stepDX = dx;
                let stepDZ = dz;
                
                for (const blockAABB of blockAABBs) {
                    stepDX = blockAABB.calculateXOffset(stepUpAABB, stepDX);
                }
                const afterStepXAABB = stepUpAABB.offset(stepDX, 0, 0);
                
                for (const blockAABB of blockAABBs) {
                    stepDZ = blockAABB.calculateZOffset(afterStepXAABB, stepDZ);
                }
                
                // If stepping up allows more movement, use it
                const normalDistSq = newDX * newDX + newDZ * newDZ;
                const stepDistSq = stepDX * stepDX + stepDZ * stepDZ;
                
                if (stepDistSq > normalDistSq) {
                    newDX = stepDX;
                    newDZ = stepDZ;
                    newDY = stepHeight;
                    
                    // Move down until we hit the ground
                    let downY = -stepHeight;
                    const afterStepAABB = aabb.offset(newDX, newDY, newDZ);
                    for (const blockAABB of blockAABBs) {
                        downY = blockAABB.calculateYOffset(afterStepAABB, downY);
                    }
                    newDY += downY;
                }
            }
            
            return {
                dx: newDX,
                dy: newDY,
                dz: newDZ,
                collidedX: newDX !== dx,
                collidedY: newDY !== originalY,
                collidedZ: newDZ !== dz,
                onGround: onGround
            };
        }
        
        // Entity list for pushing mechanics
        let entities = [];
        
        // Simple entity pushing when AABBs overlap
        function handleEntityPushing(playerAABB, playerVelX, playerVelZ) {
            for (const entity of entities) {
                if (!entity.aabb) continue;
                
                if (playerAABB.intersects(entity.aabb)) {
                    // Calculate overlap
                    const overlapX = Math.min(playerAABB.maxX - entity.aabb.minX, entity.aabb.maxX - playerAABB.minX);
                    const overlapZ = Math.min(playerAABB.maxZ - entity.aabb.minZ, entity.aabb.maxZ - playerAABB.minZ);
                    
                    // Push entity away from player
                    const centerX = (playerAABB.minX + playerAABB.maxX) / 2;
                    const centerZ = (playerAABB.minZ + playerAABB.maxZ) / 2;
                    const entityCenterX = (entity.aabb.minX + entity.aabb.maxX) / 2;
                    const entityCenterZ = (entity.aabb.minZ + entity.aabb.maxZ) / 2;
                    
                    const pushDirX = entityCenterX - centerX;
                    const pushDirZ = entityCenterZ - centerZ;
                    const pushDist = Math.sqrt(pushDirX * pushDirX + pushDirZ * pushDirZ);
                    
                    if (pushDist > 0.01) {
                        const pushStrength = 0.05;
                        entity.x += (pushDirX / pushDist) * pushStrength;
                        entity.z += (pushDirZ / pushDist) * pushStrength;
                        
                        // Update entity AABB
                        if (entity.width && entity.height) {
                            entity.aabb = AABB.fromCenter(entity.x, entity.y, entity.z, entity.width, entity.height);
                        }
                    }
                }
            }
        }
        
        // ==================== END HITBOX SYSTEM ====================
        
        // Generate the 8 HUD buttons
        for (var bi = 0; bi < HUD_WIDTH; bi++) {
            var btn = document.createElement('button');
            btn.id = 'btn' + bi;
            btn.dataset.hudSlot = bi;
            toolbar.appendChild(btn);
            btns.push(btn);
        }

        var c = document.getElementById('c');
        var scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        // Fog starts much further away and ends beyond render distance so blocks don't disappear
        scene.fog = new THREE.Fog(0x87CEEB, 500, 1000);

        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        // --- FRUSTUM FOR OPTIMIZED CULLING ---
        var frustum = new THREE.Frustum();
        var cameraViewProjectionMatrix = new THREE.Matrix4();
        
        // --- DEBUG HITBOX VISUALIZATION ---
        var showHitbox = false; // Hidden by default, toggle with F3
        
        // Create wireframe box for player hitbox visualization
        const hitboxWidth = PLAYER_RADIUS * 2; // 0.6 blocks wide
        const hitboxHeight = PLAYER_TOTAL_HEIGHT; // 1.8 blocks tall
        const hitboxGeometry = new THREE.BoxGeometry(hitboxWidth, hitboxHeight, hitboxWidth);
        const hitboxMaterial = new THREE.LineBasicMaterial({ 
            color: 0x00ff00, // Bright green outline
            linewidth: 3,
            depthTest: false, // Always visible through blocks
            depthWrite: false,
            transparent: true,
            opacity: 1.0
        });
        const hitboxEdges = new THREE.EdgesGeometry(hitboxGeometry);
        const hitboxWireframe = new THREE.LineSegments(hitboxEdges, hitboxMaterial);
        hitboxWireframe.renderOrder = 999; // Render on top
        hitboxWireframe.visible = false; // Hidden by default, toggle with F3
        scene.add(hitboxWireframe);
        // --- END DEBUG HITBOX VISUALIZATION ---
        
        // --- PERSPECTIVE SWITCHING SYSTEM ---
        var perspectiveMode = 0; // 0 = first person, 1 = third person back, 2 = third person front (DEFAULT: FIRST PERSON)
        const THIRD_PERSON_DISTANCE = 5.0; // Distance from player in third person (increased for better view)
        const CAMERA_COLLISION_PADDING = 0.3; // Extra space between camera and blocks
        
        // Walking animation variables
        let walkAnimationTimer = 0;
        const WALK_ANIMATION_SPEED = 8.0; // Speed of limb swinging
        const ARM_SWING_AMPLITUDE = 0.8; // How far arms swing (radians)
        const LEG_SWING_AMPLITUDE = 0.6; // How far legs swing (radians)
        
        // Idle animation variables (like Minecraft)
        let idleAnimationTimer = 0;
        const IDLE_ANIMATION_SPEED = 1.5; // Slow breathing/sway speed
        const IDLE_ARM_SWAY = 0.05; // Subtle arm sway
        const IDLE_HEAD_BOB = 0.015; // Subtle head bob
        const IDLE_BODY_SWAY = 0.008; // Very subtle body rotation
        
        // Create enhanced player model for third-person view (BIGGER & MORE VISIBLE)
        const playerModelGroup = new THREE.Group();
        
        // SCALE FACTOR: Make character 1.5x bigger for better visibility
        const modelScale = 1.5;
        
        // Layer meshes (second layer) - stored globally
        let headLayerMesh = null;
        let bodyLayerMesh = null;
        let leftArmLayerMesh = null;
        let rightArmLayerMesh = null;
        let leftLegLayerMesh = null;
        let rightLegLayerMesh = null;
        
        // Skin type: false = classic (4px arms), true = slim (2px arms)
        let isSlimSkin = false;
        
        // Body (8x12x4 pixels in Minecraft scaled up)
        const bodyGeometry = new THREE.BoxGeometry(0.5 * modelScale, 0.75 * modelScale, 0.25 * modelScale);
        const bodyMaterial = new THREE.MeshLambertMaterial({ 
            color: 0x3a7bc8,
            emissive: 0x1a3a5a,
            emissiveIntensity: 0.2
        }); // Enhanced blue shirt with subtle glow
        const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
        bodyMesh.position.set(0, -0.5 * modelScale, 0);
        bodyMesh.castShadow = true;
        bodyMesh.receiveShadow = true;
        bodyMesh.renderOrder = 0; // Base layer
        playerModelGroup.add(bodyMesh);
        
        // Head (8x8x8 pixels scaled up)
        const headGeometry = new THREE.BoxGeometry(0.5 * modelScale, 0.5 * modelScale, 0.5 * modelScale);
        const headMaterial = new THREE.MeshLambertMaterial({ 
            color: 0xf4c49a,
            emissive: 0x8b6f47,
            emissiveIntensity: 0.1
        }); // Enhanced skin tone with warmth
        const headMesh = new THREE.Mesh(headGeometry, headMaterial);
        headMesh.position.set(0, 0.125 * modelScale, 0);
        headMesh.castShadow = true;
        headMesh.receiveShadow = true;
        headMesh.renderOrder = 0; // Base layer
        playerModelGroup.add(headMesh);
        
        // Legs (4x12x4 pixels each scaled up) - Standard Minecraft proportions
        const legGeometry = new THREE.BoxGeometry(0.25 * modelScale, 0.75 * modelScale, 0.25 * modelScale);
        const legMaterial = new THREE.MeshLambertMaterial({ 
            color: 0x2d3e6f,
            emissive: 0x0f1a2e,
            emissiveIntensity: 0.15
        }); // Enhanced blue pants with depth
        
        // LEFT LEG: 4px wide, attached at left side of 8px wide body
        // Body spans x: -0.25 to +0.25 (8px = 0.5 units)
        // Left leg spans x: -0.25 to 0 (4px = 0.25 units, left half of body width)
        const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
        leftLeg.position.set(0, -0.375 * modelScale, 0); // Leg hangs down from pivot point
        leftLeg.castShadow = true;
        leftLeg.receiveShadow = true;
        leftLeg.renderOrder = 0; // Base layer
        const leftLegPivot = new THREE.Group();
        // Pivot at top-center of left leg (which is bottom-left quarter of body)
        leftLegPivot.position.set(-0.125 * modelScale, -0.875 * modelScale, 0);
        leftLegPivot.add(leftLeg);
        playerModelGroup.add(leftLegPivot);
        
        // RIGHT LEG: 4px wide, attached at right side of 8px wide body
        // Right leg spans x: 0 to +0.25 (4px = 0.25 units, right half of body width)
        const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
        rightLeg.position.set(0, -0.375 * modelScale, 0); // Leg hangs down from pivot point
        rightLeg.castShadow = true;
        rightLeg.receiveShadow = true;
        rightLeg.renderOrder = 0; // Base layer
        const rightLegPivot = new THREE.Group();
        // Pivot at top-center of right leg (which is bottom-right quarter of body)
        rightLegPivot.position.set(0.125 * modelScale, -0.875 * modelScale, 0);
        rightLegPivot.add(rightLeg);
        playerModelGroup.add(rightLegPivot);
        
        // ARMS - created dynamically based on slim skin setting
        let leftArm = null;
        let rightArm = null;
        let leftArmPivot = null;
        let rightArmPivot = null;
        
        // Function to create or recreate arms based on skin type
        function createArms() {
            // Store old materials to preserve textures
            const oldLeftArmMaterial = leftArm ? leftArm.material : null;
            const oldRightArmMaterial = rightArm ? rightArm.material : null;
            const oldLeftArmLayerMaterial = leftArmLayerMesh ? leftArmLayerMesh.material : null;
            const oldRightArmLayerMaterial = rightArmLayerMesh ? rightArmLayerMesh.material : null;
            
            // Remove old arms if they exist
            if (leftArmPivot) {
                playerModelGroup.remove(leftArmPivot);
                if (leftArm) {
                    leftArm.geometry.dispose();
                    // Don't dispose materials - we're reusing them
                }
                if (leftArmLayerMesh) {
                    leftArmPivot.remove(leftArmLayerMesh);
                    leftArmLayerMesh.geometry.dispose();
                    // Don't dispose materials - we're reusing them
                    leftArmLayerMesh = null;
                }
            }
            if (rightArmPivot) {
                playerModelGroup.remove(rightArmPivot);
                if (rightArm) {
                    rightArm.geometry.dispose();
                    // Don't dispose materials - we're reusing them
                }
                if (rightArmLayerMesh) {
                    rightArmPivot.remove(rightArmLayerMesh);
                    rightArmLayerMesh.geometry.dispose();
                    // Don't dispose materials - we're reusing them
                    rightArmLayerMesh = null;
                }
            }
            
            // Create new arms with proper dimensions matching Minecraft skin layout
            // Classic: 4px wide (0.25 units), Slim: 3px wide (0.1875 units)
            const armWidth = isSlimSkin ? 0.1875 * modelScale : 0.25 * modelScale;
            const armGeometry = new THREE.BoxGeometry(armWidth, 0.75 * modelScale, 0.25 * modelScale);
            
            // Use old materials if available, otherwise create new default material
            const armMaterial = oldLeftArmMaterial || new THREE.MeshLambertMaterial({ 
                color: 0xf4c49a,
                emissive: 0x8b6f47,
                emissiveIntensity: 0.1
            });
            
            // LEFT ARM: Attached to left side of body at shoulder (top of body)
            // Body: 8px wide (0.5 units), spans x: -0.25 to +0.25
            // Left arm attaches at x: -0.25 (left edge of body)
            leftArm = new THREE.Mesh(armGeometry, oldLeftArmMaterial || armMaterial);
            leftArm.position.set(0, -0.375 * modelScale, 0); // Arm hangs down from pivot (shoulder)
            leftArm.castShadow = true;
            leftArm.receiveShadow = true;
            leftArm.renderOrder = 0; // Base layer
            leftArmPivot = new THREE.Group();
            // Calculate positioning: body edge (-0.25) minus arm half-width
            const bodyHalfWidth = 0.25 * modelScale; // Half of 8px body width
            const armHalfWidth = armWidth / 2; // Half of arm width (2px for classic, 1.5px for slim)
            // Pivot at shoulder (top of body side, center of arm width)
            leftArmPivot.position.set(-(bodyHalfWidth + armHalfWidth), -0.125 * modelScale, 0);
            leftArmPivot.add(leftArm);
            playerModelGroup.add(leftArmPivot);
            
            // RIGHT ARM: Attached to right side of body at shoulder (top of body)
            // Right arm attaches at x: +0.25 (right edge of body)
            rightArm = new THREE.Mesh(armGeometry, oldRightArmMaterial || armMaterial);
            rightArm.position.set(0, -0.375 * modelScale, 0); // Arm hangs down from pivot (shoulder)
            rightArm.castShadow = true;
            rightArm.receiveShadow = true;
            rightArm.renderOrder = 0; // Base layer
            rightArmPivot = new THREE.Group();
            // Pivot at shoulder (top of body side, center of arm width)
            rightArmPivot.position.set(bodyHalfWidth + armHalfWidth, -0.125 * modelScale, 0);
            rightArmPivot.add(rightArm);
            playerModelGroup.add(rightArmPivot);
            
            // Recreate arm layers after arms are recreated
            if (typeof createBodyLayers === 'function') {
                createBodyLayers();
            }
        }
        
        // Function to create or recreate all body part layers
        function createBodyLayers() {
            // Helper to create fully transparent default materials (layers invisible until textures applied)
            const createDefaultLayerMaterial = () => {
                return new THREE.MeshLambertMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0, // Completely invisible by default
                    visible: false // Hidden until texture is applied
                });
            };
            
            // HEAD LAYER (hat) - 3D offset with proper spacing
            if (headLayerMesh) {
                playerModelGroup.remove(headLayerMesh);
                headLayerMesh.geometry.dispose();
                if (Array.isArray(headLayerMesh.material)) {
                    headLayerMesh.material.forEach(m => m.dispose());
                } else {
                    headLayerMesh.material.dispose();
                }
            }
            // Layer is 0.5px larger on each side (1px total larger), making it 9x9x9 vs 8x8x8 base
            const headLayerGeometry = new THREE.BoxGeometry(0.5625 * modelScale, 0.5625 * modelScale, 0.5625 * modelScale);
            headLayerMesh = new THREE.Mesh(headLayerGeometry, createDefaultLayerMaterial());
            headLayerMesh.position.copy(headMesh.position);
            headLayerMesh.visible = false; // Invisible until texture is applied
            headLayerMesh.renderOrder = 1; // Render on top of base layer
            playerModelGroup.add(headLayerMesh);
            
            // BODY LAYER (jacket) - 3D offset with proper spacing
            if (bodyLayerMesh) {
                playerModelGroup.remove(bodyLayerMesh);
                bodyLayerMesh.geometry.dispose();
                if (Array.isArray(bodyLayerMesh.material)) {
                    bodyLayerMesh.material.forEach(m => m.dispose());
                } else {
                    bodyLayerMesh.material.dispose();
                }
            }
            // Body: 8x12x4 base, layer adds 0.5px on each side
            const bodyLayerGeometry = new THREE.BoxGeometry(0.5625 * modelScale, 0.8125 * modelScale, 0.3125 * modelScale);
            bodyLayerMesh = new THREE.Mesh(bodyLayerGeometry, createDefaultLayerMaterial());
            bodyLayerMesh.position.copy(bodyMesh.position);
            bodyLayerMesh.visible = false; // Invisible until texture is applied
            bodyLayerMesh.renderOrder = 1; // Render on top of base layer
            playerModelGroup.add(bodyLayerMesh);
            
            // ARM LAYERS (sleeves) - 3D offset with proper spacing
            if (leftArmPivot && leftArm) {
                if (leftArmLayerMesh) {
                    leftArmPivot.remove(leftArmLayerMesh);
                    leftArmLayerMesh.geometry.dispose();
                    if (Array.isArray(leftArmLayerMesh.material)) {
                        leftArmLayerMesh.material.forEach(m => m.dispose());
                    } else {
                        leftArmLayerMesh.material.dispose();
                    }
                }
                // Arm layers: add 0.5px on each side
                // Classic: 4px arm becomes 5px layer, Slim: 3px arm becomes 4px layer
                const leftArmLayerWidth = isSlimSkin ? 0.25 * modelScale : 0.3125 * modelScale;
                const leftArmLayerGeometry = new THREE.BoxGeometry(leftArmLayerWidth, 0.8125 * modelScale, 0.3125 * modelScale);
                leftArmLayerMesh = new THREE.Mesh(leftArmLayerGeometry, createDefaultLayerMaterial());
                leftArmLayerMesh.position.copy(leftArm.position);
                leftArmLayerMesh.visible = false; // Invisible until texture is applied
                leftArmLayerMesh.renderOrder = 1; // Render on top of base layer
                leftArmPivot.add(leftArmLayerMesh);
            }
            
            if (rightArmPivot && rightArm) {
                if (rightArmLayerMesh) {
                    rightArmPivot.remove(rightArmLayerMesh);
                    rightArmLayerMesh.geometry.dispose();
                    if (Array.isArray(rightArmLayerMesh.material)) {
                        rightArmLayerMesh.material.forEach(m => m.dispose());
                    } else {
                        rightArmLayerMesh.material.dispose();
                    }
                }
                const rightArmLayerWidth = isSlimSkin ? 0.25 * modelScale : 0.3125 * modelScale;
                const rightArmLayerGeometry = new THREE.BoxGeometry(rightArmLayerWidth, 0.8125 * modelScale, 0.3125 * modelScale);
                rightArmLayerMesh = new THREE.Mesh(rightArmLayerGeometry, createDefaultLayerMaterial());
                rightArmLayerMesh.position.copy(rightArm.position);
                rightArmLayerMesh.visible = false; // Invisible until texture is applied
                rightArmLayerMesh.renderOrder = 1; // Render on top of base layer
                rightArmPivot.add(rightArmLayerMesh);
            }
            
            // LEG LAYERS (pants) - 3D offset with proper spacing
            if (leftLegLayerMesh) {
                leftLegPivot.remove(leftLegLayerMesh);
                leftLegLayerMesh.geometry.dispose();
                if (Array.isArray(leftLegLayerMesh.material)) {
                    leftLegLayerMesh.material.forEach(m => m.dispose());
                } else {
                    leftLegLayerMesh.material.dispose();
                }
            }
            // Leg: 4x12x4 base becomes 5x13x5 layer (0.5px added on each side)
            const leftLegLayerGeometry = new THREE.BoxGeometry(0.3125 * modelScale, 0.8125 * modelScale, 0.3125 * modelScale);
            leftLegLayerMesh = new THREE.Mesh(leftLegLayerGeometry, createDefaultLayerMaterial());
            leftLegLayerMesh.position.copy(leftLeg.position);
            leftLegLayerMesh.visible = false; // Invisible until texture is applied
            leftLegLayerMesh.renderOrder = 1; // Render on top of base layer
            leftLegPivot.add(leftLegLayerMesh);
            
            if (rightLegLayerMesh) {
                rightLegPivot.remove(rightLegLayerMesh);
                rightLegLayerMesh.geometry.dispose();
                if (Array.isArray(rightLegLayerMesh.material)) {
                    rightLegLayerMesh.material.forEach(m => m.dispose());
                } else {
                    rightLegLayerMesh.material.dispose();
                }
            }
            const rightLegLayerGeometry = new THREE.BoxGeometry(0.3125 * modelScale, 0.8125 * modelScale, 0.3125 * modelScale);
            rightLegLayerMesh = new THREE.Mesh(rightLegLayerGeometry, createDefaultLayerMaterial());
            rightLegLayerMesh.position.copy(rightLeg.position);
            rightLegLayerMesh.visible = false; // Invisible until texture is applied
            rightLegLayerMesh.renderOrder = 1; // Render on top of base layer
            rightLegPivot.add(rightLegLayerMesh);
        }
        
        // Initial arm creation
        createArms();
        
        // Create all body layers initially
        createBodyLayers();
        
        // Function to update skin layer visibility
        function updateSkinLayers() {
            if (headLayerMesh) headLayerMesh.visible = showSkinLayers;
            if (bodyLayerMesh) bodyLayerMesh.visible = showSkinLayers;
            if (leftArmLayerMesh) leftArmLayerMesh.visible = showSkinLayers;
            if (rightArmLayerMesh) rightArmLayerMesh.visible = showSkinLayers;
            if (leftLegLayerMesh) leftLegLayerMesh.visible = showSkinLayers;
            if (rightLegLayerMesh) rightLegLayerMesh.visible = showSkinLayers;
            if (fpHandLayerMesh) fpHandLayerMesh.visible = showSkinLayers;
        }
        
        playerModelGroup.visible = false; // Hidden by default (first person)
        playerModelGroup.castShadow = true;
        playerModelGroup.receiveShadow = true;
        scene.add(playerModelGroup);
        
        // Load and apply custom textures if available
        setTimeout(() => {
            try {
                // Always initialize textures first (creates defaults if none exist)
                if (Object.keys(modelTextures).length === 0) {
                    initializeModelTextures();
                }
                // Load saved textures (will merge with defaults)
                loadModelTextures();
                // Apply textures to all models including hand
                applyTexturesToModels();
            } catch (e) {
                console.error('Error initializing textures:', e);
            }
        }, 100);
        // --- END PERSPECTIVE SYSTEM ---
        
        // --- HELD ITEM IN HAND SYSTEM ---
        // Create a separate scene and camera for the held item (overlay rendering)
        const handScene = new THREE.Scene();
        const handCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 10);
        
        // Hand position and animation variables
        let heldItemMesh = null;
        let fpHandMesh = null; // Permanent first-person hand mesh
        let fpHandLayerMesh = null; // Second layer (sleeve) for hand
        let handBobTimer = 0;
        let isMovingForBob = false;
        let handSwingTimer = 0;
        let isSwinging = false;
        const SWING_DURATION = 0.25; // Duration of swing animation in seconds
        
        // Minecraft Skin System - Extract texture regions from 64x64 skin
        function extractSkinRegion(skinCanvas, x, y, width, height, flipVertical = false) {
            const regionCanvas = document.createElement('canvas');
            regionCanvas.width = width;
            regionCanvas.height = height;
            const ctx = regionCanvas.getContext('2d');
            
            if (flipVertical) {
                // Flip the texture upside down (180 degree rotation)
                ctx.save();
                ctx.translate(width / 2, height / 2);
                ctx.rotate(Math.PI); // 180 degrees
                ctx.drawImage(skinCanvas, x, y, width, height, -width / 2, -height / 2, width, height);
                ctx.restore();
            } else {
                ctx.drawImage(skinCanvas, x, y, width, height, 0, 0, width, height);
            }
            
            return regionCanvas;
        }
        
        // Create UV-mapped materials for a body part from skin texture
        function createBodyPartMaterials(skinCanvas, uvMap, isLayer = false, flipVertical = false) {
            // uvMap format: { right, left, top, bottom, front, back }
            // Each entry has { x, y, w, h } coordinates in the skin texture
            const materials = [];
            const faces = ['right', 'left', 'top', 'bottom', 'front', 'back'];
            
            faces.forEach(face => {
                const uv = uvMap[face];
                const faceCanvas = extractSkinRegion(skinCanvas, uv.x, uv.y, uv.w, uv.h, flipVertical);
                const texture = new THREE.CanvasTexture(faceCanvas);
                texture.magFilter = THREE.NearestFilter;
                texture.minFilter = THREE.NearestFilter;
                materials.push(new THREE.MeshLambertMaterial({ 
                    map: texture,
                    transparent: isLayer,
                    alphaTest: isLayer ? 0.1 : 0,
                    depthWrite: !isLayer
                }));
            });
            
            return materials;
        }
        
        // Function to get arm UV maps based on skin type - EXACT Minecraft 64x64 skin format
        // Based on official Minecraft skin schematic
        function getArmUVMaps() {
            if (isSlimSkin) {
                // Slim arms: 3px wide (Alex model)
                // Right arm base: front at (44,20), layer at (44,36)
                // Left arm base: front at (36,52), layer at (52,52)
                return {
                    rightArm: {
                        right: { x: 47, y: 20, w: 3, h: 12 },  // Right side (viewer's left)
                        left: { x: 44, y: 20, w: 3, h: 12 },   // Left side (viewer's right)
                        top: { x: 44, y: 16, w: 3, h: 4 },
                        bottom: { x: 47, y: 16, w: 3, h: 4 },
                        front: { x: 44, y: 20, w: 3, h: 12 },
                        back: { x: 50, y: 20, w: 3, h: 12 }
                    },
                    rightArmLayer: {
                        right: { x: 47, y: 36, w: 3, h: 12 },
                        left: { x: 44, y: 36, w: 3, h: 12 },
                        top: { x: 44, y: 32, w: 3, h: 4 },
                        bottom: { x: 47, y: 32, w: 3, h: 4 },
                        front: { x: 44, y: 36, w: 3, h: 12 },
                        back: { x: 50, y: 36, w: 3, h: 12 }
                    },
                    leftArm: {
                        right: { x: 39, y: 52, w: 3, h: 12 },  // Right side (viewer's left)
                        left: { x: 36, y: 52, w: 3, h: 12 },   // Left side (viewer's right)
                        top: { x: 36, y: 48, w: 3, h: 4 },
                        bottom: { x: 39, y: 48, w: 3, h: 4 },
                        front: { x: 36, y: 52, w: 3, h: 12 },
                        back: { x: 42, y: 52, w: 3, h: 12 }
                    },
                    leftArmLayer: {
                        right: { x: 55, y: 52, w: 3, h: 12 },
                        left: { x: 52, y: 52, w: 3, h: 12 },
                        top: { x: 52, y: 48, w: 3, h: 4 },
                        bottom: { x: 55, y: 48, w: 3, h: 4 },
                        front: { x: 52, y: 52, w: 3, h: 12 },
                        back: { x: 58, y: 52, w: 3, h: 12 }
                    }
                };
            } else {
                // Classic arms: 4px wide (Steve model) - EXACT Minecraft 64x64 coordinates
                // Right arm: front at (44,20), right at (48,20), left at (40,20), back at (52,20)
                // Left arm: front at (36,52), right at (40,52), left at (32,52), back at (44,52)
                // Layers offset by +32 on X axis
                return {
                    rightArm: {
                        right: { x: 48, y: 20, w: 4, h: 12 },  // Right side of right arm (viewer's left)
                        left: { x: 40, y: 20, w: 4, h: 12 },   // Left side of right arm (viewer's right)
                        top: { x: 44, y: 16, w: 4, h: 4 },
                        bottom: { x: 48, y: 16, w: 4, h: 4 },
                        front: { x: 44, y: 20, w: 4, h: 12 },
                        back: { x: 52, y: 20, w: 4, h: 12 }
                    },
                    rightArmLayer: {
                        right: { x: 48, y: 36, w: 4, h: 12 },  // Layer offset +16 on Y axis
                        left: { x: 40, y: 36, w: 4, h: 12 },
                        top: { x: 44, y: 32, w: 4, h: 4 },
                        bottom: { x: 48, y: 32, w: 4, h: 4 },
                        front: { x: 44, y: 36, w: 4, h: 12 },
                        back: { x: 52, y: 36, w: 4, h: 12 }
                    },
                    leftArm: {
                        right: { x: 40, y: 52, w: 4, h: 12 },  // Right side of left arm (viewer's left)
                        left: { x: 32, y: 52, w: 4, h: 12 },   // Left side of left arm (viewer's right)
                        top: { x: 36, y: 48, w: 4, h: 4 },
                        bottom: { x: 40, y: 48, w: 4, h: 4 },
                        front: { x: 36, y: 52, w: 4, h: 12 },
                        back: { x: 44, y: 52, w: 4, h: 12 }
                    },
                    leftArmLayer: {
                        right: { x: 56, y: 52, w: 4, h: 12 },  // Layer offset +32 on X axis (48+8=56)
                        left: { x: 48, y: 52, w: 4, h: 12 },
                        top: { x: 52, y: 48, w: 4, h: 4 },
                        bottom: { x: 56, y: 48, w: 4, h: 4 },
                        front: { x: 52, y: 52, w: 4, h: 12 },
                        back: { x: 60, y: 52, w: 4, h: 12 }
                    }
                };
            }
        }
        
        const armUVs = getArmUVMaps();
        
        // Complete UV mappings for all body parts - EXACT Minecraft 64x64 skin format
        // Based on official Minecraft skin schematic
        // Three.js BoxGeometry face order: [right, left, top, bottom, front, back]
        // Minecraft texture mapping: right side of model = left side of texture (when viewing front)
        const skinUVMaps = {
            // HEAD: 8x8 pixels, front at (8,8) in 64x64 texture
            head: {
                right: { x: 0, y: 8, w: 8, h: 8 },    // Right side of head (left in texture)
                left: { x: 16, y: 8, w: 8, h: 8 },    // Left side of head (right in texture)
                top: { x: 8, y: 0, w: 8, h: 8 },
                bottom: { x: 16, y: 0, w: 8, h: 8 },
                front: { x: 8, y: 8, w: 8, h: 8 },
                back: { x: 24, y: 8, w: 8, h: 8 }
            },
            // HEAD LAYER (HAT): 8x8 pixels, offset +32 on X axis
            headLayer: {
                right: { x: 32, y: 8, w: 8, h: 8 },
                left: { x: 48, y: 8, w: 8, h: 8 },
                top: { x: 40, y: 0, w: 8, h: 8 },
                bottom: { x: 48, y: 0, w: 8, h: 8 },
                front: { x: 40, y: 8, w: 8, h: 8 },
                back: { x: 56, y: 8, w: 8, h: 8 }
            },
            // BODY (TORSO): 8x12 pixels, front at (20,20)
            body: {
                right: { x: 16, y: 20, w: 4, h: 12 },  // Right side of body (left in texture)
                left: { x: 28, y: 20, w: 4, h: 12 },   // Left side of body (right in texture)
                top: { x: 20, y: 16, w: 8, h: 4 },
                bottom: { x: 28, y: 16, w: 8, h: 4 },
                front: { x: 20, y: 20, w: 8, h: 12 },
                back: { x: 32, y: 20, w: 8, h: 12 }
            },
            // BODY LAYER (JACKET): 8x12 pixels, offset +16 on Y axis
            bodyLayer: {
                right: { x: 16, y: 36, w: 4, h: 12 },
                left: { x: 28, y: 36, w: 4, h: 12 },
                top: { x: 20, y: 32, w: 8, h: 4 },
                bottom: { x: 28, y: 32, w: 8, h: 4 },
                front: { x: 20, y: 36, w: 8, h: 12 },
                back: { x: 32, y: 36, w: 8, h: 12 }
            },
            rightArm: armUVs.rightArm,
            rightArmLayer: armUVs.rightArmLayer,
            leftArm: armUVs.leftArm,
            leftArmLayer: armUVs.leftArmLayer,
            // RIGHT LEG: 4x12 pixels, front at (4,20)
            rightLeg: {
                right: { x: 0, y: 20, w: 4, h: 12 },   // Right side of right leg
                left: { x: 8, y: 20, w: 4, h: 12 },   // Left side of right leg
                top: { x: 4, y: 16, w: 4, h: 4 },
                bottom: { x: 8, y: 16, w: 4, h: 4 },
                front: { x: 4, y: 20, w: 4, h: 12 },
                back: { x: 12, y: 20, w: 4, h: 12 }
            },
            // RIGHT LEG LAYER (PANTS): 4x12 pixels, offset +16 on Y axis
            rightLegLayer: {
                right: { x: 0, y: 36, w: 4, h: 12 },
                left: { x: 8, y: 36, w: 4, h: 12 },
                top: { x: 4, y: 32, w: 4, h: 4 },
                bottom: { x: 8, y: 32, w: 4, h: 4 },
                front: { x: 4, y: 36, w: 4, h: 12 },
                back: { x: 12, y: 36, w: 4, h: 12 }
            },
            // LEFT LEG: 4x12 pixels, front at (20,52)
            leftLeg: {
                right: { x: 16, y: 52, w: 4, h: 12 },  // Right side of left leg
                left: { x: 24, y: 52, w: 4, h: 12 },   // Left side of left leg
                top: { x: 20, y: 48, w: 4, h: 4 },
                bottom: { x: 24, y: 48, w: 4, h: 4 },
                front: { x: 20, y: 52, w: 4, h: 12 },
                back: { x: 28, y: 52, w: 4, h: 12 }
            },
            // LEFT LEG LAYER (PANTS): 4x12 pixels, offset +32 on X axis (moves to left side)
            leftLegLayer: {
                right: { x: 0, y: 52, w: 4, h: 12 },
                left: { x: 8, y: 52, w: 4, h: 12 },
                top: { x: 4, y: 48, w: 4, h: 4 },
                bottom: { x: 8, y: 48, w: 4, h: 4 },
                front: { x: 4, y: 52, w: 4, h: 12 },
                back: { x: 12, y: 52, w: 4, h: 12 }
            }
        };
        
        // Create held item mesh based on type
        // Create a Minecraft character right hand with customizable skin texture and layers
        function createHandMesh() {
            const group = new THREE.Group();
            
            // Minecraft character's right arm proportions - slim: 3x12x4 pixels, classic: 4x12x4 pixels
            const handWidth = isSlimSkin ? 0.06 : 0.08; // 3px or 4px
            const handGeometry = new THREE.BoxGeometry(handWidth, 0.24, 0.08);
            
            let materials;
            let layerMaterials;
            
            if (customSkinTexture && customSkinTexture.data) {
                // Create canvas from stored skin data
                const skinCanvas = document.createElement('canvas');
                skinCanvas.width = customSkinTexture.width;
                skinCanvas.height = customSkinTexture.height;
                const ctx = skinCanvas.getContext('2d');
                const imageData = ctx.createImageData(skinCanvas.width, skinCanvas.height);
                
                for (let i = 0; i < customSkinTexture.data.length; i++) {
                    imageData.data[i] = customSkinTexture.data[i];
                }
                ctx.putImageData(imageData, 0, 0);
                
                // Create materials for first layer (base skin) using proper UV maps - NOT flipped for first-person view
                materials = createBodyPartMaterials(skinCanvas, skinUVMaps.rightArm, false, false);
                
                // Create materials for second layer (sleeve) using proper UV maps - NOT flipped for first-person view
                layerMaterials = createBodyPartMaterials(skinCanvas, skinUVMaps.rightArmLayer, true, false);
            } else if (customHandTexture) {
                // Fallback to old texture system
                const canvas = document.createElement('canvas');
                canvas.width = 16;
                canvas.height = 16;
                const ctx = canvas.getContext('2d');
                const imageData = ctx.createImageData(16, 16);
                
                for (let i = 0; i < customHandTexture.length; i++) {
                    imageData.data[i] = customHandTexture[i];
                }
                ctx.putImageData(imageData, 0, 0);
                
                const createFaceCanvas = (sx, sy, sw, sh) => {
                    const faceCanvas = document.createElement('canvas');
                    faceCanvas.width = sw;
                    faceCanvas.height = sh;
                    const faceCtx = faceCanvas.getContext('2d');
                    faceCtx.drawImage(canvas, sx, sy, sw, sh, 0, 0, sw, sh);
                    return faceCanvas;
                };
                
                materials = [
                    new THREE.MeshLambertMaterial({ map: new THREE.CanvasTexture(createFaceCanvas(0, 0, 4, 12)) }),
                    new THREE.MeshLambertMaterial({ map: new THREE.CanvasTexture(createFaceCanvas(8, 0, 4, 12)) }),
                    new THREE.MeshLambertMaterial({ map: new THREE.CanvasTexture(createFaceCanvas(4, 12, 4, 4)) }),
                    new THREE.MeshLambertMaterial({ map: new THREE.CanvasTexture(createFaceCanvas(8, 12, 4, 4)) }),
                    new THREE.MeshLambertMaterial({ map: new THREE.CanvasTexture(createFaceCanvas(4, 0, 4, 12)) }),
                    new THREE.MeshLambertMaterial({ map: new THREE.CanvasTexture(createFaceCanvas(12, 0, 4, 12)) })
                ];
                
                materials.forEach(mat => {
                    if (mat.map) {
                        mat.map.magFilter = THREE.NearestFilter;
                        mat.map.minFilter = THREE.NearestFilter;
                    }
                });
            } else {
                // Default Steve's skin tone
                const defaultMaterial = new THREE.MeshLambertMaterial({ color: 0xd4a574 });
                materials = [defaultMaterial, defaultMaterial, defaultMaterial, defaultMaterial, defaultMaterial, defaultMaterial];
            }
            
            // Create base hand mesh
            const handMesh = new THREE.Mesh(handGeometry, materials);
            handMesh.castShadow = false;
            handMesh.receiveShadow = false;
            handMesh.renderOrder = 0; // Base layer
            group.add(handMesh);
            
            // Create second layer (sleeve) - 3D SKIN LAYERS MOD STYLE with actual depth
            if (layerMaterials) {
                // Hand: base is 4px or 3px (slim), layer adds MORE depth like 3D Skin Layers mod
                const layerWidth = isSlimSkin ? 0.075 : 0.095; // Much thicker for 3D effect
                const layerHeight = 0.265; // Taller than base
                const layerDepth = 0.095; // Deeper than base
                const layerGeometry = new THREE.BoxGeometry(layerWidth, layerHeight, layerDepth);
                fpHandLayerMesh = new THREE.Mesh(layerGeometry, layerMaterials);
                fpHandLayerMesh.castShadow = false;
                fpHandLayerMesh.receiveShadow = false;
                fpHandLayerMesh.visible = showSkinLayers;
                fpHandLayerMesh.renderOrder = 1; // Render on top of base layer
                
                // Offset the layer slightly for 3D depth effect (like 3D Skin Layers mod)
                fpHandLayerMesh.position.set(0, 0, 0.008); // Push layer out slightly
                
                group.add(fpHandLayerMesh);
            }
            
            return group;
        }
        
        function createHeldItemMesh(itemType) {
            if (itemType === null || itemType === undefined) return null;
            
            let geometry, material;
            
            // Check if it's a tool (negative number)
            if (itemType < 0) {
                const itemDef = itemDefinitions[itemType];
                if (!itemDef) return null;
                
                // Create tool representation
                if (itemDef.isPickaxe || itemDef.isAxe) {
                    // Tool head (small cube)
                    const headGeometry = new THREE.BoxGeometry(0.15, 0.1, 0.05);
                    const headMaterial = new THREE.MeshLambertMaterial({ 
                        color: itemDef.isPickaxe ? 0x7a7a7a : 0x8b5a2b 
                    });
                    const head = new THREE.Mesh(headGeometry, headMaterial);
                    head.position.set(0, 0.12, 0);
                    
                    // Handle (stick)
                    const handleGeometry = new THREE.BoxGeometry(0.03, 0.25, 0.03);
                    const handleMaterial = new THREE.MeshLambertMaterial({ color: 0x8b5a2b });
                    const handle = new THREE.Mesh(handleGeometry, handleMaterial);
                    handle.position.set(0, -0.05, 0);
                    
                    const tool = new THREE.Group();
                    tool.add(head);
                    tool.add(handle);
                    return tool;
                    
                } else if (itemDef.isSword) {
                    // Blade
                    const bladeGeometry = new THREE.BoxGeometry(0.05, 0.3, 0.02);
                    const bladeMaterial = new THREE.MeshLambertMaterial({ 
                        color: itemType === ITEM_STONE_SWORD ? 0x7a7a7a : 0x8b5a2b 
                    });
                    const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
                    blade.position.set(0, 0.1, 0);
                    
                    // Handle
                    const handleGeometry = new THREE.BoxGeometry(0.03, 0.1, 0.03);
                    const handleMaterial = new THREE.MeshLambertMaterial({ color: 0x8b5a2b });
                    const handle = new THREE.Mesh(handleGeometry, handleMaterial);
                    handle.position.set(0, -0.1, 0);
                    
                    // Guard
                    const guardGeometry = new THREE.BoxGeometry(0.15, 0.02, 0.03);
                    const guardMaterial = new THREE.MeshLambertMaterial({ color: 0x4a4a4a });
                    const guard = new THREE.Mesh(guardGeometry, guardMaterial);
                    guard.position.set(0, -0.05, 0);
                    
                    const sword = new THREE.Group();
                    sword.add(blade);
                    sword.add(handle);
                    sword.add(guard);
                    return sword;
                    
                } else if (itemDef.isStick) {
                    // Simple stick
                    geometry = new THREE.BoxGeometry(0.03, 0.25, 0.03);
                    material = new THREE.MeshLambertMaterial({ color: 0x8b5a2b });
                    return new THREE.Mesh(geometry, material);
                } else if (itemDef.isPlaceable) {
                    // Planks or other placeable items - render as small block with proper texture
                    geometry = new THREE.BoxGeometry(0.15, 0.15, 0.15);
                    
                    // Use the actual planks material if available (mats[12] is PLANKS_TYPE)
                    if (itemType === ITEM_PLANKS && mats[PLANKS_TYPE]) {
                        material = mats[PLANKS_TYPE].clone();
                    } else {
                        material = new THREE.MeshLambertMaterial({ 
                            color: itemDef.color ? parseInt(itemDef.color.replace('#', '0x')) : 0xdaa560 
                        });
                    }
                    
                    return new THREE.Mesh(geometry, material);
                }
            }
            
            // It's a block - use existing material or create cube
            if (itemType >= 0 && itemType < mats.length && mats[itemType]) {
                geometry = new THREE.BoxGeometry(0.15, 0.15, 0.15);
                
                // Handle array materials (like grass blocks) or single materials
                if (Array.isArray(mats[itemType])) {
                    // Clone each material in the array
                    material = mats[itemType].map(mat => mat.clone());
                } else {
                    material = mats[itemType].clone();
                }
                
                const block = new THREE.Mesh(geometry, material);
                return block;
            }
            
            return null;
        }
        
        // Update held item info display
        function updateHeldItemInfo() {
            const heldItemInfoDiv = document.getElementById('held-item-info');
            const hudIndex = getHUDIndex(sel);
            const item = inventoryData[hudIndex];
            
            if (!item || inventoryOpen || paused || isDead) {
                heldItemInfoDiv.style.display = 'none';
                return;
            }
            
            const display = getBlockDisplay(item.type);
            const itemNameEl = heldItemInfoDiv.querySelector('.item-name');
            const itemCountEl = heldItemInfoDiv.querySelector('.item-count');
            const durabilityBarContainer = heldItemInfoDiv.querySelector('.durability-bar-container');
            const durabilityBar = heldItemInfoDiv.querySelector('.durability-bar');
            const durabilityText = heldItemInfoDiv.querySelector('.durability-text');
            
            itemNameEl.textContent = display.name;
            itemNameEl.style.color = display.color;
            
            // Check if it's a tool with durability
            const isTool = item.type < 0 && itemDefinitions[item.type] && itemDefinitions[item.type].isTool;
            
            if (isTool && !isCreativeMode) {
                // Hide count for tools
                itemCountEl.style.display = 'none';
                
                // Show durability bar
                const itemDef = itemDefinitions[item.type];
                const currentDurability = item.durability !== undefined ? item.durability : itemDef.maxDurability;
                const maxDurability = itemDef.maxDurability;
                const durabilityPercent = (currentDurability / maxDurability) * 100;
                
                durabilityBarContainer.style.display = 'block';
                durabilityBar.style.width = durabilityPercent + '%';
                
                // Color based on durability level
                durabilityBar.classList.remove('high', 'medium', 'low');
                if (durabilityPercent > 50) {
                    durabilityBar.classList.add('high');
                } else if (durabilityPercent > 25) {
                    durabilityBar.classList.add('medium');
                } else {
                    durabilityBar.classList.add('low');
                }
                
                durabilityText.textContent = `${currentDurability} / ${maxDurability}`;
                durabilityText.style.display = 'block';
            } else {
                // Show count for regular items
                itemCountEl.style.display = 'block';
                if (isCreativeMode) {
                    itemCountEl.textContent = '';
                } else {
                    itemCountEl.textContent = `x${item.count}`;
                }
                durabilityBarContainer.style.display = 'none';
                durabilityText.style.display = 'none';
            }
            
            heldItemInfoDiv.style.display = 'block';
        }
        
        // Update held item
        function updateHeldItem() {
            // Remove old item (but keep hand)
            if (heldItemMesh) {
                handScene.remove(heldItemMesh);
                heldItemMesh = null;
            }
            
            // Get current item
            const hudIndex = getHUDIndex(sel);
            const item = inventoryData[hudIndex];
            
            // Initialize permanent hand if not exists
            if (!fpHandMesh) {
                fpHandMesh = createHandMesh();
                if (fpHandMesh) {
                    // Make hand bigger and move to bottom-right corner
                    fpHandMesh.scale.set(1.5, 1.5, 1.5); // 1.5x bigger
                    fpHandMesh.userData.basePosition = { x: 0.4, y: -0.3, z: -0.5 }; 
                    fpHandMesh.userData.baseRotation = { x: -0.15, y: -1.05, z: 3.2 }; 
                    fpHandMesh.position.set(0.4, -0.35, -0.5);
                    fpHandMesh.rotation.set(0.15, -0.2, 0.0);
                    handScene.add(fpHandMesh);
                    // Apply textures after creating (safely)
                    try {
                        if (modelTextures && Object.keys(modelTextures).length > 0) {
                            applyTexturesToModels();
                        }
                    } catch (e) {
                        console.error('Error applying textures to hand:', e);
                    }
                }
            }
            
            // Show hand ONLY when NOT holding any item AND showItemInHand is enabled
            if (fpHandMesh) {
                fpHandMesh.visible = showItemInHand && !item;
            }
            
            if (!item) {
                // No item - just show hand (if enabled)
                updateHeldItemInfo();
                return;
            }
            
            // Create new item mesh when holding something
            heldItemMesh = createHeldItemMesh(item.type);
            
            if (heldItemMesh) {
                // Position to match Minecraft - blocks held at different angle than hand
                heldItemMesh.userData.basePosition = { x: 0.25, y: -0.2, z: -0.45 };
                heldItemMesh.userData.baseRotation = { x: 0.3, y: -0.5, z: 0.1 };
                heldItemMesh.position.set(0.25, -0.2, -0.45);
                heldItemMesh.rotation.set(0.3, -0.5, 0.1);
                handScene.add(heldItemMesh);
            }
            
            // Update held item info display
            updateHeldItemInfo();
        }
        
        // Add light to hand scene
        const handLight = new THREE.DirectionalLight(0xffffff, 1);
        handLight.position.set(1, 1, 1);
        handScene.add(handLight);
        const handAmbient = new THREE.AmbientLight(0xffffff, 0.6);
        handScene.add(handAmbient);
        
        // Load settings from localStorage on page load
        loadSettings();
        
        // Recreate arms if slim skin was loaded from settings
        if (isSlimSkin) {
            createArms();
            // Update UV maps for slim arms
            const armUVs = getArmUVMaps();
            skinUVMaps.rightArm = armUVs.rightArm;
            skinUVMaps.rightArmLayer = armUVs.rightArmLayer;
            skinUVMaps.leftArm = armUVs.leftArm;
            skinUVMaps.leftArmLayer = armUVs.leftArmLayer;
        }
        
        var renderer = new THREE.WebGLRenderer({ 
            canvas: c, 
            antialias: false, // Disabled antialiasing for blocky look
            powerPreference: "high-performance", // Request high-performance GPU
            precision: "mediump", // Medium precision for better performance
            stencil: false, // Disable stencil buffer
            depth: true // Keep depth buffer for proper rendering
        }); 
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap pixel ratio for performance
        renderer.shadowMap.enabled = shadowsEnabled; // Use setting value
        renderer.shadowMap.type = THREE.BasicShadowMap; // Blocky shadows like Minecraft
        renderer.sortObjects = false; // Disable sorting for performance
        document.body.appendChild(renderer.domElement);
        
        // NEW: Assign fakeCursorElement now that DOM is ready
        fakeCursorElement = document.getElementById('fake-cursor');
        pickedUpItemElement = document.getElementById('picked-up-item'); // MODIFIED: Assigned here

        // --- Lights and Materials (Optimized for performance) ---
        var aLight = new THREE.AmbientLight(0xffffff, 0.5); // Slightly brighter ambient
        scene.add(aLight);
        var dLight = new THREE.DirectionalLight(0xffffff, 0.6); // Brighter directional
        dLight.position.set(50, 100, 50);
        dLight.castShadow = true;
        // Optimized shadow settings - only directional light casts shadows for performance
        dLight.shadow.mapSize.width = 1024; // Improved shadow quality
        dLight.shadow.mapSize.height = 1024;
        dLight.shadow.camera.near = 0.5;
        dLight.shadow.camera.far = 500;
        dLight.shadow.camera.left = -50;
        dLight.shadow.camera.right = 50;
        dLight.shadow.camera.top = 50;
        dLight.shadow.camera.bottom = -50;
        scene.add(dLight);
        
        // --- 2D PIXEL ART SUN AND MOON SPRITES (MINECRAFT STYLE) ---
        const celestialDistance = 150; // Distance from camera
        
        // Function to create pixel art sun texture (bright and glowy like Minecraft)
        function createSunTexture() {
            const size = 128; // Larger for better quality
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            // Clear background
            ctx.clearRect(0, 0, size, size);
            
            // Add outer glow (multiple layers for gradient effect)
            const glowLayers = [
                { color: 'rgba(255, 255, 200, 0.15)', size: 58 },
                { color: 'rgba(255, 255, 150, 0.25)', size: 52 },
                { color: 'rgba(255, 255, 100, 0.35)', size: 46 },
                { color: 'rgba(255, 245, 80, 0.45)', size: 40 }
            ];
            
            glowLayers.forEach(layer => {
                ctx.fillStyle = layer.color;
                const offset = (size - layer.size) / 2;
                ctx.fillRect(offset, offset, layer.size, layer.size);
            });
            
            // Sun core - very bright white/yellow
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(36, 36, 56, 56);
            
            // Inner bright core
            ctx.fillStyle = '#FFFFD0';
            ctx.fillRect(42, 42, 44, 44);
            
            // Center highlight
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(52, 52, 24, 24);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            return texture;
        }
        
        // Function to create moon texture based on phase (0-7)
        // 0 = Full Moon, 1 = Waning Gibbous, 2 = Last Quarter, 3 = Waning Crescent
        // 4 = New Moon, 5 = Waxing Crescent, 6 = First Quarter, 7 = Waxing Gibbous
        function createMoonTexture(phase) {
            const size = 64;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            // Clear background
            ctx.clearRect(0, 0, size, size);
            
            const moonSize = 28;
            const moonX = 18;
            const moonY = 18;
            
            // Draw moon base (light gray)
            ctx.fillStyle = '#CCCCCC';
            ctx.fillRect(moonX, moonY, moonSize, moonSize);
            
            // Add highlights
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(moonX + 8, moonY + 4, 8, 8);
            
            // Add craters
            ctx.fillStyle = '#999999';
            ctx.fillRect(moonX + 4, moonY + 16, 4, 4);
            ctx.fillRect(moonX + 16, moonY + 10, 6, 6);
            ctx.fillRect(moonX + 20, moonY + 20, 3, 3);
            
            // Apply shadow based on phase
            ctx.fillStyle = 'rgba(0, 0, 0, 0.85)'; // Dark shadow
            
            switch(phase) {
                case 0: // Full Moon - no shadow
                    break;
                case 1: // Waning Gibbous - shadow on left edge
                    ctx.fillRect(moonX, moonY, 7, moonSize);
                    break;
                case 2: // Last Quarter - shadow on left half
                    ctx.fillRect(moonX, moonY, 14, moonSize);
                    break;
                case 3: // Waning Crescent - mostly shadow, thin crescent on right
                    ctx.fillRect(moonX, moonY, 21, moonSize);
                    break;
                case 4: // New Moon - completely dark
                    ctx.fillRect(moonX, moonY, moonSize, moonSize);
                    break;
                case 5: // Waxing Crescent - thin crescent on left
                    ctx.fillRect(moonX + 7, moonY, 21, moonSize);
                    break;
                case 6: // First Quarter - shadow on right half
                    ctx.fillRect(moonX + 14, moonY, 14, moonSize);
                    break;
                case 7: // Waxing Gibbous - shadow on right edge
                    ctx.fillRect(moonX + 21, moonY, 7, moonSize);
                    break;
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            return texture;
        }
        
        // Function to create pixel art moon texture
        function createMoonTexture() {
            const size = 64;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            // Clear background
            ctx.clearRect(0, 0, size, size);
            
            // Moon base - light gray
            ctx.fillStyle = '#CCCCCC';
            ctx.fillRect(18, 18, 28, 28);
            
            // Add highlights (white)
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(28, 24, 8, 8);
            
            // Add craters (darker gray)
            ctx.fillStyle = '#999999';
            ctx.fillRect(24, 36, 4, 4);
            ctx.fillRect(36, 28, 6, 6);
            ctx.fillRect(40, 40, 3, 3);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            return texture;
        }
        
        // Create sun as flat plane with brighter appearance
        const sunTexture = createSunTexture();
        const sunGeometry = new THREE.PlaneGeometry(40, 40); // Larger sun
        const sunMaterial = new THREE.MeshBasicMaterial({ 
            map: sunTexture,
            transparent: true,
            side: THREE.DoubleSide,
            depthWrite: false,
            opacity: 1.0
        });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        scene.add(sun);
        
        // Create moon as flat plane - starts with full moon
        let moonTexture = createMoonTexture(0);
        const moonGeometry = new THREE.PlaneGeometry(25, 25);
        const moonMaterial = new THREE.MeshBasicMaterial({ 
            map: moonTexture,
            transparent: true,
            side: THREE.DoubleSide,
            depthWrite: false
        });
        const moon = new THREE.Mesh(moonGeometry, moonMaterial);
        scene.add(moon);
        
        // Function to update moon texture based on current phase
        function updateMoonPhase() {
            const newTexture = createMoonTexture(moonPhase);
            moonMaterial.map = newTexture;
            moonMaterial.needsUpdate = true;
            if (moonTexture) moonTexture.dispose(); // Clean up old texture
            moonTexture = newTexture;
        }
        scene.add(moon);
        
        // --- SOUND SYSTEM WITH OGG FILES FROM GITHUB ---
        // Base URL for sound files
        const SOUND_BASE_URL = 'https://raw.githubusercontent.com/litoj/Enhanced-Soundcraft/master/assets/minecraft/sounds/';
        
        // Sound cache to prevent re-loading
        const soundCache = {};
        
        // Sound mappings for block types
        const soundFiles = {
            grass: {
                dig: ['dig/grass1.ogg', 'dig/grass2.ogg', 'dig/grass3.ogg', 'dig/grass4.ogg'],
                step: ['step/grass1.ogg', 'step/grass2.ogg', 'step/grass3.ogg', 'step/grass4.ogg']
            },
            gravel: {
                dig: ['dig/gravel1.ogg', 'dig/gravel2.ogg', 'dig/gravel3.ogg', 'dig/gravel4.ogg'],
                step: ['step/gravel1.ogg', 'step/gravel2.ogg', 'step/gravel3.ogg', 'step/gravel4.ogg']
            },
            stone: {
                dig: ['dig/stone1.ogg', 'dig/stone2.ogg', 'dig/stone3.ogg', 'dig/stone4.ogg'],
                step: ['step/stone1.ogg', 'step/stone2.ogg', 'step/stone3.ogg', 'step/stone4.ogg']
            },
            wood: {
                dig: ['dig/wood1.ogg', 'dig/wood2.ogg', 'dig/wood3.ogg', 'dig/wood4.ogg'],
                step: ['step/wood1.ogg', 'step/wood2.ogg', 'step/wood3.ogg', 'step/wood4.ogg']
            },
            sand: {
                dig: ['dig/sand1.ogg', 'dig/sand2.ogg', 'dig/sand3.ogg', 'dig/sand4.ogg'],
                step: ['step/sand1.ogg', 'step/sand2.ogg', 'step/sand3.ogg', 'step/sand4.ogg']
            },
            glass: {
                dig: ['random/glass1.ogg', 'random/glass2.ogg', 'random/glass3.ogg'],
                step: ['step/stone1.ogg', 'step/stone2.ogg']
            }
        };
        
        // Map block types to sound categories
        const blockSoundMap = {
            0: 'grass',   // GRASS
            1: 'gravel',  // DIRT
            2: 'stone',   // STONE
            3: 'wood',    // WOOD
            4: 'sand',    // SAND
            5: 'stone',   // BEDROCK
            6: 'grass',   // LEAVES
            7: 'glass',   // GLASS
            8: 'wood',    // DOOR
            9: 'wood',    // TORCH
            10: 'gravel', // WATER
            11: 'stone',  // LAVA
            12: 'wood'    // PLANKS
        };
        
        // Load and play OGG sound file
        async function playOggSound(soundPath, volume = 0.5) {
            try {
                const url = SOUND_BASE_URL + soundPath;
                
                // Check cache first
                if (soundCache[url]) {
                    const source = audioCtx.createBufferSource();
                    source.buffer = soundCache[url];
                    const gainNode = audioCtx.createGain();
                    gainNode.gain.value = volume * sfxVolume * masterVolume;
                    source.connect(gainNode);
                    gainNode.connect(audioCtx.destination);
                    source.start(0);
                    return;
                }
                
                // Fetch and decode audio
                const response = await fetch(url);
                if (!response.ok) throw new Error('Sound not found');
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
                
                // Cache the buffer
                soundCache[url] = audioBuffer;
                
                // Play the sound
                const source = audioCtx.createBufferSource();
                source.buffer = audioBuffer;
                const gainNode = audioCtx.createGain();
                gainNode.gain.value = volume * sfxVolume * masterVolume;
                source.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                source.start(0);
            } catch (err) {
                // Fallback to generated sound if OGG fails
                console.warn('OGG sound failed, using fallback:', soundPath, err);
                playFallbackSound(volume);
            }
        }
        
        // Fallback generated sound
        function playFallbackSound(volume = 0.2) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(sfxGainNode);
            osc.frequency.value = 400 + Math.random() * 200;
            gain.gain.setValueAtTime(volume, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.1);
        }
        
        // Get random sound from array
        function getRandomSound(sounds) {
            return sounds[Math.floor(Math.random() * sounds.length)];
        }
        
        function playBreakSound(blockType = 0) {
            const category = blockSoundMap[blockType] || 'grass';
            const sounds = soundFiles[category];
            if (sounds && sounds.dig) {
                playOggSound(getRandomSound(sounds.dig), 0.5);
            } else {
                playFallbackSound(0.3);
            }
        }
        
        function playPlaceSound(blockType = 0) {
            const category = blockSoundMap[blockType] || 'grass';
            const sounds = soundFiles[category];
            if (sounds && sounds.dig) {
                playOggSound(getRandomSound(sounds.dig), 0.4);
            } else {
                playFallbackSound(0.25);
            }
        }
        
        function playStepSound(blockType = 0) {
            const category = blockSoundMap[blockType] || 'grass';
            const sounds = soundFiles[category];
            if (sounds && sounds.step) {
                playOggSound(getRandomSound(sounds.step), 0.3);
            } else {
                playFallbackSound(0.15);
            }
        }
        
        function playJumpSound(blockType = 0) {
            const category = blockSoundMap[blockType] || 'grass';
            const sounds = soundFiles[category];
            if (sounds && sounds.step) {
                playOggSound(getRandomSound(sounds.step), 0.4);
            } else {
                playFallbackSound(0.2);
            }
        }
        
        
        // Damage/hurt sound effect - uses OGG files
        function playDamageSound() {
            // Try to load damage sound from GitHub
            const damageSounds = ['damage/hit1.ogg', 'damage/hit2.ogg', 'damage/hit3.ogg'];
            playOggSound(getRandomSound(damageSounds), 0.5);
        }
        
        // Helper function to get block type player is standing on
        function getBlockUnderPlayer() {
            const feetY = py - EYE_HEIGHT;
            const blockX = Math.round(px / bs);
            const blockY = Math.round(feetY / bs) - 1; // Block directly under feet
            const blockZ = Math.round(pz / bs);
            
            const blockKey = key(blockX, blockY, blockZ);
            const block = world[blockKey];
            
            return block ? block.userData.blockType : 0; // Default to grass sound
        }
        
        // Walking sound state
        let stepTimer = 0;
        const stepInterval = 0.4; // Time between steps in seconds
        let wasMoving = false;

        // --- PIXEL TEXTURE GENERATION ---
        function createPixelTexture(baseColor, pattern) {
            const canvas = document.createElement('canvas');
            canvas.width = 16;
            canvas.height = 16;
            const ctx = canvas.getContext('2d');
            
            // Fill base color
            ctx.fillStyle = baseColor;
            ctx.fillRect(0, 0, 16, 16);
            
            // Apply pattern
            pattern.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, p.w || 1, p.h || 1);
            });
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            texture.needsUpdate = true;
            return texture;
        }
        
        // Dirt Texture Pattern (brown with darker spots)
        const dirtPattern = [
            { x: 2, y: 1, color: '#5a3419' }, { x: 5, y: 2, color: '#5a3419' }, { x: 9, y: 3, color: '#5a3419' },
            { x: 12, y: 5, color: '#7a5030' }, { x: 3, y: 7, color: '#5a3419' }, { x: 8, y: 8, color: '#7a5030' },
            { x: 14, y: 9, color: '#5a3419' }, { x: 1, y: 11, color: '#7a5030' }, { x: 6, y: 12, color: '#5a3419' },
            { x: 11, y: 13, color: '#7a5030' }, { x: 4, y: 14, color: '#5a3419' }
        ];
        
        // Grass Top Texture Pattern (green with varied shades)
        const grassPattern = [
            { x: 1, y: 0, color: '#4a7a2e' }, { x: 4, y: 1, color: '#6a9c4e' }, { x: 7, y: 1, color: '#4a7a2e' },
            { x: 10, y: 2, color: '#6a9c4e' }, { x: 2, y: 3, color: '#4a7a2e' }, { x: 13, y: 4, color: '#6a9c4e' },
            { x: 5, y: 5, color: '#4a7a2e' }, { x: 8, y: 6, color: '#6a9c4e' }, { x: 11, y: 7, color: '#4a7a2e' },
            { x: 3, y: 9, color: '#6a9c4e' }, { x: 14, y: 10, color: '#4a7a2e' }, { x: 6, y: 11, color: '#6a9c4e' },
            { x: 9, y: 12, color: '#4a7a2e' }, { x: 1, y: 14, color: '#6a9c4e' }
        ];
        
        // Stone Texture Pattern (gray with darker cracks)
        const stonePattern = [
            { x: 3, y: 2, w: 2, color: '#606060' }, { x: 8, y: 1, color: '#909090' }, { x: 12, y: 3, color: '#606060' },
            { x: 1, y: 5, color: '#909090' }, { x: 6, y: 6, w: 2, color: '#606060' }, { x: 14, y: 7, color: '#909090' },
            { x: 4, y: 9, color: '#606060' }, { x: 10, y: 10, w: 2, color: '#909090' }, { x: 2, y: 12, color: '#606060' },
            { x: 13, y: 13, color: '#909090' }, { x: 7, y: 14, color: '#606060' }
        ];
        
        // Wood Texture Pattern - SIDES (brown with vertical grain lines)
        const woodSidePattern = [
            { x: 3, y: 0, h: 16, color: '#734a1a' }, { x: 8, y: 0, h: 16, color: '#9b6a3b' },
            { x: 12, y: 0, h: 16, color: '#734a1a' }, { x: 6, y: 4, w: 2, h: 1, color: '#6b421a' },
            { x: 10, y: 8, w: 2, h: 1, color: '#6b421a' }, { x: 5, y: 12, w: 2, h: 1, color: '#6b421a' }
        ];
        
        // Wood Texture Pattern - TOP/BOTTOM (rings pattern, lighter brown like Minecraft)
        const woodTopPattern = [
            // Outer ring
            { x: 2, y: 2, w: 12, h: 1, color: '#6b421a' },
            { x: 2, y: 13, w: 12, h: 1, color: '#6b421a' },
            { x: 2, y: 3, w: 1, h: 10, color: '#6b421a' },
            { x: 13, y: 3, w: 1, h: 10, color: '#6b421a' },
            // Middle ring
            { x: 4, y: 4, w: 8, h: 1, color: '#9b6a3b' },
            { x: 4, y: 11, w: 8, h: 1, color: '#9b6a3b' },
            { x: 4, y: 5, w: 1, h: 6, color: '#9b6a3b' },
            { x: 11, y: 5, w: 1, h: 6, color: '#9b6a3b' },
            // Inner ring
            { x: 6, y: 6, w: 4, h: 1, color: '#734a1a' },
            { x: 6, y: 9, w: 4, h: 1, color: '#734a1a' },
            { x: 6, y: 7, w: 1, h: 2, color: '#734a1a' },
            { x: 9, y: 7, w: 1, h: 2, color: '#734a1a' },
            // Center
            { x: 7, y: 7, w: 2, h: 2, color: '#8b5a2b' }
        ];
        
        // Planks Texture Pattern (horizontal wooden planks - distinct from log texture)
        const planksPattern = [
            // Horizontal plank boards (lighter color than logs)
            { x: 0, y: 0, w: 16, h: 4, color: '#b8936d' },
            { x: 0, y: 4, w: 16, h: 1, color: '#8b6f47' },
            { x: 0, y: 5, w: 16, h: 3, color: '#c9a876' },
            { x: 0, y: 8, w: 16, h: 1, color: '#8b6f47' },
            { x: 0, y: 9, w: 16, h: 3, color: '#b8936d' },
            { x: 0, y: 12, w: 16, h: 1, color: '#8b6f47' },
            { x: 0, y: 13, w: 16, h: 3, color: '#c9a876' },
            // Nail/joint details on planks
            { x: 2, y: 1, w: 1, h: 1, color: '#5a4a30' },
            { x: 13, y: 1, w: 1, h: 1, color: '#5a4a30' },
            { x: 5, y: 6, w: 1, h: 1, color: '#5a4a30' },
            { x: 10, y: 6, w: 1, h: 1, color: '#5a4a30' },
            { x: 2, y: 10, w: 1, h: 1, color: '#5a4a30' },
            { x: 13, y: 10, w: 1, h: 1, color: '#5a4a30' },
            { x: 7, y: 14, w: 1, h: 1, color: '#5a4a30' }
        ];
        
        // Create textured materials using real Minecraft textures from GitHub
        var mats = [];
        var textureLoader = new THREE.TextureLoader();
        
        // GitHub raw URL base for textures
        const GITHUB_TEXTURE_BASE = 'https://raw.githubusercontent.com/Matko802/Minecraft-html/main/textures/';
        
        // IndexedDB texture cache (separate from world DB)
        const TEXTURE_DB_NAME = 'WebcraftTextures';
        const TEXTURE_DB_VERSION = 1;
        const TEXTURE_STORE_NAME = 'textures';
        
        // Open IndexedDB for textures
        function openTextureDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(TEXTURE_DB_NAME, TEXTURE_DB_VERSION);
                request.onerror = () => reject(request.error);
                request.onsuccess = () => resolve(request.result);
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(TEXTURE_STORE_NAME)) {
                        db.createObjectStore(TEXTURE_STORE_NAME, { keyPath: 'name' });
                    }
                };
            });
        }
        
        // Get texture from IndexedDB cache
        async function getCachedTexture(name) {
            try {
                const db = await openTextureDB();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(TEXTURE_STORE_NAME, 'readonly');
                    const store = tx.objectStore(TEXTURE_STORE_NAME);
                    const request = store.get(name);
                    request.onsuccess = () => resolve(request.result?.data);
                    request.onerror = () => reject(request.error);
                });
            } catch (e) {
                console.warn('IndexedDB cache read failed:', e);
                return null;
            }
        }
        
        // Save texture to IndexedDB cache
        async function cacheTexture(name, dataUrl) {
            try {
                const db = await openTextureDB();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(TEXTURE_STORE_NAME, 'readwrite');
                    const store = tx.objectStore(TEXTURE_STORE_NAME);
                    const request = store.put({ name, data: dataUrl, timestamp: Date.now() });
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            } catch (e) {
                console.warn('IndexedDB cache write failed:', e);
            }
        }
        
        // Load texture from GitHub with IndexedDB caching
        async function loadGitHubTexture(filename) {
            const cachedData = await getCachedTexture(filename);
            
            // Helper to load texture from data URL and wait for it to be ready
            function loadTextureAsync(dataUrl) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => {
                        const texture = new THREE.Texture(img);
                        texture.magFilter = THREE.NearestFilter;
                        texture.minFilter = THREE.NearestFilter;
                        texture.generateMipmaps = false;
                        texture.needsUpdate = true;
                        resolve(texture);
                    };
                    img.onerror = (e) => reject(e);
                    img.src = dataUrl;
                });
            }
            
            if (cachedData) {
                console.log(`Loaded ${filename} from cache`);
                try {
                    return await loadTextureAsync(cachedData);
                } catch (e) {
                    console.warn(`Cache load failed for ${filename}, fetching fresh`);
                }
            }
            
            // Fetch from GitHub
            const url = GITHUB_TEXTURE_BASE + filename;
            console.log(`Fetching ${filename} from GitHub...`);
            
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const blob = await response.blob();
                const dataUrl = await new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.readAsDataURL(blob);
                });
                
                // Cache in IndexedDB
                await cacheTexture(filename, dataUrl);
                console.log(`Cached ${filename} in IndexedDB`);
                
                return await loadTextureAsync(dataUrl);
            } catch (e) {
                console.error(`Failed to load ${filename}:`, e);
                // Return placeholder texture
                return createPixelTexture('#ff00ff', []);
            }
        }
        
        // Helper function for sync texture loading (returns placeholder, updates async)
        // Track all materials that use each texture for proper updating
        const textureMaterialMap = {};
        
        function loadBlockTexture(filename) {
            // Create a placeholder texture with gray color initially
            const texture = createPixelTexture('#888888', []);
            
            // Track this texture for material updates
            if (!textureMaterialMap[filename]) {
                textureMaterialMap[filename] = { texture: texture, materials: [] };
            }
            
            // Load the actual texture from GitHub asynchronously
            loadGitHubTexture(filename).then(loadedTexture => {
                // Copy the loaded image to our texture
                if (loadedTexture && loadedTexture.image) {
                    texture.image = loadedTexture.image;
                    texture.magFilter = THREE.NearestFilter;
                    texture.minFilter = THREE.NearestFilter;
                    texture.generateMipmaps = false;
                    texture.needsUpdate = true;
                    
                    // Also update all materials using this texture
                    const entry = textureMaterialMap[filename];
                    if (entry && entry.materials) {
                        entry.materials.forEach(mat => {
                            if (mat) mat.needsUpdate = true;
                        });
                    }
                    
                    console.log(` Texture loaded: ${filename}`);
                }
            }).catch(err => {
                console.error(`Failed to load texture ${filename}:`, err);
            });
            
            return texture;
        }
        
        // Function to register a material with its texture for updates
        function registerMaterialTexture(material, filename) {
            if (textureMaterialMap[filename]) {
                textureMaterialMap[filename].materials.push(material);
            }
        }
        
        // Helper function to load texture with 90 degree rotation for left/right faces
        function loadBlockTextureRotated(filename, rotation) {
            const texture = loadBlockTexture(filename);
            texture.center.set(0.5, 0.5);
            texture.rotation = rotation;
            return texture;
        }
        
        // Load real textures from GitHub (cached in IndexedDB)
        var dirtTexture = loadBlockTexture('dirt.png');
        var grassTopTexture = loadBlockTexture('grass_top.png');
        var grassSideTexture = loadBlockTexture('grass_side.png');
        // Use same texture for all side faces (no rotation)
        var grassSideTextureRight = loadBlockTexture('grass_side.png');
        var grassSideTextureLeft = loadBlockTexture('grass_side.png');
        var stoneTexture = loadBlockTexture('stone.png');
        var woodSideTexture = loadBlockTexture('oak_wood_side.png');
        var woodSideTextureRight = loadBlockTexture('oak_wood_side.png');
        var woodSideTextureLeft = loadBlockTexture('oak_wood_side.png');
        var woodTopTexture = loadBlockTexture('oak_wood_top.png');
        var leavesTexture = loadBlockTexture('leaves.png');
        
        // Load sand texture from GitHub
        var sandTexture = loadBlockTexture('sand.png');
        
        // Fallback textures for blocks not in the GitHub repo (using procedural generation)
        var bedrockTexture = createPixelTexture('#222222', [
            { x: 1, y: 1, color: '#333333' }, { x: 5, y: 2, color: '#111111' }, { x: 9, y: 4, color: '#333333' },
            { x: 12, y: 6, color: '#111111' }, { x: 3, y: 8, color: '#333333' }, { x: 14, y: 11, color: '#111111' }
        ]);
        var planksTexture = createPixelTexture('#daa560', planksPattern);
        
        // Create materials from textures
        var matDirt = new THREE.MeshLambertMaterial({ map: dirtTexture });
        var matGrassTop = new THREE.MeshLambertMaterial({ map: grassTopTexture });
        var matGrassSide = new THREE.MeshLambertMaterial({ map: grassSideTexture });
        var matGrassSideRight = new THREE.MeshLambertMaterial({ map: grassSideTextureRight });
        var matGrassSideLeft = new THREE.MeshLambertMaterial({ map: grassSideTextureLeft });
        var matStone = new THREE.MeshLambertMaterial({ map: stoneTexture });
        var matWoodSide = new THREE.MeshLambertMaterial({ map: woodSideTexture });
        var matWoodSideRight = new THREE.MeshLambertMaterial({ map: woodSideTextureRight });
        var matWoodSideLeft = new THREE.MeshLambertMaterial({ map: woodSideTextureLeft });
        var matWoodTop = new THREE.MeshLambertMaterial({ map: woodTopTexture });
        var matPlanks = new THREE.MeshLambertMaterial({ map: planksTexture });
        var matSand = new THREE.MeshLambertMaterial({ map: sandTexture });
        var matBedrock = new THREE.MeshLambertMaterial({ map: bedrockTexture });
        
        // Leaves material with transparency
        var matLeaves = new THREE.MeshLambertMaterial({ map: leavesTexture, transparent: true, opacity: 0.85 });
        
        // Glass Texture Pattern (light blue/white with frame only - more transparent)
        var glassTexture = createPixelTexture('rgba(200, 230, 255, 0.2)', [
            // White frame around edges only
            { x: 0, y: 0, w: 16, h: 1, color: '#ffffff' },  // Top
            { x: 0, y: 15, w: 16, h: 1, color: '#ffffff' }, // Bottom
            { x: 0, y: 0, w: 1, h: 16, color: '#ffffff' },  // Left
            { x: 15, y: 0, w: 1, h: 16, color: '#ffffff' }  // Right
        ]);
        var matGlass = new THREE.MeshLambertMaterial({ 
            map: glassTexture, 
            transparent: true, 
            opacity: 0.4,
            side: THREE.DoubleSide
        });
        
        // Door Texture Pattern (wooden door with planks)
        var doorTexture = createPixelTexture('#8b5a2b', [
            { x: 0, y: 0, w: 16, h: 1, color: '#6b4a1b' },  // Top edge
            { x: 0, y: 15, w: 16, h: 1, color: '#6b4a1b' }, // Bottom edge
            { x: 0, y: 0, w: 1, h: 16, color: '#6b4a1b' },  // Left edge
            { x: 15, y: 0, w: 1, h: 16, color: '#6b4a1b' }, // Right edge
            // Horizontal planks
            { x: 2, y: 2, w: 12, h: 1, color: '#734a1a' },
            { x: 2, y: 5, w: 12, h: 1, color: '#734a1a' },
            { x: 2, y: 8, w: 12, h: 1, color: '#734a1a' },
            { x: 2, y: 11, w: 12, h: 1, color: '#734a1a' },
            { x: 2, y: 14, w: 12, h: 1, color: '#734a1a' },
            // Door handle
            { x: 12, y: 7, w: 2, h: 2, color: '#444444' }
        ]);
        var matDoor = new THREE.MeshLambertMaterial({ 
            map: doorTexture,
            side: THREE.DoubleSide
        });
        
        // Torch Texture Pattern (proper Minecraft torch look)
        var torchTexture = createPixelTexture('#000000', [
            // Dark wooden stick (bottom 7 pixels)
            { x: 7, y: 0, w: 2, h: 7, color: '#5c3c1f' },
            { x: 6, y: 1, w: 1, h: 5, color: '#4a2f19' },
            { x: 9, y: 1, w: 1, h: 5, color: '#6b4423' },
            // Flame base (pixels 8-10)
            { x: 6, y: 7, w: 4, h: 1, color: '#ff8800' },
            { x: 5, y: 8, w: 6, h: 1, color: '#ffaa00' },
            { x: 6, y: 9, w: 4, h: 1, color: '#ffdd00' },
            // Bright flame tip (pixels 11-12)
            { x: 6, y: 10, w: 4, h: 2, color: '#ffffaa' },
            { x: 7, y: 12, w: 2, h: 2, color: '#ffff88' }
        ]);
        var matTorch = new THREE.MeshLambertMaterial({ 
            map: torchTexture,
            emissive: 0xffaa00,
            emissiveIntensity: 0.5
        });
        
        // Water Texture Pattern (blue/cyan with subtle waves)
        var waterTexture = createPixelTexture('#3a5fcd', [
            { x: 1, y: 1, color: '#4a6fdd' }, { x: 4, y: 2, color: '#5a7fed' }, { x: 7, y: 1, color: '#4a6fdd' },
            { x: 10, y: 3, color: '#6a8ffd' }, { x: 2, y: 5, color: '#4a6fdd' }, { x: 13, y: 4, color: '#5a7fed' },
            { x: 5, y: 7, color: '#6a8ffd' }, { x: 9, y: 8, color: '#4a6fdd' }, { x: 12, y: 9, color: '#5a7fed' },
            { x: 3, y: 11, color: '#6a8ffd' }, { x: 14, y: 12, color: '#4a6fdd' }, { x: 6, y: 13, color: '#5a7fed' }
        ]);
        waterTexture.wrapS = waterTexture.wrapT = THREE.RepeatWrapping;
        var matWater = new THREE.MeshLambertMaterial({ 
            map: waterTexture,
            transparent: true,
            opacity: 0.6,
            depthWrite: false
        });
        
        // Lava Texture Pattern (orange/red with bright spots)
        var lavaTexture = createPixelTexture('#cc4400', [
            { x: 1, y: 1, color: '#ff6600' }, { x: 4, y: 2, color: '#ff8800' }, { x: 7, y: 1, color: '#dd5500' },
            { x: 10, y: 3, color: '#ffaa00' }, { x: 2, y: 5, color: '#dd5500' }, { x: 13, y: 4, color: '#ff6600' },
            { x: 5, y: 7, color: '#ff8800' }, { x: 9, y: 8, color: '#dd5500' }, { x: 12, y: 9, color: '#ffaa00' },
            { x: 3, y: 11, color: '#ff6600' }, { x: 14, y: 12, color: '#dd5500' }, { x: 6, y: 13, color: '#ff8800' },
            // Bright lava spots
            { x: 8, y: 5, color: '#ffdd00' }, { x: 11, y: 10, color: '#ffdd00' }, { x: 4, y: 14, color: '#ffdd00' }
        ]);
        lavaTexture.wrapS = lavaTexture.wrapT = THREE.RepeatWrapping;
        var matLava = new THREE.MeshLambertMaterial({ 
            map: lavaTexture,
            transparent: true,
            opacity: 0.9,
            emissive: 0xff6600,
            emissiveIntensity: 0.7,
            depthWrite: false
        });

        // Material mapping - all side faces use the same material, UV orientation is handled in createCulledGeometry
        // Face order in Three.js BoxGeometry: [right (+X), left (-X), top (+Y), bottom (-Y), front (+Z), back (-Z)]
        mats[0] = [matGrassSide, matGrassSide, matGrassTop, matDirt, matGrassSide, matGrassSide]; // Grass block
        mats[1] = matDirt;
        mats[2] = matStone;
        mats[3] = [matWoodSide, matWoodSide, matWoodTop, matWoodTop, matWoodSide, matWoodSide]; // Wood logs
        mats[4] = matSand;
        mats[5] = matBedrock;
        mats[6] = matLeaves;
        mats[7] = matGlass;
        mats[8] = matDoor;
        mats[9] = matTorch;
        mats[10] = matWater;
        mats[11] = matLava;
        mats[12] = matPlanks; // Planks - horizontal wooden boards

        // --- World Data and Basic Functions ---
        var world = {}; 
        var bs = 2; // Block Size
        var ws = 40; // World Size (in chunks)
        var worldBorderEnabled = true; // World border setting (default enabled)
        // renderDistance, mouseSensitivity, fieldOfView are declared at top of script
        var sel = 0; // HUD selection index (0-7)

        function key(x, y, z) { return Math.round(x) + "," + Math.round(y) + "," + Math.round(z); }

        // Optimization: Reuse geometries and materials
        var blockGeometry = new THREE.BoxGeometry(bs, bs, bs);
        var doorGeometry = new THREE.BoxGeometry(bs * 0.25, bs * 2, bs); // Thin door, 2 blocks tall
        var torchGeometry = new THREE.BoxGeometry(bs * 0.125, bs * 0.625, bs * 0.125); // Minecraft-like torch: 2x10x2 pixels
        
        // --- FACE CULLING GEOMETRY BUILDER ---
        // Creates a box geometry with only visible faces (for water/lava/block face culling)
        function createCulledGeometry(x, y, z, blockType) {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const normals = [];
            const uvs = [];
            const indices = [];
            const groups = [];
            
            const half = bs / 2;
            let vertexCount = 0;
            
            // Define the 6 faces: right, left, top, bottom, front, back
            const faces = [
                { dir: [1, 0, 0], vertices: [[half, -half, -half], [half, half, -half], [half, half, half], [half, -half, half]], normal: [1, 0, 0] },  // Right (+X)
                { dir: [-1, 0, 0], vertices: [[-half, -half, half], [-half, half, half], [-half, half, -half], [-half, -half, -half]], normal: [-1, 0, 0] }, // Left (-X)
                { dir: [0, 1, 0], vertices: [[-half, half, -half], [-half, half, half], [half, half, half], [half, half, -half]], normal: [0, 1, 0] },   // Top (+Y)
                { dir: [0, -1, 0], vertices: [[-half, -half, -half], [half, -half, -half], [half, -half, half], [-half, -half, half]], normal: [0, -1, 0] }, // Bottom (-Y)
                { dir: [0, 0, 1], vertices: [[-half, -half, half], [half, -half, half], [half, half, half], [-half, half, half]], normal: [0, 0, 1] },   // Front (+Z)
                { dir: [0, 0, -1], vertices: [[half, -half, -half], [-half, -half, -half], [-half, half, -half], [half, half, -half]], normal: [0, 0, -1] }  // Back (-Z)
            ];
            
            // Check each face
            faces.forEach((face, faceIndex) => {
                const [dx, dy, dz] = face.dir;
                const neighborKey = key(x + dx, y + dy, z + dz);
                const neighborBlock = world[neighborKey];
                
                // Determine if this face should be culled
                let shouldCull = false;
                
                if (neighborBlock) {
                    const neighborType = neighborBlock.userData.blockType;
                    
                    // Never cull faces against doors
                    if (neighborBlock.userData.isDoor || neighborType === DOOR_TYPE) {
                        shouldCull = false;
                    } else {
                        // For transparent blocks, handle culling
                        const isCurrentTransparent = [WATER_TYPE, LAVA_TYPE, GLASS_TYPE].includes(blockType);
                        const isNeighborTransparent = [WATER_TYPE, LAVA_TYPE, GLASS_TYPE, LEAVES_TYPE, TORCH_TYPE, DOOR_TYPE].includes(neighborType);
                        
                        if (isCurrentTransparent) {
                            // Water culls with water, lava culls with lava (regardless of flow level)
                            if (blockType === WATER_TYPE && neighborType === WATER_TYPE) {
                                shouldCull = true;
                            } else if (blockType === LAVA_TYPE && neighborType === LAVA_TYPE) {
                                shouldCull = true;
                            } else if (blockType === neighborType) {
                                shouldCull = true;
                            }
                        } else if (!isNeighborTransparent) {
                            // Solid block next to solid block: cull
                            shouldCull = true;
                        }
                    }
                }
                
                // Add face if not culled
                if (!shouldCull) {
                    const startVertex = vertexCount;
                    
                    // UV coordinates for this face - adjusted per face to ensure identical orientation on all 4 sides
                    // faceIndex: 0=Right, 1=Left, 2=Top, 3=Bottom, 4=Front, 5=Back
                    // Goal: All side faces show grass_side with grass at top, dirt at bottom, same horizontal direction
                    let faceUVs;
                    if (faceIndex === 0) {
                        // Right face (+X) - vertices go: bottom-back, top-back, top-front, bottom-front
                        faceUVs = [[1, 0], [1, 1], [0, 1], [0, 0]];
                    } else if (faceIndex === 1) {
                        // Left face (-X) - vertices go: bottom-front, top-front, top-back, bottom-back
                        faceUVs = [[0, 0], [0, 1], [1, 1], [1, 0]];
                    } else if (faceIndex === 4) {
                        // Front face (+Z) - vertices go: bottom-left, bottom-right, top-right, top-left
                        faceUVs = [[0, 0], [1, 0], [1, 1], [0, 1]];
                    } else if (faceIndex === 5) {
                        // Back face (-Z) - vertices go: bottom-right, bottom-left, top-left, top-right
                        faceUVs = [[1, 0], [0, 0], [0, 1], [1, 1]];
                    } else {
                        // Top and Bottom faces use standard UVs
                        faceUVs = [[0, 0], [0, 1], [1, 1], [1, 0]];
                    }
                    
                    // Add vertices for this face
                    face.vertices.forEach((v, i) => {
                        vertices.push(...v);
                        normals.push(...face.normal);
                        uvs.push(...faceUVs[i]);
                    });
                    
                    // Add indices (two triangles per face)
                    indices.push(
                        startVertex, startVertex + 1, startVertex + 2,
                        startVertex, startVertex + 2, startVertex + 3
                    );
                    
                    // Add material group for this face
                    groups.push({
                        start: (startVertex / 4) * 6, // Each face has 6 indices (2 triangles)
                        count: 6,
                        materialIndex: faceIndex
                    });
                    
                    vertexCount += 4;
                }
            });
            
            // If no faces are visible, return null
            if (vertices.length === 0) return null;
            
            // Set attributes
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            geometry.setIndex(indices);
            
            // Set groups for multi-material
            groups.forEach(group => {
                geometry.addGroup(group.start, group.count, group.materialIndex);
            });
            
            geometry.computeBoundingSphere();
            
            return geometry;
        }
        
        // --- BLOCK OUTLINE ---
        const outlineGeometry = new THREE.EdgesGeometry(new THREE.BoxGeometry(bs + 0.02, bs + 0.02, bs + 0.02));
        const doorOutlineGeometry = new THREE.EdgesGeometry(new THREE.BoxGeometry(bs * 0.25 + 0.02, bs * 2 + 0.02, bs + 0.02));
        const outlineMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
        const blockOutline = new THREE.LineSegments(outlineGeometry, outlineMaterial);
        blockOutline.visible = false;
        scene.add(blockOutline);
        
        // --- PARTICLE SYSTEM ---
        const particles = [];
        const particleGeometry = new THREE.PlaneGeometry(0.3, 0.3);
        
        function createBreakParticles(x, y, z, blockType) {
            const particleMaterial = mats[blockType];
            const mat = Array.isArray(particleMaterial) ? particleMaterial[0] : particleMaterial;
            
            for (let i = 0; i < 8; i++) {
                const particle = new THREE.Mesh(particleGeometry, mat.clone());
                particle.position.set(
                    x * bs + (Math.random() - 0.5) * bs,
                    y * bs + (Math.random() - 0.5) * bs,
                    z * bs + (Math.random() - 0.5) * bs
                );
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 5,
                    Math.random() * 8 + 2,
                    (Math.random() - 0.5) * 5
                );
                particle.lifetime = 1.0;
                scene.add(particle);
                particles.push(particle);
            }
        }
        
        // Helper function to check if a block position has a solid neighbor
        function hasSolidBlockAt(x, y, z) {
            var blockKey = key(x, y, z);
            var block = world[blockKey];
            if (!block) return false;
            
            var blockType = block.userData.blockType;
            // Transparent/non-solid blocks don't count as occluders
            if (blockType === GLASS_TYPE || blockType === LEAVES_TYPE || 
                blockType === WATER_TYPE || blockType === LAVA_TYPE || 
                blockType === TORCH_TYPE || blockType === DOOR_TYPE) {
                return false;
            }
            
            return true;
        }
        
        // Check if a block is completely surrounded by solid blocks (hidden face culling)
        function isBlockCompletelyHidden(x, y, z) {
            // Check all 6 neighbors
            return hasSolidBlockAt(x + 1, y, z) &&
                   hasSolidBlockAt(x - 1, y, z) &&
                   hasSolidBlockAt(x, y + 1, z) &&
                   hasSolidBlockAt(x, y - 1, z) &&
                   hasSolidBlockAt(x, y, z + 1) &&
                   hasSolidBlockAt(x, y, z - 1);
        }
        
        function add(x, y, z, t, facingAngle = 0) {
            var k = key(x, y, z);
            // Allow placing blocks through water or lava
            const existingBlock = world[k];
            if (existingBlock) {
                const existingType = existingBlock.userData.blockType;
                // If it's water or lava, allow block placement (replace liquid)
                if ((existingType === WATER_TYPE || existingType === LAVA_TYPE) && 
                    t !== WATER_TYPE && t !== LAVA_TYPE) {
                    scene.remove(existingBlock);
                    if (existingBlock.geometry) existingBlock.geometry.dispose();
                    delete world[k];
                } else {
                    return; // Can't place if occupied by non-liquid block
                }
            }
            
            var m = mats[t];
            var mesh;
            
            // Special handling for doors - single mesh spanning 2 blocks
            if (t === DOOR_TYPE) {
                // Check if there's space for 2 blocks tall (allow replacing liquids)
                var kAbove = key(x, y + 1, z);
                if (world[kAbove]) {
                    const above = world[kAbove];
                    const aboveType = above.userData.blockType;
                    const aboveIsLiquid = (aboveType === WATER_TYPE || aboveType === LAVA_TYPE);
                    if (aboveIsLiquid) {
                        scene.remove(above);
                        if (above.geometry) above.geometry.dispose();
                        delete world[kAbove];
                    } else {
                        return; // Occupied by non-liquid
                    }
                }
                
                // Create single mesh positioned between y and y+1
                const geom = doorGeometry.clone();
                mesh = new THREE.Mesh(geom, m);
                
                // Determine door rotation based on camera angle
                // Round to nearest 90-degree angle and rotate 90 so door faces the player
                const doorRotation = Math.round(facingAngle / (Math.PI / 2)) * (Math.PI / 2) + Math.PI / 2;
                
                // Position door at block center when closed (no offset)
                mesh.position.set(x * bs, y * bs + bs / 2, z * bs);
                mesh.rotation.y = doorRotation; // Set initial rotation based on placement angle
                
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.userData.blockType = t;
                mesh.userData.isDoor = true;
                mesh.userData.doorOpen = false;
                mesh.userData.doorBottomY = y; // Store bottom position
                mesh.userData.doorRotation = doorRotation; // Store initial rotation
                mesh.userData.baseX = x * bs; // Store base block position
                mesh.userData.baseZ = z * bs;
                scene.add(mesh);
                
                // Store in both block positions but pointing to same mesh
                world[k] = mesh;
                world[kAbove] = mesh;
                
                // Play place sound if not silent
                if (!mesh.userData.silentPlace) {
                    playPlaceSound(t);
                }
            } else if (t === TORCH_TYPE) {
                // Torch positioned at same height as normal blocks
                mesh = new THREE.Mesh(torchGeometry, m);
                mesh.position.set(x * bs, y * bs, z * bs);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.userData.blockType = t;
                mesh.userData.isTorch = true; // Flag for no collision
                scene.add(mesh);
                world[k] = mesh;
                
                // Add bright point light at torch position (optimized - no shadows for performance)
                var torchLight = new THREE.PointLight(0xffaa00, 2.0, 20); // Increased intensity and range
                torchLight.position.set(x * bs, y * bs + bs * 0.3, z * bs);
                torchLight.castShadow = false; // Disabled for performance - allows multiple torches
                scene.add(torchLight);
                mesh.userData.light = torchLight;
                
                // Play place sound if not silent
                if (!mesh.userData.silentPlace) {
                    playPlaceSound(t);
                }
            } else {
                // Regular block, water, or lava - use face culling
                // For water and lava, we want per-face culling
                // For solid blocks, we keep the existing full culling optimization
                
                if (t === WATER_TYPE || t === LAVA_TYPE) {
                    // Water and lava: use per-face culling
                    const culledGeometry = createCulledGeometry(x, y, z, t);
                    
                    if (culledGeometry) {
                        // Create mesh with culled geometry
                        mesh = new THREE.Mesh(culledGeometry, Array.isArray(m) ? m : [m, m, m, m, m, m]); 
                        mesh.position.set(x * bs, y * bs, z * bs);
                        mesh.castShadow = true;
                        mesh.receiveShadow = true;
                        mesh.userData.blockType = t;
                        scene.add(mesh);
                    } else {
                        // All faces culled - create placeholder
                        mesh = new THREE.Object3D();
                        mesh.position.set(x * bs, y * bs, z * bs);
                        mesh.userData.blockType = t;
                        mesh.userData.isHidden = true;
                    }
                } else {
                    // Solid blocks: check if completely hidden for optimization
                    var isHidden = isBlockCompletelyHidden(x, y, z);
                    
                    if (!isHidden) {
                        // Use per-face culling for solid blocks too
                        const culledGeometry = createCulledGeometry(x, y, z, t);
                        
                        if (culledGeometry) {
                            mesh = new THREE.Mesh(culledGeometry, Array.isArray(m) ? m : [m, m, m, m, m, m]); 
                            mesh.position.set(x * bs, y * bs, z * bs);
                            mesh.castShadow = true;
                            mesh.receiveShadow = true;
                            mesh.userData.blockType = t;
                            scene.add(mesh);
                        } else {
                            // All faces culled - create placeholder
                            mesh = new THREE.Object3D();
                            mesh.position.set(x * bs, y * bs, z * bs);
                            mesh.userData.blockType = t;
                            mesh.userData.isHidden = true;
                        }
                    } else {
                        // Block is completely hidden - create a minimal placeholder
                        mesh = new THREE.Object3D();
                        mesh.position.set(x * bs, y * bs, z * bs);
                        mesh.userData.blockType = t;
                        mesh.userData.isHidden = true;
                    }
                }
            }
            
            // Store in world (both visible and hidden blocks need to be tracked)
            world[k] = mesh;
            
            // After placing a block, refresh neighboring blocks' geometry (for face culling)
            refreshNeighborFaces(x, y, z);
            
            // After placing a block, check if any neighbors become completely hidden
            hideNeighbors(x, y, z);
            
            // Play place sound only when player places (not during world generation or grass spreading)
            if (locked && !paused && !mesh.userData.silentPlace && !mesh.userData.isHidden) {
                playPlaceSound(t);
            }
            
            // Water blocks are simple - no flow mechanics needed
        }
        
        // Function to refresh neighboring blocks' faces (for water/lava/block face culling)
        function refreshNeighborFaces(x, y, z) {
            const neighbors = [
                [x + 1, y, z], [x - 1, y, z],
                [x, y + 1, z], [x, y - 1, z],
                [x, y, z + 1], [x, y, z - 1]
            ];
            
            neighbors.forEach(([nx, ny, nz]) => {
                const nKey = key(nx, ny, nz);
                const neighborBlock = world[nKey];
                
                // If neighbor exists and is visible (has geometry)
                if (neighborBlock && neighborBlock.geometry) {
                    const blockType = neighborBlock.userData.blockType;
                    
                    // Skip doors and torches - they don't need face culling
                    if (blockType === DOOR_TYPE || blockType === TORCH_TYPE) return;
                    
                    // Regenerate geometry with updated face culling
                    const newGeometry = createCulledGeometry(nx, ny, nz, blockType);
                    const oldGeometry = neighborBlock.geometry;
                    
                    if (newGeometry) {
                        // Update to new culled geometry
                        neighborBlock.geometry = newGeometry;
                        oldGeometry.dispose();
                        
                        // Make sure it's visible
                        if (neighborBlock.userData.isHidden) {
                            scene.add(neighborBlock);
                            neighborBlock.userData.isHidden = false;
                        }
                    } else {
                        // All faces culled - hide the block
                        if (!neighborBlock.userData.isHidden) {
                            scene.remove(neighborBlock);
                            neighborBlock.userData.isHidden = true;
                        }
                        oldGeometry.dispose();
                    }
                }
            });
        }
        
        // Function to check and hide neighboring blocks that become completely surrounded
        function hideNeighbors(x, y, z) {
            const neighbors = [
                [x + 1, y, z], [x - 1, y, z],
                [x, y + 1, z], [x, y - 1, z],
                [x, y, z + 1], [x, y, z - 1]
            ];
            
            neighbors.forEach(([nx, ny, nz]) => {
                const nKey = key(nx, ny, nz);
                const neighborBlock = world[nKey];
                
                // If neighbor exists and is currently visible (not already hidden)
                if (neighborBlock && !neighborBlock.userData.isHidden && 
                    neighborBlock.userData.blockType !== DOOR_TYPE &&
                    neighborBlock.userData.blockType !== TORCH_TYPE) {
                    
                    // Check if it becomes completely hidden now
                    if (isBlockCompletelyHidden(nx, ny, nz)) {
                        const blockType = neighborBlock.userData.blockType;
                        
                        // Remove the visible mesh from scene
                        scene.remove(neighborBlock);
                        delete world[nKey];
                        
                        // Replace with invisible placeholder
                        const placeholder = new THREE.Object3D();
                        placeholder.position.set(nx * bs, ny * bs, nz * bs);
                        placeholder.userData.blockType = blockType;
                        placeholder.userData.isHidden = true;
                        world[nKey] = placeholder;
                    }
                }
            });
        }
        
        // --- LIQUID FLOW SYSTEM (Water & Lava) ---
        const MAX_FLOW_LEVEL = 7; // Source is 0, max flowing is 7
        
        function flowLiquids() {
            // Track all liquid blocks (both source and flowing)
            const liquidBlocks = [];
            
            for (const k in world) {
                const block = world[k];
                const blockType = block?.userData.blockType;
                if (blockType === WATER_TYPE || blockType === LAVA_TYPE) {
                    const [x, y, z] = k.split(',').map(Number);
                    const flowLevel = block.userData.flowLevel !== undefined ? block.userData.flowLevel : 0;
                    liquidBlocks.push({ x, y, z, type: blockType, flowLevel });
                }
            }
            
            // Process each liquid block
            const toAdd = [];
            const toCobblestone = [];
            
            for (const { x, y, z, type, flowLevel } of liquidBlocks) {
                // PRIORITY 1: Flow downward if possible (downward flow becomes source)
                const belowKey = key(x, y - 1, z);
                const belowBlock = world[belowKey];
                
                if (!belowBlock && y > 0) {
                    // Empty space below - flow down (becomes source at 0)
                    toAdd.push({ x, y: y - 1, z, type, flowLevel: 0 });
                    continue;
                }
                
                // PRIORITY 2: Flow horizontally if can't flow down
                // Stop flowing at MAX_FLOW_LEVEL
                if (flowLevel >= MAX_FLOW_LEVEL) {
                    continue; // Max flow distance reached
                }
                
                const horizontalDirections = [
                    [x + 1, y, z],
                    [x - 1, y, z],
                    [x, y, z + 1],
                    [x, y, z - 1]
                ];
                
                for (const [nx, ny, nz] of horizontalDirections) {
                    const nKey = key(nx, ny, nz);
                    const neighborBlock = world[nKey];
                    
                    // Check if space is empty
                    if (!neighborBlock) {
                        // Check if this position has a block below it (so liquid doesn't flow into air)
                        const supportKey = key(nx, ny - 1, nz);
                        const supportBlock = world[supportKey];
                        
                        if (supportBlock || ny === 0) {
                            // Has support or is at bedrock level - create flowing liquid
                            toAdd.push({ x: nx, y: ny, z: nz, type, flowLevel: flowLevel + 1 });
                        }
                    } else if (neighborBlock.userData.blockType === type) {
                        // If neighbor is same liquid type, update its flow level if ours is lower
                        const neighborFlowLevel = neighborBlock.userData.flowLevel !== undefined ? neighborBlock.userData.flowLevel : 0;
                        if (flowLevel + 1 < neighborFlowLevel) {
                            neighborBlock.userData.flowLevel = flowLevel + 1;
                        }
                    }
                    
                    // COBBLESTONE GENERATION: Check for water-lava interaction
                    if (type === WATER_TYPE && neighborBlock?.userData.blockType === LAVA_TYPE) {
                        // Water touches lava - create cobblestone
                        toCobblestone.push({ x: nx, y: ny, z: nz });
                    } else if (type === LAVA_TYPE && neighborBlock?.userData.blockType === WATER_TYPE) {
                        // Lava touches water - create cobblestone
                        toCobblestone.push({ x: nx, y: ny, z: nz });
                    }
                }
            }
            
            // Apply cobblestone generation first (replaces lava/water)
            const halfWorldSize = ws / 2;
            for (const { x, y, z } of toCobblestone) {
                if (x >= -halfWorldSize && x < halfWorldSize && 
                    z >= -halfWorldSize && z < halfWorldSize) {
                    // Remove existing liquid
                    const k = key(x, y, z);
                    if (world[k]) {
                        scene.remove(world[k]);
                        if (world[k].geometry) world[k].geometry.dispose();
                        delete world[k];
                    }
                    // Place cobblestone
                    add(x, y, z, COBBLESTONE_TYPE);
                }
            }
            
            // Then add new flowing liquid blocks
            for (const { x, y, z, type, flowLevel } of toAdd) {
                if (x >= -halfWorldSize && x < halfWorldSize && 
                    z >= -halfWorldSize && z < halfWorldSize) {
                    const k = key(x, y, z);
                    if (!world[k]) { // Only add if still empty
                        add(x, y, z, type);
                        // Set flow level on the newly created block
                        if (world[k]) {
                            world[k].userData.flowLevel = flowLevel;
                        }
                    }
                }
            }
        }
        
        // Function to remove all flowing liquid blocks connected to a removed liquid source
        function removeConnectedFlowingLiquid(x, y, z, liquidType) {
            // Get all liquid blocks of the same type
            const allLiquidBlocks = [];
            for (const k in world) {
                const block = world[k];
                const blockType = block?.userData.blockType;
                if (blockType === liquidType) {
                    const [bx, by, bz] = k.split(',').map(Number);
                    const flowLevel = block.userData.flowLevel !== undefined ? block.userData.flowLevel : 0;
                    allLiquidBlocks.push({ x: bx, y: by, z: bz, flowLevel, key: k });
                }
            }
            
            // Remove the destroyed block from the list
            const destroyedKey = key(x, y, z);
            const remainingBlocks = allLiquidBlocks.filter(b => b.key !== destroyedKey);
            
            // Find all source blocks (flowLevel === 0)
            const sourceBlocks = remainingBlocks.filter(b => b.flowLevel === 0);
            
            // If no source blocks remain, remove all liquid blocks
            if (sourceBlocks.length === 0) {
                for (const block of remainingBlocks) {
                    const k = block.key;
                    if (world[k]) {
                        scene.remove(world[k]);
                        if (world[k].geometry) world[k].geometry.dispose();
                        delete world[k];
                    }
                }
                return;
            }
            
            // Mark all blocks reachable from source blocks using BFS
            const reachable = new Set();
            const queue = [...sourceBlocks];
            
            for (const source of sourceBlocks) {
                reachable.add(source.key);
            }
            
            while (queue.length > 0) {
                const current = queue.shift();
                
                // Check all neighbors
                const neighbors = [
                    [current.x + 1, current.y, current.z],
                    [current.x - 1, current.y, current.z],
                    [current.x, current.y + 1, current.z],
                    [current.x, current.y - 1, current.z],
                    [current.x, current.y, current.z + 1],
                    [current.x, current.y, current.z - 1]
                ];
                
                for (const [nx, ny, nz] of neighbors) {
                    const nKey = key(nx, ny, nz);
                    const neighborBlock = world[nKey];
                    
                    if (neighborBlock && 
                        neighborBlock.userData.blockType === liquidType && 
                        !reachable.has(nKey)) {
                        reachable.add(nKey);
                        const neighborFlowLevel = neighborBlock.userData.flowLevel !== undefined ? neighborBlock.userData.flowLevel : 0;
                        queue.push({ x: nx, y: ny, z: nz, flowLevel: neighborFlowLevel, key: nKey });
                    }
                }
            }
            
            // Remove all liquid blocks that are NOT reachable from any source
            for (const block of remainingBlocks) {
                if (!reachable.has(block.key)) {
                    const k = block.key;
                    if (world[k]) {
                        scene.remove(world[k]);
                        if (world[k].geometry) world[k].geometry.dispose();
                        delete world[k];
                    }
                }
            }
        }

        function remove(x, y, z) {
            var k = key(x, y, z);
            if (world[k]) {
                const blockType = world[k].userData.blockType; 
                const mesh = world[k];
                
                // --- Bedrock Indestructibility Check ---
                // MODIFIED: Only indestructible in Survival mode
                if (blockType === BEDROCK_TYPE && !isCreativeMode) {
                     console.log("Bedrock cannot be destroyed in Survival Mode.");
                     return; 
                }
                
                // --- Water Indestructibility Check ---
                // Water can be destroyed in creative mode
                if (blockType === WATER_TYPE && !isCreativeMode) {
                     console.log("Water cannot be destroyed in survival mode.");
                     return;
                }
                
                // --- Remove Connected Flowing Water ---
                // If we're removing water or lava, clear dependent flowing blocks
                if (blockType === WATER_TYPE || blockType === LAVA_TYPE) {
                    removeConnectedFlowingLiquid(x, y, z, blockType);
                }
                // -------------------------------------------

                // Special handling for doors - remove both blocks
                if (blockType === DOOR_TYPE) {
                    const doorBottomY = mesh.userData.doorBottomY;
                    const kBottom = key(x, doorBottomY, z);
                    const kTop = key(x, doorBottomY + 1, z);
                    
                    // Create break particles at door position
                    createBreakParticles(x, doorBottomY, z, blockType);
                    playBreakSound(blockType);
                    
                    // Remove from scene and world
                    scene.remove(mesh);
                    delete world[kBottom];
                    delete world[kTop];
                    
                    // Add to inventory only if using correct tool or in creative
                    if (shouldDropBlock(blockType)) {
                        addToInventory(DOOR_TYPE, 1);
                    }
                    return;
                }
                
                // Special handling for torch - remove light
                if (blockType === TORCH_TYPE && mesh.userData.light) {
                    scene.remove(mesh.userData.light);
                }

                // Create break particles
                createBreakParticles(x, y, z, blockType);
                
                // Play breaking sound with block type
                playBreakSound(blockType);

                scene.remove(mesh);
                delete world[k];
                
                // Refresh neighboring blocks' faces (for water/lava/block face culling)
                refreshNeighborFaces(x, y, z);
                
                // Reveal neighboring blocks that may have been hidden
                revealNeighbors(x, y, z);
                
                // MODIFIED: Grass (type 0) drops Dirt (type 1)
                const dropType = (blockType === GRASS_TYPE) ? DIRT_TYPE : blockType; 

                // Only add to inventory if block should drop (correct tool used)
                // Grass and leaves always drop regardless of tool
                if (blockType === GRASS_TYPE || blockType === LEAVES_TYPE || shouldDropBlock(blockType)) {
                    addToInventory(dropType, 1);
                }
                
                // Water auto-fill will handle gaps
            }
        }
        
        // Function to check and reveal hidden neighboring blocks when a block is removed
        function revealNeighbors(x, y, z) {
            const neighbors = [
                [x + 1, y, z], [x - 1, y, z],
                [x, y + 1, z], [x, y - 1, z],
                [x, y, z + 1], [x, y, z - 1]
            ];
            
            neighbors.forEach(([nx, ny, nz]) => {
                const nKey = key(nx, ny, nz);
                const neighborBlock = world[nKey];
                
                // If neighbor exists and is marked as hidden
                if (neighborBlock && neighborBlock.userData.isHidden) {
                    const blockType = neighborBlock.userData.blockType;
                    
                    // Check if it's still completely hidden
                    if (!isBlockCompletelyHidden(nx, ny, nz)) {
                        // No longer hidden - need to render it with face culling
                        scene.remove(neighborBlock); // Remove placeholder
                        delete world[nKey];
                        
                        // Add it back as a visible block with culled geometry
                        const m = mats[blockType];
                        const culledGeometry = createCulledGeometry(nx, ny, nz, blockType);
                        
                        if (culledGeometry) {
                            const newMesh = new THREE.Mesh(culledGeometry, Array.isArray(m) ? m : [m, m, m, m, m, m]);
                            newMesh.position.set(nx * bs, ny * bs, nz * bs);
                            newMesh.castShadow = true;
                            newMesh.receiveShadow = true;
                            newMesh.userData.blockType = blockType;
                            scene.add(newMesh);
                            world[nKey] = newMesh;
                        } else {
                            // All faces still culled - keep as placeholder
                            const placeholder = new THREE.Object3D();
                            placeholder.position.set(nx * bs, ny * bs, nz * bs);
                            placeholder.userData.blockType = blockType;
                            placeholder.userData.isHidden = true;
                            world[nKey] = placeholder;
                        }
                    }
                }
            });
        }
        
        // Toggle door open/closed state (no animation - instant like Minecraft)
        function toggleDoor(x, y, z) {
            var k = key(x, y, z);
            var mesh = world[k];
            
            if (!mesh || mesh.userData.blockType !== DOOR_TYPE) return;
            
            // Toggle door state instantly
            const currentlyOpen = mesh.userData.doorOpen;
            mesh.userData.doorOpen = !currentlyOpen;
            
            // Get stored initial rotation and base position
            const initialRotation = mesh.userData.doorRotation;
            const baseX = mesh.userData.baseX;
            const baseZ = mesh.userData.baseZ;
            
            if (currentlyOpen) {
                // Closing door - return to block center position
                mesh.rotation.y = initialRotation;
                mesh.position.x = baseX;
                mesh.position.z = baseZ;
            } else {
                // Opening door - rotate 90 degrees (no position change)
                mesh.rotation.y = initialRotation + Math.PI / 2;
                mesh.position.x = baseX;
                mesh.position.z = baseZ;
            }
            
            // Play door sound
            playPlaceSound(WOOD_TYPE); // Use wood sound for door
        }

        // Helper function for collision check
        function isBlockPresent(x, y, z) {
            var tx = Math.round(x / bs);
            var ty = Math.round(y / bs); 
            var tz = Math.round(z / bs);
            var block = world[key(tx, ty, tz)];
            
            if (!block) return false;
            
            // Return false for torches (no collision)
            if (block.userData.isTorch) {
                return false;
            }
            
            // Return false for water and lava (no collision - can swim through)
            const blockType = block.userData.blockType;
            if (blockType === WATER_TYPE || blockType === LAVA_TYPE) {
                return false;
            }
            
            // Return false for open doors (no collision)
            if (block.userData.blockType === DOOR_TYPE && block.userData.doorOpen) {
                return false;
            }
            
            return true;
        }
        
        function generateWorld() {
             // Optimization: More efficient cleanup - don't dispose shared geometry
             for(var k in world) { 
                scene.remove(world[k]); 
             }
            world = {};
            
            if (isFlatWorld) {
                // --- FLAT WORLD GENERATION ---
                for (var x = -ws / 2; x < ws / 2; x++) {
                    for (var z = -ws / 2; z < ws / 2; z++) {
                        add(x, 0, z, BEDROCK_TYPE); // Bedrock at Y=0
                        add(x, 1, z, 2); // Stone at Y=1
                        add(x, 2, z, DIRT_TYPE); // Dirt at Y=2
                        add(x, 3, z, GRASS_TYPE); // Grass at Y=3
                    }
                }
                return; // Exit early for flat world
            }
            
            // Optimization: Pre-calculate noise values
            var noiseMap = {};
            for (var x = -ws / 2; x < ws / 2; x++) {
                for (var z = -ws / 2; z < ws / 2; z++) {
                    var seededX = x + WORLD_SEED / 100;
                    var seededZ = z + WORLD_SEED / 100;
                    
                    // Enhanced terrain generation with biomes
                    var baseHeight = Math.floor(
                        Math.sin(seededX * 0.1) * Math.cos(seededZ * 0.1) * 2 + 
                        Math.sin(seededX * 0.3) * 1.5 + 
                        Math.cos(seededZ * 0.2) * 1.5 + 
                        4
                    );
                    
                    // Biome determination (using noise for variation)
                    var biomeNoise = Math.sin(seededX * 0.05) * Math.cos(seededZ * 0.05);
                    var moistureNoise = Math.sin(seededX * 0.08) * Math.sin(seededZ * 0.08);
                    
                    // Store height and biome data
                    noiseMap[x + ',' + z] = {
                        height: baseHeight,
                        biome: biomeNoise,
                        moisture: moistureNoise
                    };
                }
            }
            
            // Generate terrain using pre-calculated noise
            for (var x = -ws / 2; x < ws / 2; x++) {
                for (var z = -ws / 2; z < ws / 2; z++) {
                    var data = noiseMap[x + ',' + z];
                    var h = data.height;
                    var biome = data.biome;
                    var moisture = data.moisture;
                    
                    // 1. ADD BEDROCK at Y=0 (type 5)
                    add(x, 0, z, BEDROCK_TYPE); 

                    // 2. Generate terrain from Y=1 up to h+1 with biome-specific blocks
                    for (var y = 1; y < h + 1; y++) { 
                        var bt = 2; // Default is Stone
                        
                        // Determine surface block based on biome
                        if (y === h) { 
                            // Desert/Beach biome (sand) - dry and low areas
                            if (biome > 0.3 && moisture < -0.2) {
                                bt = 4; // Sand
                            }
                            // Water-adjacent areas (beaches)
                            else if (h <= 3) {
                                bt = 4; // Sand at water level
                            }
                            // Normal grass
                            else {
                                bt = 0; // Grass
                            }
                        } 
                        // Subsurface layers
                        else if (y >= h - 2) {
                            // Sand continues deeper in desert biomes
                            if (biome > 0.3 && moisture < -0.2) {
                                bt = 4; // Sand
                            } else {
                                bt = 1; // Dirt
                            }
                        }
                        // Deep layers are stone
                        
                        add(x, y, z, bt); 
                    }

                    // 3. Tree Generation (only on grass, not sand)
                    var topBlockType = (biome > 0.3 && moisture < -0.2) || h <= 3 ? 4 : 0;
                    if (topBlockType === 0 && h >= 5 && Math.random() < 0.02) { 
                        generateTree(x, h + 1, z);
                    }
                }
            }
            
            // 4. REALISTIC WATER & LAVA GENERATION (Seas and Puddles only - NO water on grass)
            
            // Define water level (sea level)
            var SEA_LEVEL = 4;
            
            // First pass: Create oceans and seas by filling low-lying areas
            for (var x = -ws / 2; x < ws / 2; x++) {
                for (var z = -ws / 2; z < ws / 2; z++) {
                    var data = noiseMap[x + ',' + z];
                    var h = data.height;
                    var biome = data.biome;
                    var moisture = data.moisture;
                    
                    // Create ocean/sea if terrain is below sea level
                    if (h < SEA_LEVEL) {
                        // Fill with water above terrain up to sea level
                        for (var y = h + 1; y <= SEA_LEVEL; y++) {
                            add(x, y, z, WATER_TYPE);
                        }
                    }
                }
            }
            
            // Second pass: Create underground water puddles ONLY
            for (var x = -ws / 2; x < ws / 2; x++) {
                for (var z = -ws / 2; z < ws / 2; z++) {
                    var data = noiseMap[x + ',' + z];
                    var h = data.height;
                    var biome = data.biome;
                    
                    // Skip if already underwater (in ocean)
                    if (h < SEA_LEVEL) continue;
                    
                    var isSandBiome = (biome > 0.3 && data.moisture < -0.2);
                    
                    // Small water puddles underground in wet areas (NOT on surface)
                    if (!isSandBiome && data.moisture > 0.2 && h >= 4 && Math.random() < 0.002) {
                        var puddleDepth = Math.floor(Math.random() * 2) + 2; // 2-3 blocks underground
                        var puddleKey = key(x, h - puddleDepth, z);
                        // Only place puddle if there's a solid block there to replace
                        if (world[puddleKey]) {
                            remove(x, h - puddleDepth, z);
                            add(x, h - puddleDepth, z, WATER_TYPE);
                        }
                    }
                    
                    // Lava pools in desert biomes (underground)
                    if (isSandBiome && Math.random() < 0.001 && h >= 3) {
                        var lavaDepth = Math.floor(Math.random() * 2) + 2;
                        var lavaKey = key(x, h - lavaDepth, z);
                        if (world[lavaKey]) {
                            remove(x, h - lavaDepth, z);
                            add(x, h - lavaDepth, z, LAVA_TYPE);
                        }
                    }
                    
                    // Rare underground lava pockets (deep)
                    if (Math.random() < 0.0005 && h >= 5) {
                        var deepLavaDepth = Math.floor(Math.random() * 3) + 3;
                        var deepLavaKey = key(x, h - deepLavaDepth, z);
                        if (world[deepLavaKey]) {
                            remove(x, h - deepLavaDepth, z);
                            add(x, h - deepLavaDepth, z, LAVA_TYPE);
                        }
                    }
                }
            }
        }

        // --- Player/Movement variables ---
        var px = 0; var py = 20; var pz = 0; 
        var vx = 0; var vy = 0; var vz = 0; 
        var rx = 0; var ry = 0; 
        var ground = false;
        var keys = {};
        var locked = false;
        var paused = false; 
        var inventoryOpen = false;
        
        // --- Keybind System (defined at top of script) ---
        let waitingForKey = null;
        
        // --- FLYING VARS ---
        let isFlying = false; 
        let lastSpacePress = 0;
        let spaceHeld = false; // NEW: Track if space is held
        const DOUBLE_PRESS_TIME = 300; // ms
        // -------------------------
        
        // --- OXYGEN/BREATHING VARS ---
        let maxOxygen = 10; // Maximum oxygen (10 bubbles)
        let currentOxygen = maxOxygen; // Current oxygen level
        let isUnderwater = false; // Track if player is underwater
        const oxygenDepletionRate = 1; // Oxygen lost per second underwater (1 bubble per second)
        const oxygenRegenRate = 5; // Oxygen gained per second when not underwater (fast regen)
        const drownDamageRate = 2; // Damage per second when out of oxygen
        let drownDamageTimer = 0; // Timer for drowning damage
        const drownDamageInterval = 1.0; // Take damage every 1 second when drowning
        // -------------------------
        
        // --- HEALTH SYSTEM VARS ---
        let maxHealth = 20; // Maximum health (10 hearts = 20 half-hearts)
        let currentHealth = maxHealth; // Current health level
        let isDead = false; // Track if player is dead
        
        // --- LAVA DAMAGE SYSTEM ---
        let isInLava = false; // Track if player is in lava
        let lavaDamageTimer = 0; // Timer for lava damage
        const lavaDamageInterval = 0.5; // Take damage every 0.5 seconds in lava
        const lavaDamageAmount = 4; // 2 hearts of damage per tick (4 half-hearts)
        
        // --- FALL DAMAGE SYSTEM ---
        let fallStartY = 0; // Y position when player started falling
        let wasFalling = false; // Track if player was falling last frame
        const SAFE_FALL_DISTANCE = 3; // Blocks fallen before taking damage (3 blocks = safe)
        const FALL_DAMAGE_MULTIPLIER = 1; // Damage per block fallen beyond safe distance (1 heart per block)
        // -------------------------
        
        // --- Player Size Constants (1.8 blocks tall - Minecraft standard) ---
        var PLAYER_TOTAL_HEIGHT = bs * 1.8; // Total player height (1.8 blocks)
        var EYE_HEIGHT = bs * 1.62; // Camera eye height from feet (1.62 blocks from feet)
        var PLAYER_HEIGHT = PLAYER_TOTAL_HEIGHT; // For collision detection
        var PLAYER_RADIUS = bs * 0.3; // Player is 0.6 blocks wide (matches Minecraft)

        var pauseMenu = document.getElementById('pause-menu'); 
        var inventoryScreen = document.getElementById('inventory-screen'); 
        var uiElement = document.getElementById('ui'); 
        var settingsSeedInput = document.getElementById('settingsSeedInput'); 
        var settingsSeedInputStart = document.getElementById('settingsSeedInputStart'); 

        // --- NEW COOLDOWN VARIABLES ---
        const COOLDOWN_TIME_MS = 2000; // 2 seconds
        let isCooldownActive = false;
        const continueGameButton = document.getElementById('main-menu-btn-pause');
        
        // Respawn button cooldown variables
        let isRespawnCooldownActive = false;
        const respawnButton = document.getElementById('respawn-btn');
        
        // Track if buttons have been clicked to skip countdown
        let pauseMenuButtonsClicked = false;
        // --- END NEW COOLDOWN VARIABLES ---


        function resetPlayer() {
            px = 0; py = 20; pz = 0; vx = 0; vy = 0; vz = 0; rx = 0; ry = 0; 
            // Player height is constant at 2 blocks
            PLAYER_HEIGHT = PLAYER_TOTAL_HEIGHT; 
            camera.position.set(px, py, pz);
            camera.rotation.set(rx, ry, 0, 'YXZ');
            ground = false;
            
            // Reset oxygen to full
            currentOxygen = maxOxygen;
            isUnderwater = false;
            drownDamageTimer = 0;
            
            // Reset health to full
            currentHealth = maxHealth;
            isDead = false;
            
            // Reset lava damage
            isInLava = false;
            lavaDamageTimer = 0;
            
            // Reset fall damage tracking
            fallStartY = py;
            wasFalling = false;
            
            // Clear inventory in survival mode
            if (!isCreativeMode) {
                inventoryData = Array(TOTAL_SLOTS).fill(null);
                updateInventoryUI();
                updateToolbarSelection();
            }
            
            // Reset game modes
            // isCreativeMode is preserved across respawns (Fix for user request)
            isFlying = false;
            
            // Hide death screen
            document.getElementById('death-screen').style.display = 'none';
        }
        resetPlayer(); 

        
        // --- Health & Oxygen UI Update Functions ---
        function updateHealthUI() {
            const healthContainer = document.getElementById('health-container');
            if (!isCreativeMode) {
                healthContainer.style.display = 'block';
                healthContainer.innerHTML = '';
                
                const numHearts = 10; // Total 10 hearts (20 health points)
                for (let i = 0; i < numHearts; i++) {
                    const heart = document.createElement('span');
                    heart.className = 'heart';
                    
                    const heartValue = (i + 1) * 2; // Each heart represents 2 health
                    
                    if (currentHealth >= heartValue) {
                        // Full heart
                        heart.classList.add('full');
                    } else if (currentHealth >= heartValue - 1) {
                        // Half heart
                        heart.classList.add('half');
                    } else {
                        // Empty heart
                        heart.classList.add('empty');
                    }
                    
                    // Add low health animation
                    if (currentHealth <= 6) {
                        heart.classList.add('low');
                    }
                    
                    healthContainer.appendChild(heart);
                }
            } else {
                healthContainer.style.display = 'none';
            }
        }
        
        function updateOxygenUI() {
            const oxygenContainer = document.getElementById('oxygen-container');
            if (!isCreativeMode && (isUnderwater || currentOxygen < maxOxygen)) {
                oxygenContainer.style.display = 'block';
                oxygenContainer.innerHTML = '';
                
                const numBubbles = 10; // Total 10 bubbles
                for (let i = 0; i < numBubbles; i++) {
                    const bubble = document.createElement('span');
                    bubble.className = 'bubble';
                    
                    if (currentOxygen < (i + 1)) {
                        // Popped bubble
                        bubble.classList.add('popped');
                    }
                    
                    oxygenContainer.appendChild(bubble);
                }
            } else {
                oxygenContainer.style.display = 'none';
            }
        }
        
        function takeDamage(amount) {
            if (isCreativeMode || isDead) return;
            
            currentHealth = Math.max(0, currentHealth - amount);
            updateHealthUI();
            
            // Play damage sound
            playDamageSound();
            
            // Damage visual effects
            applyDamageEffects(amount);
            
            if (currentHealth <= 0) {
                playerDeath();
            }
        }
        
        // Damage visual effects: red flash and camera shake
        function applyDamageEffects(damageAmount) {
            // Create red damage overlay
            let damageOverlay = document.getElementById('damage-overlay');
            if (!damageOverlay) {
                damageOverlay = document.createElement('div');
                damageOverlay.id = 'damage-overlay';
                damageOverlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: radial-gradient(circle, transparent 40%, rgba(255, 0, 0, 0.4) 100%);
                    pointer-events: none;
                    z-index: 9999;
                    opacity: 0;
                    transition: opacity 0.05s ease-out;
                `;
                document.body.appendChild(damageOverlay);
            }
            
            // Flash red based on damage amount
            const intensity = Math.min(damageAmount / 20, 1); // Scale with damage
            damageOverlay.style.opacity = intensity;
            
            // Fade out
            setTimeout(() => {
                damageOverlay.style.opacity = '0';
            }, 100);
            
            // Camera shake effect
            const shakeIntensity = Math.min(damageAmount * 0.02, 0.3);
            const shakeDuration = 200 + damageAmount * 10; // Longer shake for more damage
            applyCameraShake(shakeIntensity, shakeDuration);
        }
        
        // Camera shake implementation
        let isShaking = false;
        let shakeOffset = { x: 0, y: 0, z: 0 };
        
        function applyCameraShake(intensity, duration) {
            if (isShaking) return; // Prevent multiple shakes
            
            isShaking = true;
            const startTime = Date.now();
            const originalRx = rx;
            
            function shake() {
                const elapsed = Date.now() - startTime;
                if (elapsed > duration) {
                    isShaking = false;
                    shakeOffset = { x: 0, y: 0, z: 0 };
                    return;
                }
                
                // Decay intensity over time
                const progress = elapsed / duration;
                const currentIntensity = intensity * (1 - progress);
                
                // Random shake offset
                shakeOffset.x = (Math.random() - 0.5) * currentIntensity;
                shakeOffset.y = (Math.random() - 0.5) * currentIntensity;
                shakeOffset.z = (Math.random() - 0.5) * currentIntensity;
                
                requestAnimationFrame(shake);
            }
            
            shake();
        }
        
        function playerDeath() {
            isDead = true;
            paused = true;
            
            // Exit pointer lock
            if (document.exitPointerLock) {
                document.exitPointerLock();
            }
            locked = false;
            
            // Hide crosshair, show death screen
            const crosshair = document.getElementById('crosshair');
            const deathScreen = document.getElementById('death-screen');
            const deathScore = document.getElementById('death-score');
            if (crosshair) crosshair.style.display = 'none';
            if (deathScreen) deathScreen.style.display = 'flex';
            
            // Calculate score
            const score = Math.floor((Date.now() - (window.gameStartTime || Date.now())) / 1000);
            if (deathScore) deathScore.textContent = score + ' seconds survived';
            
            // Stop player movement
            vx = 0;
            vy = 0;
            vz = 0;
        }


        
        // --- Game Mode Toggle Functions ---
        function updateGameModeButtonText() {
            if (gameModeToggleBtn) {
                gameModeToggleBtn.textContent = isCreativeMode ? 'Switch to Survival' : 'Switch to Creative';
            }
        }

        function toggleGameMode() {
            isCreativeMode = !isCreativeMode;
            
            if (isCreativeMode) {
                isFlying = false; // Disable flying when switching (will be re-enabled on double-space if desired)
            } else {
                isFlying = false; // MUST disable flying when switching to survival
            }
            
            updateGameModeButtonText();
            inventoryScreen.classList.toggle('creative-mode', isCreativeMode);
            
            // Refresh inventories to show/hide ''
            updateInventoryUI();
            updateToolbarSelection();
        }

        // --- Inventory Toggle Function ---
        function toggleInventory() {
            if (!locked) return; 
            inventoryOpen = !inventoryOpen;
            // Game no longer pauses when inventory is open - player just can't move/interact

            if (inventoryOpen) {
                inventoryScreen.style.display = 'flex';
                // Set class based on current game mode
                inventoryScreen.classList.toggle('creative-mode', isCreativeMode);
                updateGameModeButtonText(); // Update button text
                
                // Add animation class
                inventoryScreen.classList.remove('inventory-animate');
                setTimeout(() => {
                    inventoryScreen.classList.add('inventory-animate');
                }, 10);
                
                // Hide HUD elements when inventory is open
                document.getElementById('crosshair').style.display = 'none';
                document.getElementById('toolbar').style.display = 'none';
                document.getElementById('health-container').style.display = 'none';
                document.getElementById('oxygen-container').style.display = 'none';
                document.getElementById('fps').style.display = 'none';
                if (uiElement) uiElement.style.display = 'none';
                const debugInfoElement = document.getElementById('debug-info');
                if (debugInfoElement) debugInfoElement.style.display = 'none';
                
                // NEW: Show and reset fake cursor (will be centered by CSS transform)
                fakeCursorElement.style.display = 'block';
                fakeCursorX = window.innerWidth / 2;
                fakeCursorY = window.innerHeight / 2;
                fakeCursorElement.style.left = fakeCursorX + 'px';
                fakeCursorElement.style.top = fakeCursorY + 'px';
                
                // Initialize picked-up item position to match cursor
                if (pickedUpItemElement) {
                    pickedUpItemElement.style.left = fakeCursorX + 'px';
                    pickedUpItemElement.style.top = fakeCursorY + 'px';
                }
                
                // Initialize crafting UI and category tabs
                initCraftingUI();
                generateBlockPicker(currentCategory);
                initCategoryTabs();
                
                updateInventoryUI();
            } else {
                inventoryScreen.style.display = 'none';
                inventoryScreen.classList.remove('inventory-animate');
                
                // Show HUD elements when closing inventory
                document.getElementById('crosshair').style.display = 'block';
                document.getElementById('toolbar').style.display = 'flex';
                if (!isCreativeMode) {
                    document.getElementById('health-container').style.display = 'block';
                    document.getElementById('oxygen-container').style.display = 'block';
                }
                // Respect FPS and UI visibility settings
                const fpsElement = document.getElementById('fps');
                if (fpsElement) {
                    // Show FPS only when in game and setting is enabled
                    fpsElement.style.display = (fpsAlwaysVisible && currentGameState === GAME_STATE.IN_GAME) || showHitbox ? 'block' : 'none';
                }
                if (uiElement) {
                    uiElement.style.display = showHitbox ? 'block' : 'none';
                }
                const debugInfoElement = document.getElementById('debug-info');
                if (debugInfoElement) {
                    debugInfoElement.style.display = showHitbox ? 'block' : 'none';
                }
                
                // NEW: Hide fake cursor
                fakeCursorElement.style.display = 'none';
                
                // Return crafting grid items to inventory
                craftingGrid.forEach(item => {
                    if (item && !isCreativeMode) {
                        addToInventory(item.type, item.count);
                    }
                });
                craftingGrid = Array(9).fill(null);
                
                // When closing inventory, drop the item being held to prevent loss
                if (pickedUpItem) {
                    if (!isCreativeMode) {
                        // Add back to inventory in survival
                        addToInventory(pickedUpItem.type, pickedUpItem.count);
                    }
                    // In creative, item just disappears
                    pickedUpItem = null;
                }
                // NEW: Update UI to hide pickedUpItemElement when closing
                updateInventoryUI();
            }
            updateToolbarSelection();
        }
        
        // --- MODIFIED: Toggle Pause Function to handle cooldown ---
        function togglePause() {
            // Only allow unpausing if cooldown is not active
            if (!paused && isCooldownActive) return; 

            paused = !paused;
            if (!paused) {
                // Resume game: Request pointer lock
                setGameState(GAME_STATE.IN_GAME);
                
                requestLock(renderer.domElement);
                pauseMenu.style.display = 'none';
                // Music continues playing during gameplay
                
                // Show ALL HUD elements when resuming game
                document.getElementById('crosshair').style.display = 'block';
                document.getElementById('toolbar').style.display = 'flex';
                if (!isCreativeMode) {
                    document.getElementById('health-container').style.display = 'block';
                    document.getElementById('oxygen-container').style.display = 'block';
                }
                // Respect FPS and UI visibility settings
                const fpsElement = document.getElementById('fps');
                if (fpsElement) {
                    // Show FPS only when in game and setting is enabled
                    fpsElement.style.display = (fpsAlwaysVisible && currentGameState === GAME_STATE.IN_GAME) || showHitbox ? 'block' : 'none';
                }
                if (uiElement) {
                    uiElement.style.display = showHitbox ? 'block' : 'none';
                }
                const debugInfoElement = document.getElementById('debug-info');
                if (debugInfoElement) {
                    debugInfoElement.style.display = showHitbox ? 'block' : 'none';
                }
                
                // Reset button text (ESC no longer works to close pause menu)
                continueGameButton.textContent = 'CONTINUE GAME';
            } else {
                // Pause game: Exit pointer lock
                document.exitPointerLock();
                showPauseMenu();
            }
        }
        
        function showPauseMenu() {
            // Set game state to pause menu
            setGameState(GAME_STATE.PAUSE_MENU);
            
            // Only pause if inventory wasn't open
            if (!inventoryOpen) {
                paused = true;
            }
            inventoryOpen = false;
            inventoryScreen.style.display = 'none'; 
            pauseMenu.style.display = 'flex';
            
            // Add animation class (same as inventory)
            pauseMenu.classList.remove('inventory-animate');
            setTimeout(() => {
                pauseMenu.classList.add('inventory-animate');
            }, 10);
            
            startBackgroundMusic(); // Start music when paused
            
            // Hide ALL HUD elements when menu is open
            document.getElementById('crosshair').style.display = 'none';
            document.getElementById('toolbar').style.display = 'none';
            document.getElementById('health-container').style.display = 'none';
            document.getElementById('oxygen-container').style.display = 'none';
            document.getElementById('fps').style.display = 'none';
            if (uiElement) uiElement.style.display = 'none';
            const debugInfoElement = document.getElementById('debug-info');
            if (debugInfoElement) debugInfoElement.style.display = 'none';
            
            // NEW: Hide fake cursor if it was open
            if (fakeCursorElement) fakeCursorElement.style.display = 'none';
            // NEW: Hide floating item if it was visible
            if (pickedUpItemElement) pickedUpItemElement.style.display = 'none';


            settingsSeedInput.value = WORLD_SEED;
            
            // Display current world name
            const worldNameDisplay = document.getElementById('current-world-name');
            if (worldNameDisplay && currentWorldName) {
                worldNameDisplay.textContent = 'World: ' + currentWorldName;
            }
            
            // COUNTDOWN FOR BUTTONS WHEN PAUSE MENU OPENS (every time)
            const pauseMenuCountdown = 2000; // 2000 milliseconds (2 seconds)
            let remainingTime = pauseMenuCountdown;
            
            // Disable buttons and show countdown
            continueGameButton.disabled = true;
            respawnButton.disabled = true;
            continueGameButton.textContent = `CONTINUE GAME (${(remainingTime / 1000).toFixed(2)}s)`;
            respawnButton.textContent = `RESPAWN (${(remainingTime / 1000).toFixed(2)}s)`;
            
            // Update countdown every 100ms for smooth animation
            const pauseCountdownInterval = setInterval(() => {
                remainingTime -= 100;
                
                if (remainingTime <= 0) {
                    clearInterval(pauseCountdownInterval);
                    // Enable buttons and reset text (ESC no longer works in pause menu)
                    continueGameButton.disabled = false;
                    respawnButton.disabled = false;
                    continueGameButton.textContent = 'CONTINUE GAME';
                    respawnButton.textContent = 'RESPAWN';
                } else {
                    // Update button text with remaining time in seconds with 2 decimal places
                    continueGameButton.textContent = `CONTINUE GAME (${(remainingTime / 1000).toFixed(2)}s)`;
                    respawnButton.textContent = `RESPAWN (${(remainingTime / 1000).toFixed(2)}s)`;
                }
            }, 100);
            // END COUNTDOWN
        }
        
        // --- Event Listeners ---
        document.addEventListener('keydown', function(e) {
            // Keybind customization handler
            if (waitingForKey) {
                e.preventDefault();
                e.stopPropagation();
                
                // Don't allow F5, F11, or Tab as keybinds
                if (e.code === 'F5' || e.code === 'F11' || e.code === 'Tab') {
                    waitingForKey.textContent = keybinds[waitingForKey.dataset.action] ? getKeyDisplay(keybinds[waitingForKey.dataset.action]) : 'NONE';
                    waitingForKey.style.background = '#444';
                    waitingForKey = null;
                    return;
                }
                
                keybinds[waitingForKey.dataset.action] = e.code;
                waitingForKey.textContent = getKeyDisplay(e.code);
                waitingForKey.style.background = '#444';
                waitingForKey = null;
                saveSettings();
                playClickSound();
                return;
            }
            
            keys[e.code] = true; 
            
            // --- FLYING TOGGLE (Double Space) ---
            if (e.code === keybinds.jump && locked && !inventoryOpen && !paused) {
                // Double-tap to fly ONLY works in creative mode
                if (!isCreativeMode) return; 
                
                // NEW: Bug fix for hold-to-fly-toggle
                if (spaceHeld) return; // Don't process if key is already held
                
                spaceHeld = true;
                
                const now = Date.now();
                if (now - lastSpacePress < DOUBLE_PRESS_TIME) { 
                    isFlying = !isFlying; 
                    lastSpacePress = 0; // Reset to prevent triple-press
                } else {
                    lastSpacePress = now;
                }
            }
            
            // Inventory toggle (only when NOT in pause menu)
            if (e.code === keybinds.inventory && locked && !paused) { 
                inventoryOpen = !inventoryOpen;
                
                if (inventoryOpen) {
                    const inventoryScreen = document.getElementById('inventory-screen');
                    inventoryScreen.style.display = 'flex';
                    
                    // Add animation class
                    inventoryScreen.classList.remove('inventory-animate');
                    setTimeout(() => {
                        inventoryScreen.classList.add('inventory-animate');
                    }, 10);
                    
                    fakeCursorElement.style.display = 'block';
                    document.getElementById('crosshair').style.display = 'none'; 
                    
                    fakeCursorX = window.innerWidth / 2;
                    fakeCursorY = window.innerHeight / 2;
                    fakeCursorElement.style.left = fakeCursorX + 'px';
                    fakeCursorElement.style.top = fakeCursorY + 'px';
                    
                    playClickSound();
                } else {
                    const inventoryScreen = document.getElementById('inventory-screen');
                    inventoryScreen.style.display = 'none';
                    inventoryScreen.classList.remove('inventory-animate');
                    
                    fakeCursorElement.style.display = 'none';
                    document.getElementById('crosshair').style.display = 'block'; 
                    
                    if (pickedUpItem) { 
                        addItemToInventory(pickedUpItem.type, pickedUpItem.count, false);
                        pickedUpItem = null;
                        updateInventoryUI();
                    }
                    
                    playClickSound();
                }
            }
            
            // Pause menu toggle - ESC only opens pause menu from gameplay, NOT close it
            if (e.code === keybinds.pause && locked && !paused) { 
                togglePause();
            }
            
            // HUD selection 1-8 keys (only when NOT in inventory)
            if (!inventoryOpen && e.code.startsWith('Digit') && e.keyCode >= 49 && e.keyCode <= 56) { 
                sel = e.keyCode - 49; 
                updateToolbarSelection();
            }

        });

        document.addEventListener('keyup', function(e) { 
            keys[e.code] = false; 
            // NEW: Bug fix for fly toggle
            if (e.code === keybinds.jump) {
                spaceHeld = false;
            }
        });
        
        // --- NEW: Cross-browser Pointer Lock Change Handler ---
        function onPointerLockChange() { 
            locked = document.pointerLockElement === renderer.domElement ||
                     document.mozPointerLockElement === renderer.domElement || // Firefox prefix
                     document.webkitPointerLockElement === renderer.domElement; // Webkit prefix (Chrome)
                     
            // Check if lock is lost
            if (!locked) {
                // If inventory was open, we need to explicitly close it first, then transition to pause menu.
                if (inventoryOpen) {
                    // Manually perform the 'close inventory' steps from toggleInventory()
                    inventoryOpen = false; // State change
                    
                    inventoryScreen.style.display = 'none';
                    document.getElementById('crosshair').style.display = 'block'; 
                    
                    // Hide fake cursor/picked up item
                    if (fakeCursorElement) fakeCursorElement.style.display = 'none';
                    if (pickedUpItemElement) pickedUpItemElement.style.display = 'none';

                    // When closing inventory, drop the item being held to prevent loss
                    if (pickedUpItem) {
                        if (!isCreativeMode) {
                            // Add back to inventory in survival
                            addToInventory(pickedUpItem.type, pickedUpItem.count);
                        }
                        pickedUpItem = null;
                    }
                    updateInventoryUI();
                    
                    // Now, transition to the "Game Stopped" screen
                    showPauseMenu();

                } else if (!paused) { 
                    // If not in inventory and not already in pause menu, simply show pause menu (e.g., alt-tab from gameplay)
                    showPauseMenu();
                }
            }
        }
        
        document.addEventListener('pointerlockchange', onPointerLockChange, false);
        document.addEventListener('mozpointerlockchange', onPointerLockChange, false);
        document.addEventListener('webkitpointerlockchange', onPointerLockChange, false);
        // --- END NEW ---

        // MODIFIED: Continue Game button with cooldown (same as respawn button)
        continueGameButton.addEventListener('click', function() {
            // Immediately execute the continue game action
            togglePause();
        });
        // NEW: Save World button
        document.getElementById('save-world-btn').addEventListener('click', function() {
            if (currentWorldName) {
                saveWorld(currentWorldName);
                alert('World saved successfully!');
            }
        });
        
        // NEW: Settings button from pause menu
        document.getElementById('pause-settings-btn').addEventListener('click', function() {
            // Set flag to remember we came from pause menu
            openedSettingsFromPause = true;
            
            // Hide pause menu (HUD already hidden from showPauseMenu)
            pauseMenu.style.display = 'none';
            
            // Show main menu with settings view and dark overlay for in-game
            const mainMenu = document.getElementById('main-menu');
            mainMenu.style.display = 'flex';
            mainMenu.classList.add('in-game-overlay'); // Add overlay class
            mainMenu.style.animation = 'none'; // No parallax during gameplay
            
            // Set settings state
            setGameState(GAME_STATE.SETTINGS);
            
            // Add animation class (same as inventory and pause menu)
            mainMenu.classList.remove('inventory-animate');
            setTimeout(() => {
                mainMenu.classList.add('inventory-animate');
            }, 10);
            
            // Initialize sliders with current values
            const slider = document.getElementById('renderDistanceSlider');
            const valueSpan = document.getElementById('renderDistanceValue');
            if (slider && valueSpan) {
                slider.value = renderDistance;
                valueSpan.textContent = renderDistance;
            }
            
            const sensSlider = document.getElementById('sensitivitySlider');
            const sensValueSpan = document.getElementById('sensitivityValue');
            if (sensSlider && sensValueSpan) {
                sensSlider.value = mouseSensitivity * 100;
                sensValueSpan.textContent = Math.round(mouseSensitivity * 100);
            }
            
            const fovSlider = document.getElementById('fovSlider');
            const fovValueSpan = document.getElementById('fovValue');
            if (fovSlider && fovValueSpan) {
                fovSlider.value = fieldOfView;
                fovValueSpan.textContent = fieldOfView;
            }
            
            // Initialize Master Volume Slider
            const masterSlider = document.getElementById('masterVolumeSlider');
            const masterValueSpan = document.getElementById('masterVolumeValue');
            if (masterSlider && masterValueSpan) {
                masterSlider.value = masterVolume * 100;
                masterValueSpan.textContent = Math.round(masterVolume * 100);
            }
            
            // Initialize Music Volume Slider
            const musicSlider = document.getElementById('musicVolumeSlider');
            const musicValueSpan = document.getElementById('musicVolumeValue');
            if (musicSlider && musicValueSpan) {
                musicSlider.value = musicVolume * 100;
                musicValueSpan.textContent = Math.round(musicVolume * 100);
            }
            
            // Initialize SFX Volume Slider
            const sfxSlider = document.getElementById('sfxVolumeSlider');
            const sfxValueSpan = document.getElementById('sfxVolumeValue');
            if (sfxSlider && sfxValueSpan) {
                sfxSlider.value = sfxVolume * 100;
                sfxValueSpan.textContent = Math.round(sfxVolume * 100);
            }
            
            // Initialize Tab Out Mute Slider
            const tabOutSlider = document.getElementById('tabOutMuteSlider');
            const tabOutValueSpan = document.getElementById('tabOutMuteValue');
            if (tabOutSlider && tabOutValueSpan) {
                tabOutSlider.value = Math.round(tabOutMuteLevel * 100);
                tabOutValueSpan.textContent = Math.round(tabOutMuteLevel * 100);
            }
            
            showView('settings-view');
        });
        
        // Respawn button
        respawnButton.addEventListener('click', function() {
            // Immediately execute the respawn action
            resetPlayer();
            togglePause();
        });
        
        // Death screen respawn button
        document.getElementById('death-respawn-btn').addEventListener('click', function() {
            resetPlayer();
            // Request pointer lock again and show crosshair
            requestLock(renderer.domElement);
            document.getElementById('crosshair').style.display = 'block';
            paused = false;
        });
        
        // NEW: Exit to Menu button with save prompt
        document.getElementById('exit-to-menu-btn').addEventListener('click', function() { 
            if (currentWorldName) {
                const shouldSave = confirm('Do you want to save your world before exiting?');
                if (shouldSave) {
                    saveWorld(currentWorldName);
                }
            }
            stopAutoSave();
            window.location.reload(); 
        });

        // --- Menu View Switching Logic (Unchanged) ---
        // Function to reset button positions and transforms
        function resetMainMenuButtonTransforms() {
            mainMenuButtons.forEach(button => {
                button.style.transform = '';
                button.style.boxShadow = '';
            });
            if (mainMenuTitle) {
                mainMenuTitle.style.transform = '';
                mainMenuTitle.style.textShadow = '';
            }
        }
        
        function showView(viewId) {
            // Set appropriate game state based on view
            if (viewId === 'main-controls') {
                setGameState(GAME_STATE.MAIN_MENU);
            } else if (viewId === 'creation-view') {
                setGameState(GAME_STATE.CREATE_WORLD);
            } else if (viewId === 'saved-worlds-view') {
                setGameState(GAME_STATE.SAVED_WORLDS);
            } else if (viewId === 'credits-view') {
                setGameState(GAME_STATE.CREDITS);
            } else if (viewId === 'settings-view' || viewId === 'video-settings-view' || 
                       viewId === 'audio-settings-view' || viewId === 'controls-settings-view' || 
                       viewId === 'theme-settings-view') {
                setGameState(GAME_STATE.SETTINGS);
            }
            
            // Reset button transforms when leaving main-controls OR entering submenus
            const currentView = document.querySelector('#main-menu .menu-view[style*="display: flex"]');
            if (currentView && currentView.id === 'main-controls' && viewId !== 'main-controls') {
                resetMainMenuButtonTransforms();
            }
            
            // Also reset when entering creation, saved worlds, or settings
            if (['creation-view', 'saved-worlds-view', 'settings-view'].includes(viewId)) {
                resetMainMenuButtonTransforms();
            }
            
            // Show/hide fixed back buttons
            const backFromSettingsBtn = document.getElementById('backFromSettingsBtn');
            const backToSettingsBtn = document.getElementById('backToSettingsBtn');
            
            if (viewId === 'settings-view') {
                backFromSettingsBtn.style.display = 'block';
                backToSettingsBtn.style.display = 'none';
            } else {
                backFromSettingsBtn.style.display = 'none';
                backToSettingsBtn.style.display = 'none';
            }
            
            // Apply parallax animation to specific views
            const mainMenu = document.getElementById('main-menu');
            const viewsWithParallax = ['creation-view', 'saved-worlds-view', 'settings-view', 'credits-view', 'video-settings-view', 'controls-settings-view', 'audio-settings-view', 'theme-settings-view'];
            
            if (viewsWithParallax.includes(viewId)) {
                // Disable parallax if we came from pause menu (in-game)
                if (openedSettingsFromPause) {
                    mainMenu.style.animation = 'none';
                    mainMenu.style.backgroundColor = 'rgba(0, 0, 0, 0)';
                } else if (viewId === 'credits-view') {
                    // Consistent background for credits
                    mainMenu.style.animation = 'bgParallaxFast 30s linear infinite';
                    mainMenu.style.backgroundColor = 'rgba(0, 0, 0, 0)';
                } else {
                    // Normal parallax for other views - consistent background
                    mainMenu.style.animation = `bgParallax ${currentParallaxSpeed}s linear infinite`;
                    mainMenu.style.backgroundColor = 'rgba(0, 0, 0, 0)';
                }
            } else if (viewId === 'main-controls') {
                // Reset to default for main menu
                mainMenu.style.animation = 'bgParallax 120s linear infinite';
                mainMenu.style.backgroundColor = 'rgba(0, 0, 0, 0)';
            }
            
            // Hide all views first
            document.querySelectorAll('#main-menu .menu-view').forEach(view => { 
                view.style.display = 'none';
                view.classList.remove('menu-animate');
            });
            
            // Show the selected view with animation
            const targetView = document.getElementById(viewId);
            targetView.style.display = 'flex';
            
            // Apply enhanced frame styling if opened from pause menu (in-game)
            if (openedSettingsFromPause && targetView.id !== 'main-controls') {
                targetView.style.background = 'rgba(25, 50, 30, 0.95)';
                targetView.style.border = '6px solid rgba(140, 220, 100, 0.9)';
                targetView.style.outline = '3px solid rgba(0, 0, 0, 0.8)';
                targetView.style.outlineOffset = '-9px';
                targetView.style.boxShadow = '0 12px 0 0 rgba(0, 0, 0, 0.6), 0 0 40px rgba(0, 0, 0, 0.8), inset 0 0 60px rgba(0, 0, 0, 0.4)';
            }
            
            // Trigger animation after a tiny delay to ensure display is set
            setTimeout(() => {
                targetView.classList.add('menu-animate');
            }, 10);
            
            // Reset button transforms when returning to main-controls
            if (viewId === 'main-controls') {
                // Small delay to ensure display is set before resetting
                setTimeout(() => {
                    resetMainMenuButtonTransforms();
                }, 10);
            }
        }
        
        // --- Settings Category Navigation ---
        function showSettingsCategory(category) {
            // Set state to SETTINGS
            setGameState(GAME_STATE.SETTINGS);
            
            // Hide FPS when entering settings
            const fpsElement = document.getElementById('fps');
            if (fpsElement) fpsElement.style.display = 'none';
            
            // Hide all settings views
            document.querySelectorAll('#main-menu .menu-view').forEach(view => { 
                view.style.display = 'none';
                view.classList.remove('menu-animate');
            });
            
            // Show the category view
            let categoryView;
            if (category === 'video') {
                categoryView = document.getElementById('video-settings-view');
            } else if (category === 'controls') {
                categoryView = document.getElementById('controls-settings-view');
            } else if (category === 'audio') {
                categoryView = document.getElementById('audio-settings-view');
            } else if (category === 'theme') {
                categoryView = document.getElementById('theme-settings-view');
            }
            
            if (categoryView) {
                categoryView.style.display = 'flex';
                
                // Apply enhanced frame styling if opened from pause menu (in-game)
                if (openedSettingsFromPause) {
                    categoryView.style.background = 'rgba(25, 50, 30, 0.95)';
                    categoryView.style.border = '6px solid rgba(140, 220, 100, 0.9)';
                    categoryView.style.outline = '3px solid rgba(0, 0, 0, 0.8)';
                    categoryView.style.outlineOffset = '-9px';
                    categoryView.style.boxShadow = '0 12px 0 0 rgba(0, 0, 0, 0.6), 0 0 40px rgba(0, 0, 0, 0.8), inset 0 0 60px rgba(0, 0, 0, 0.4)';
                }
                
                setTimeout(() => {
                    categoryView.classList.add('menu-animate');
                }, 10);
            }
            
            // Show the "Back to Settings" button for detailed settings
            const backFromSettingsBtn = document.getElementById('backFromSettingsBtn');
            const backToSettingsBtn = document.getElementById('backToSettingsBtn');
            backFromSettingsBtn.style.display = 'none';
            backToSettingsBtn.style.display = 'block';
            
            // Reset button transforms
            resetMainMenuButtonTransforms();

            // Ensure audio sliders reflect current saved values when opening Audio tab
            if (category === 'audio') {
                const masterSlider = document.getElementById('masterVolumeSlider');
                const masterValueSpan = document.getElementById('masterVolumeValue');
                if (masterSlider && masterValueSpan) {
                    masterSlider.value = Math.round(masterVolume * 100);
                    masterValueSpan.textContent = Math.round(masterVolume * 100);
                }
                const musicSlider = document.getElementById('musicVolumeSlider');
                const musicValueSpan = document.getElementById('musicVolumeValue');
                if (musicSlider && musicValueSpan) {
                    musicSlider.value = Math.round(musicVolume * 100);
                    musicValueSpan.textContent = Math.round(musicVolume * 100);
                }
                const sfxSlider = document.getElementById('sfxVolumeSlider');
                const sfxValueSpan = document.getElementById('sfxVolumeValue');
                if (sfxSlider && sfxValueSpan) {
                    sfxSlider.value = Math.round(sfxVolume * 100);
                    sfxValueSpan.textContent = Math.round(sfxVolume * 100);
                }
                const tabOutSlider = document.getElementById('tabOutMuteSlider');
                const tabOutValueSpan = document.getElementById('tabOutMuteValue');
                if (tabOutSlider && tabOutValueSpan) {
                    tabOutSlider.value = Math.round(tabOutMuteLevel * 100);
                    tabOutValueSpan.textContent = Math.round(tabOutMuteLevel * 100);
                }
            }

            playClickSound();
        }
        
        function backToSettingsMenu() {
            // Still in settings, just going back to settings main menu
            setGameState(GAME_STATE.SETTINGS);
            
            // Hide FPS when in settings
            const fpsElement = document.getElementById('fps');
            if (fpsElement) fpsElement.style.display = 'none';
            
            // Hide all category views
            document.querySelectorAll('#main-menu .menu-view').forEach(view => { 
                view.style.display = 'none';
                view.classList.remove('menu-animate');
            });
            
            // Show main settings menu with animation
            const settingsView = document.getElementById('settings-view');
            settingsView.style.display = 'flex';
            
            // Show the main settings back button, hide category back button
            const backFromSettingsBtn = document.getElementById('backFromSettingsBtn');
            const backToSettingsBtn = document.getElementById('backToSettingsBtn');
            backFromSettingsBtn.style.display = 'block';
            backToSettingsBtn.style.display = 'none';
            
            // Trigger animation
            setTimeout(() => {
                settingsView.classList.add('menu-animate');
            }, 10);
            
            // Reset button transforms
            resetMainMenuButtonTransforms();
            
            // Clear search when returning
            const searchInput = document.getElementById('settingsSearchInput');
            if (searchInput) {
                searchInput.value = '';
            }
            
            playClickSound();
        }
        
        
        // Blur functionality removed - using solid grey backgrounds only
        
        
        // Wrapper functions for detailed settings buttons
        function showVideoSettings() {
            showSettingsCategory('video');
        }
        
        function showControlSettings() {
            showSettingsCategory('controls');
        }
        
        function showAudioSettings() {
            showSettingsCategory('audio');
        }
        
        function showThemeSettings() {
            showSettingsCategory('theme');
        }
        
        // Theme customization - using solid grey only
        let currentParallaxColor = 'transparent';
        let currentParallaxSpeed = 120;
        
        function setParallaxColor(color) {
            currentParallaxColor = color;
            const mainMenu = document.getElementById('main-menu');
            const currentView = document.querySelector('#main-menu .menu-view[style*="display: flex"]');
            
            // Update immediately if not in credits or main-controls
            if (currentView && currentView.id !== 'main-controls' && currentView.id !== 'credits-view') {
                mainMenu.style.backgroundColor = color;
            }
            
            // Visual feedback - highlight selected button
            document.querySelectorAll('.theme-color-btn').forEach(btn => {
                btn.style.border = '3px solid #666';
                btn.style.transform = 'scale(1)';
            });
            event.target.style.border = '3px solid var(--main-action)';
            event.target.style.transform = 'scale(1.1)';
            
            playClickSound();
        }
        
        function setMenuStyle(style, event) {
            // Menu style setting removed - always using dark green translucent
            const mainControls = document.getElementById('main-controls');
            
            mainControls.style.background = 'rgba(25, 50, 30, 0.85)';
            
            playClickSound();
        }
        
        function resetThemeSettings() {
            currentParallaxColor = 'transparent';
            currentParallaxSpeed = 120;
            
            const mainMenu = document.getElementById('main-menu');
            mainMenu.style.backgroundColor = currentParallaxColor;
            
            const mainControls = document.getElementById('main-controls');
            mainControls.style.background = 'rgba(25, 50, 30, 0.85)';
            
            const speedSlider = document.getElementById('parallaxSpeedSlider');
            const speedValue = document.getElementById('parallaxSpeedValue');
            if (speedSlider && speedValue) {
                speedSlider.value = 120;
                speedValue.textContent = '120';
            }
            
            // Reset button highlights
            document.querySelectorAll('.theme-color-btn').forEach(btn => {
                btn.style.border = '3px solid #666';
                btn.style.transform = 'scale(1)';
            });
            
            playClickSound();
        }
        
        // Settings Search Filter Function - Enhanced with auto-navigation
        function filterSettings(searchTerm) {
            searchTerm = searchTerm.toLowerCase().trim();
            
            // Get all settings views
            const views = [
                { id: 'video-settings-view', name: 'video' },
                { id: 'controls-settings-view', name: 'controls' },
                { id: 'audio-settings-view', name: 'audio' },
                { id: 'theme-settings-view', name: 'theme' }
            ];
            
            if (!searchTerm) {
                // If search is empty, show all settings and return to main menu
                views.forEach(view => {
                    const viewElement = document.getElementById(view.id);
                    if (viewElement) {
                        viewElement.querySelectorAll('.setting-item').forEach(item => {
                            item.style.display = '';
                        });
                    }
                });
                return;
            }
            
            let resultsFound = false;
            let firstMatchView = null;
            let matchCounts = {};
            
            // Search through all settings and count matches per view
            views.forEach(view => {
                const viewElement = document.getElementById(view.id);
                if (viewElement) {
                    let viewMatches = 0;
                    const settingItems = viewElement.querySelectorAll('.setting-item');
                    
                    settingItems.forEach(item => {
                        const label = item.querySelector('.setting-label');
                        const description = item.querySelector('.setting-description');
                        
                        const labelText = label ? label.textContent.toLowerCase() : '';
                        const descText = description ? description.textContent.toLowerCase() : '';
                        
                        if (labelText.includes(searchTerm) || descText.includes(searchTerm)) {
                            item.style.display = '';
                            viewMatches++;
                            resultsFound = true;
                            if (!firstMatchView) {
                                firstMatchView = view.name;
                            }
                        } else {
                            item.style.display = 'none';
                        }
                    });
                    
                    matchCounts[view.name] = viewMatches;
                }
            });
            
            // Auto-navigate to the view with most matches
            if (resultsFound && firstMatchView) {
                // Find view with most matches
                let bestView = firstMatchView;
                let maxMatches = matchCounts[firstMatchView] || 0;
                
                Object.keys(matchCounts).forEach(viewName => {
                    if (matchCounts[viewName] > maxMatches) {
                        maxMatches = matchCounts[viewName];
                        bestView = viewName;
                    }
                });
                
                // Navigate to the best matching view
                showSettingsCategory(bestView);
            }
        }
        
        document.getElementById('showCreationBtn').addEventListener('click', function() { showView('creation-view'); });
        document.getElementById('showSavedWorldsBtn').addEventListener('click', function() { 
            displaySavedWorlds(); 
            showView('saved-worlds-view'); 
        });
        document.getElementById('showSettingsBtn').addEventListener('click', function() {
            // NEW: Initialize Render Distance Slider (view distance, not world size)
            const slider = document.getElementById('renderDistanceSlider');
            const valueSpan = document.getElementById('renderDistanceValue');
            if (slider && valueSpan) {
                slider.value = renderDistance;
                valueSpan.textContent = renderDistance;
            }
            
            // Initialize Sensitivity Slider
            const sensSlider = document.getElementById('sensitivitySlider');
            const sensValueSpan = document.getElementById('sensitivityValue');
            if (sensSlider && sensValueSpan) {
                sensSlider.value = mouseSensitivity * 100;
                sensValueSpan.textContent = Math.round(mouseSensitivity * 100);
            }
            
            // Initialize FOV Slider
            const fovSlider = document.getElementById('fovSlider');
            const fovValueSpan = document.getElementById('fovValue');
            if (fovSlider && fovValueSpan) {
                fovSlider.value = fieldOfView;
                fovValueSpan.textContent = fieldOfView;
            }
            
            // Initialize Master Volume Slider
            const masterSlider = document.getElementById('masterVolumeSlider');
            const masterValueSpan = document.getElementById('masterVolumeValue');
            if (masterSlider && masterValueSpan) {
                masterSlider.value = masterVolume * 100;
                masterValueSpan.textContent = Math.round(masterVolume * 100);
            }
            
            // Initialize Music Volume Slider
            const musicSlider = document.getElementById('musicVolumeSlider');
            const musicValueSpan = document.getElementById('musicVolumeValue');
            if (musicSlider && musicValueSpan) {
                musicSlider.value = musicVolume * 100;
                musicValueSpan.textContent = Math.round(musicVolume * 100);
            }
            
            // Initialize SFX Volume Slider
            const sfxSlider = document.getElementById('sfxVolumeSlider');
            const sfxValueSpan = document.getElementById('sfxVolumeValue');
            if (sfxSlider && sfxValueSpan) {
                sfxSlider.value = sfxVolume * 100;
                sfxValueSpan.textContent = Math.round(sfxVolume * 100);
            }
            
            // Initialize Tab Out Mute Slider
            const tabOutSlider = document.getElementById('tabOutMuteSlider');
            const tabOutValueSpan = document.getElementById('tabOutMuteValue');
            if (tabOutSlider && tabOutValueSpan) {
                tabOutSlider.value = Math.round(tabOutMuteLevel * 100);
                tabOutValueSpan.textContent = Math.round(tabOutMuteLevel * 100);
            }
            // END NEW

            showView('settings-view');
        });
        document.getElementById('showCreditsBtn').addEventListener('click', function() { 
            showView('credits-view'); 
            initCreditsTracking();
            // Music visualizer removed from credits
        });
        document.getElementById('backFromCreationBtn').addEventListener('click', function() { showView('main-controls'); });
        document.getElementById('backFromSettingsBtn').addEventListener('click', function() { 
            // Persist any pending changes before leaving settings
            saveSettings();
            // Check if we came from pause menu
            if (openedSettingsFromPause) {
                // Reset flag
                openedSettingsFromPause = false;
                
                // Going back to pause menu
                setGameState(GAME_STATE.PAUSE_MENU);
                
                // Hide main menu and reset styling
                const mainMenu = document.getElementById('main-menu');
                mainMenu.style.display = 'none';
                mainMenu.classList.remove('in-game-overlay'); // Remove overlay class
                mainMenu.classList.remove('inventory-animate'); // Remove animation class
                mainMenu.style.animation = 'bgParallax 120s linear infinite';
                
                // Show pause menu again with animation
                pauseMenu.style.display = 'flex';
                pauseMenu.classList.remove('inventory-animate');
                setTimeout(() => {
                    pauseMenu.classList.add('inventory-animate');
                }, 10);
            } else {
                // Regular flow: go back to main menu
                setGameState(GAME_STATE.MAIN_MENU);
                
                // Reset main menu styling for main menu view
                const mainMenu = document.getElementById('main-menu');
                mainMenu.classList.remove('in-game-overlay'); // Remove overlay class
                mainMenu.classList.remove('inventory-animate'); // Remove animation class
                mainMenu.style.animation = 'bgParallax 120s linear infinite';
                showView('main-controls');
            }
        });
        document.getElementById('backFromSavedWorldsBtn').addEventListener('click', function() { showView('main-controls'); });
        document.getElementById('deleteAllWorldsBtn').addEventListener('click', function() { startDeleteAllWorlds(); });
        document.getElementById('backFromCreditsBtn').addEventListener('click', function() { 
            showView('main-controls');
            disableCreditsTracking();
            // Music visualizer removed from credits
        });
        
        // ==================== CREDITS WINDOW TRACKING & EFFECTS ====================
        let creditsTrackingEnabled = false;
        let creditsContainer = null;
        let visualizerInterval = null;
        let easterEggClicks = 0;
        let easterEggTimer = null;
        let lastMouseX = window.innerWidth / 2;
        let lastMouseY = window.innerHeight / 2;
        
        function initCreditsTracking() {
            creditsTrackingEnabled = true;
            creditsContainer = document.querySelector('.credits-container');
            
            // Track globally on document (works anywhere in the window)
            document.addEventListener('mousemove', handleCreditsTracking);
            
            // Track mouse position even when it leaves the window
            document.addEventListener('mouseout', handleMouseLeave);
            document.addEventListener('mouseleave', handleMouseLeave);
            
            // Setup easter eggs
            setupEasterEggs();
        }
        
        function disableCreditsTracking() {
            creditsTrackingEnabled = false;
            
            // Remove global listeners
            document.removeEventListener('mousemove', handleCreditsTracking);
            document.removeEventListener('mouseout', handleMouseLeave);
            document.removeEventListener('mouseleave', handleMouseLeave);
            
            // Reset container position
            if (creditsContainer) {
                creditsContainer.style.transform = 'perspective(1500px) rotateX(0deg) rotateY(0deg) translateZ(0px)';
                creditsContainer.style.filter = 'none';
            }
        }
        
        function handleMouseLeave(e) {
            // When mouse leaves the window, keep using the last known position
            if (!creditsTrackingEnabled || !creditsContainer) return;
            
            // Continue tracking with the edge position
            if (e.clientX !== undefined) {
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
            
            updateCreditsPosition(lastMouseX, lastMouseY);
        }
        
        function handleCreditsTracking(e) {
            if (!creditsTrackingEnabled || !creditsContainer) return;
            
            // Update last known position
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            
            updateCreditsPosition(lastMouseX, lastMouseY);
        }
        
        function updateCreditsPosition(mouseX, mouseY) {
            if (!creditsContainer) return;
            
            const rect = creditsContainer.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            const deltaX = mouseX - centerX;
            const deltaY = mouseY - centerY;
            
            // Calculate rotation (make entire container "look" at mouse)
            const maxRotation = 15; // degrees
            const rotateY = (deltaX / window.innerWidth) * maxRotation;
            const rotateX = -(deltaY / window.innerHeight) * maxRotation;
            
            // Apply transform to container
            creditsContainer.style.transform = `
                perspective(1500px)
                rotateX(${rotateX}deg)
                rotateY(${rotateY}deg)
                translateZ(20px)
            `;
            
            // Add dynamic shadow based on rotation
            const shadowX = rotateY * 2;
            const shadowY = -rotateX * 2;
            creditsContainer.style.filter = `
                drop-shadow(${shadowX}px ${shadowY}px 30px rgba(121, 192, 90, 0.4))
            `;
        }
        
        // ==================== MUSIC VISUALIZER ====================
        function initMusicVisualizer() {
            const visualizerContainer = document.querySelector('.music-visualizer');
            if (!visualizerContainer) return;
            
            visualizerContainer.style.display = 'flex';
            
            // Create bars
            const bars = visualizerContainer.querySelectorAll('.visualizer-bar');
            
            // Animate bars with random heights
            visualizerInterval = setInterval(() => {
                bars.forEach((bar, index) => {
                    const height = Math.random() * 80 + 20; // 20-100%
                    const delay = index * 50;
                    setTimeout(() => {
                        bar.style.height = height + '%';
                    }, delay);
                });
            }, 200);
        }
        
        function stopMusicVisualizer() {
            if (visualizerInterval) {
                clearInterval(visualizerInterval);
                visualizerInterval = null;
            }
            const visualizerContainer = document.querySelector('.music-visualizer');
            if (visualizerContainer) {
                visualizerContainer.style.display = 'none';
            }
        }
        
        // ==================== EASTER EGGS ====================
        function setupEasterEggs() {
            const creditsView = document.getElementById('credits-view');
            const creditIcons = document.querySelectorAll('.credit-icon');
            
            // Easter Egg 1: Click icons 5 times quickly to unlock secret mode
            creditIcons.forEach(icon => {
                icon.addEventListener('click', function() {
                    easterEggClicks++;
                    
                    // Visual feedback
                    this.style.transform = 'scale(1.5) rotate(360deg)';
                    setTimeout(() => {
                        this.style.transform = '';
                    }, 300);
                    
                    if (easterEggClicks >= 5) {
                        activateEasterEgg1();
                        easterEggClicks = 0;
                    }
                    
                    // Reset counter after 2 seconds
                    clearTimeout(easterEggTimer);
                    easterEggTimer = setTimeout(() => {
                        easterEggClicks = 0;
                    }, 2000);
                });
            });
            
            // Easter Egg 2: Konami Code (up, up, down, down, left, right, left, right)
            let konamiCode = [];
            const konamiSequence = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight'];
            
            document.addEventListener('keydown', function(e) {
                if (!creditsTrackingEnabled) return;
                
                konamiCode.push(e.key);
                if (konamiCode.length > konamiSequence.length) {
                    konamiCode.shift();
                }
                
                if (JSON.stringify(konamiCode) === JSON.stringify(konamiSequence)) {
                    activateEasterEgg2();
                    konamiCode = [];
                }
            });
            
            // Easter Egg 3: Double-click the title
            const creditsTitle = document.querySelector('.credits-title');
            if (creditsTitle) {
                creditsTitle.addEventListener('dblclick', activateEasterEgg3);
            }
        }
        
        function activateEasterEgg1() {
            console.log(' Easter Egg 1 Activated: Party Mode!');
            const creditsView = document.getElementById('credits-view');
            
            // Rainbow colors animation
            creditsView.style.animation = 'none';
            creditsView.style.background = 'linear-gradient(45deg, red, orange, yellow, green, blue, indigo, violet)';
            creditsView.style.backgroundSize = '400% 400%';
            creditsView.style.animation = 'bgParallax 3s ease infinite';
            
            // Show message
            showEasterEggMessage(' PARTY MODE ACTIVATED! ');
            
            // Reset after 5 seconds
            setTimeout(() => {
                creditsView.style.animation = 'creditsGlow 3s ease-in-out infinite';
                creditsView.style.background = '';
            }, 5000);
        }
        
        function activateEasterEgg2() {
            console.log(' Easter Egg 2 Activated: Konami Code!');
            const creditCards = document.querySelectorAll('.credit-card');
            
            // Make cards spin
            creditCards.forEach((card, index) => {
                setTimeout(() => {
                    card.style.animation = 'none';
                    card.style.transform = 'rotateY(720deg) scale(1.2)';
                    setTimeout(() => {
                        card.style.transform = '';
                        card.style.animation = 'creditsEntrance 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) forwards';
                    }, 1000);
                }, index * 200);
            });
            
            showEasterEggMessage(' KONAMI CODE!');
        }
        
        function activateEasterEgg3() {
            console.log(' Easter Egg 3 Activated: Secret Message!');
            const particles = document.querySelector('.credits-particles');
            
            // Create explosion effect
            if (particles) {
                for (let i = 0; i < 20; i++) {
                    const particle = document.createElement('div');
                    particle.style.position = 'absolute';
                    particle.style.width = '10px';
                    particle.style.height = '10px';
                    particle.style.background = `hsl(${Math.random() * 360}, 100%, 50%)`;
                    particle.style.borderRadius = '50%';
                    particle.style.left = '50%';
                    particle.style.top = '20%';
                    particle.style.animation = `particleFloat ${2 + Math.random() * 2}s ease-out forwards`;
                    particle.style.transform = `rotate(${Math.random() * 360}deg) translateX(${Math.random() * 200 - 100}px)`;
                    particles.appendChild(particle);
                    
                    setTimeout(() => particle.remove(), 3000);
                }
            }
            
            showEasterEggMessage(' You found the secret! You are a true gamer! ');
        }
        
        function showEasterEggMessage(message) {
            const existingMsg = document.querySelector('.easter-egg-message');
            if (existingMsg) existingMsg.remove();
            
            const msgDiv = document.createElement('div');
            msgDiv.className = 'easter-egg-message';
            msgDiv.textContent = message;
            msgDiv.style.position = 'fixed';
            msgDiv.style.top = '50%';
            msgDiv.style.left = '50%';
            msgDiv.style.transform = 'translate(-50%, -50%)';
            msgDiv.style.background = 'rgba(0, 0, 0, 0.9)';
            msgDiv.style.color = '#79C05A';
            msgDiv.style.padding = '30px 50px';
            msgDiv.style.borderRadius = '12px';
            msgDiv.style.border = '3px solid #79C05A';
            msgDiv.style.fontSize = '24px';
            msgDiv.style.fontWeight = 'bold';
            msgDiv.style.zIndex = '10000';
            msgDiv.style.animation = 'scale-in 0.5s ease-out';
            msgDiv.style.textAlign = 'center';
            msgDiv.style.boxShadow = '0 0 50px rgba(121, 192, 90, 0.8)';
            
            document.body.appendChild(msgDiv);
            
            setTimeout(() => {
                msgDiv.style.animation = 'scale-out 0.5s ease-out';
                setTimeout(() => msgDiv.remove(), 500);
            }, 3000);
        }
        // ==================== END CREDITS EFFECTS ====================
        
        // NEW: World Size Slider (in creation menu)
        const worldSizeSlider = document.getElementById('worldSizeSlider');
        const worldSizeValueSpan = document.getElementById('worldSizeValue');

        if (worldSizeSlider && worldSizeValueSpan) {
            worldSizeSlider.addEventListener('input', function() {
                ws = parseInt(this.value);
                worldSizeValueSpan.textContent = ws;
            });
            // Initial sync
            worldSizeSlider.value = ws;
            worldSizeValueSpan.textContent = ws;
        }

        // NEW: View Distance Slider (in settings menu) - separate from world size
        const renderDistanceSlider = document.getElementById('renderDistanceSlider');
        const renderDistanceValueSpan = document.getElementById('renderDistanceValue');

        if (renderDistanceSlider && renderDistanceValueSpan) {
            renderDistanceSlider.addEventListener('input', function() {
                renderDistance = parseInt(this.value);
                renderDistanceValueSpan.textContent = renderDistance;
                updateDefaultIndicator(renderDistance, DEFAULT_RENDER_DISTANCE, 'renderDistanceDefault');
                
                // Sync with quick settings
                const quickSlider = document.getElementById('quick-renderDistance');
                const quickValue = document.getElementById('quick-renderDistance-value');
                const quickDefault = document.getElementById('quick-renderDistance-default');
                if (quickSlider && quickValue) {
                    quickSlider.value = renderDistance;
                    quickValue.textContent = renderDistance + ' blocks';
                    if (quickDefault) {
                        quickDefault.style.color = renderDistance === DEFAULT_RENDER_DISTANCE ? '#79C05A' : 'transparent';
                    }
                }
                
                saveSettings(); // Save to localStorage
            });
            // Initial sync
            renderDistanceSlider.value = renderDistance;
            renderDistanceValueSpan.textContent = renderDistance;
            updateDefaultIndicator(renderDistance, DEFAULT_RENDER_DISTANCE, 'renderDistanceDefault');
        }
        
        // NEW: Mouse Sensitivity Slider
        const sensitivitySlider = document.getElementById('sensitivitySlider');
        const sensitivityValueSpan = document.getElementById('sensitivityValue');

        if (sensitivitySlider && sensitivityValueSpan) {
            sensitivitySlider.addEventListener('input', function() {
                const value = parseInt(this.value);
                mouseSensitivity = value / 100;
                sensitivityValueSpan.textContent = value;
                updateDefaultIndicator(value, DEFAULT_MOUSE_SENSITIVITY, 'sensitivityDefault');
                
                // Sync with quick settings
                const quickSlider = document.getElementById('quick-sensitivity');
                const quickValue = document.getElementById('quick-sensitivity-value');
                const quickDefault = document.getElementById('quick-sensitivity-default');
                if (quickSlider && quickValue) {
                    quickSlider.value = value;
                    quickValue.textContent = value + '%';
                    if (quickDefault) {
                        quickDefault.style.color = value === DEFAULT_MOUSE_SENSITIVITY ? '#79C05A' : 'transparent';
                    }
                }
                
                saveSettings(); // Save to localStorage
            });
            // Initial sync
            sensitivitySlider.value = mouseSensitivity * 100;
            sensitivityValueSpan.textContent = Math.round(mouseSensitivity * 100);
            updateDefaultIndicator(Math.round(mouseSensitivity * 100), DEFAULT_MOUSE_SENSITIVITY, 'sensitivityDefault');
        }
        
        // NEW: FOV Slider
        const fovSlider = document.getElementById('fovSlider');
        const fovValueSpan = document.getElementById('fovValue');

        if (fovSlider && fovValueSpan) {
            fovSlider.addEventListener('input', function() {
                fieldOfView = parseInt(this.value);
                fovValueSpan.textContent = fieldOfView;
                updateDefaultIndicator(fieldOfView, DEFAULT_FOV, 'fovDefault');
                camera.fov = fieldOfView;
                camera.updateProjectionMatrix();
                
                // Sync with quick settings
                const quickSlider = document.getElementById('quick-fov');
                const quickValue = document.getElementById('quick-fov-value');
                const quickDefault = document.getElementById('quick-fov-default');
                if (quickSlider && quickValue) {
                    quickSlider.value = fieldOfView;
                    quickValue.textContent = fieldOfView + '';
                    if (quickDefault) {
                        quickDefault.style.color = fieldOfView === DEFAULT_FOV ? '#79C05A' : 'transparent';
                    }
                }
                
                saveSettings(); // Save to localStorage
            });
            // Initial sync
            fovSlider.value = fieldOfView;
            fovValueSpan.textContent = fieldOfView;
            updateDefaultIndicator(fieldOfView, DEFAULT_FOV, 'fovDefault');
        }
        
        // NEW: Shadows Toggle
        const shadowsToggle = document.getElementById('shadowsToggle');
        if (shadowsToggle) {
            shadowsToggle.addEventListener('change', function() {
                shadowsEnabled = this.checked;
                renderer.shadowMap.enabled = shadowsEnabled;
                saveSettings();
            });
            // Initial sync
            shadowsToggle.checked = shadowsEnabled;
        }
        
        // NEW: Show Item in Hand Toggle
        const showHandToggle = document.getElementById('showHandToggle');
        if (showHandToggle) {
            showHandToggle.addEventListener('change', function() {
                showItemInHand = this.checked;
                saveSettings();
            });
            showHandToggle.checked = showItemInHand;
        }
        
        // NEW: Hand Bob Toggle
        const handBobToggle = document.getElementById('handBobToggle');
        if (handBobToggle) {
            handBobToggle.addEventListener('change', function() {
                handBobEnabled = this.checked;
                saveSettings();
            });
            handBobToggle.checked = handBobEnabled;
        }
        
        // NEW: FPS Always Visible Toggle
        const fpsToggle = document.getElementById('fpsAlwaysVisibleToggle');
        if (fpsToggle) {
            fpsToggle.addEventListener('change', function() {
                fpsAlwaysVisible = this.checked;
                const fpsElement = document.getElementById('fps');
                if (fpsElement) {
                    // Show FPS only when in game and setting is enabled
                    fpsElement.style.display = (fpsAlwaysVisible && currentGameState === GAME_STATE.IN_GAME) ? 'block' : (showHitbox ? 'block' : 'none');
                }
                saveSettings();
            });
            fpsToggle.checked = fpsAlwaysVisible;
        }
        
        // NEW: Player Skin Upload System
        const uploadSkinBtn = document.getElementById('uploadSkinBtn');
        const exportSkinBtn = document.getElementById('exportSkinBtn');
        const skinFileInput = document.getElementById('skinFileInput');
        const downloadSkinTemplate = document.getElementById('downloadSkinTemplate');
        const showSkinLayersToggle = document.getElementById('showSkinLayersToggle');
        const slimSkinToggle = document.getElementById('slimSkinToggle');
        
        // Slim skin toggle handler
        if (slimSkinToggle) {
            slimSkinToggle.addEventListener('change', function() {
                isSlimSkin = this.checked;
                createArms(); // Recreate arms with new dimensions
                
                // Update UV maps
                const armUVs = getArmUVMaps();
                skinUVMaps.rightArm = armUVs.rightArm;
                skinUVMaps.rightArmLayer = armUVs.rightArmLayer;
                skinUVMaps.leftArm = armUVs.leftArm;
                skinUVMaps.leftArmLayer = armUVs.leftArmLayer;
                
                // Save old texture dimensions before updating
                const oldTextureDimensions = texturePartDimensions;
                
                // Update texture dimensions for editor
                texturePartDimensions = getTexturePartDimensions();
                
                // Preserve and scale arm textures to new dimensions
                const armParts = ['leftArm', 'leftArmLayer', 'rightArm', 'rightArmLayer', 'fpHand'];
                armParts.forEach(part => {
                    if (modelTextures[part]) {
                        const oldTextureData = modelTextures[part];
                        modelTextures[part] = {};
                        
                        for (let side in texturePartDimensions[part]) {
                            const newDims = texturePartDimensions[part][side];
                            const oldDims = oldTextureDimensions[part][side];
                            
                            // Create canvas for new dimensions
                            const newCanvas = document.createElement('canvas');
                            newCanvas.width = newDims.w;
                            newCanvas.height = newDims.h;
                            const newCtx = newCanvas.getContext('2d');
                            
                            // If we have existing texture data, preserve it by scaling
                            if (oldTextureData[side]) {
                                // Create temporary canvas with old texture
                                const oldCanvas = document.createElement('canvas');
                                oldCanvas.width = oldDims.w;
                                oldCanvas.height = oldDims.h;
                                const oldCtx = oldCanvas.getContext('2d');
                                oldCtx.putImageData(oldTextureData[side], 0, 0);
                                
                                // Scale the old texture to new dimensions
                                // Use nearest-neighbor scaling to preserve pixelated look
                                newCtx.imageSmoothingEnabled = false;
                                newCtx.drawImage(oldCanvas, 0, 0, oldDims.w, oldDims.h, 0, 0, newDims.w, newDims.h);
                            } else {
                                // Initialize with default color only if no texture exists
                                if (part.includes('Layer')) {
                                    newCtx.clearRect(0, 0, newDims.w, newDims.h);
                                } else {
                                    newCtx.fillStyle = '#d4a574';
                                    newCtx.fillRect(0, 0, newDims.w, newDims.h);
                                }
                            }
                            
                            modelTextures[part][side] = newCtx.getImageData(0, 0, newDims.w, newDims.h);
                        }
                    }
                });
                
                // Reapply textures with new UV maps
                applyTexturesToModels();
                
                // Recreate first-person hand with new dimensions
                if (fpHandMesh) handScene.remove(fpHandMesh);
                fpHandMesh = createHandMesh();
                if (fpHandMesh) {
                    // Make hand bigger and move to bottom-right corner
                    fpHandMesh.scale.set(1.5, 1.5, 1.5); // 1.5x bigger
                    fpHandMesh.userData.basePosition = { x: 0.4, y: -0.35, z: -0.5 }; // Bottom-right corner (Minecraft style)
                    fpHandMesh.userData.baseRotation = { x: 0.15, y: -0.2, z: 0.0 }; // Natural arm holding position (Minecraft style)
                    fpHandMesh.position.set(0.4, -0.35, -0.5);
                    fpHandMesh.rotation.set(0.15, -0.2, 0.0);
                    fpHandMesh.visible = showItemInHand; // Show based on setting
                    handScene.add(fpHandMesh);
                    // Apply textures after creating
                    applyTexturesToModels();
                }
                
                saveSettings();
            });
            slimSkinToggle.checked = isSlimSkin;
        }
        
        if (uploadSkinBtn && skinFileInput) {
            uploadSkinBtn.addEventListener('click', function() {
                skinFileInput.click();
            });
            
            skinFileInput.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.onload = function() {
                        // Validate skin dimensions - support both 64x64 (modern) and 64x32 (pre-1.8 legacy)
                        if ((img.width === 64 && img.height === 64) || (img.width === 64 && img.height === 32)) {
                            const canvas = document.createElement('canvas');
                            canvas.width = 64;
                            canvas.height = 64; // Always use 64x64 internally
                            const ctx = canvas.getContext('2d');
                            
                            if (img.height === 32) {
                                // Legacy 64x32 format: duplicate top half to bottom half for layers
                                ctx.drawImage(img, 0, 0, 64, 32, 0, 0, 64, 32); // Top half
                                ctx.drawImage(img, 0, 0, 64, 32, 0, 32, 64, 32); // Duplicate to bottom half
                            } else {
                                // Modern 64x64 format
                                ctx.drawImage(img, 0, 0);
                            }
                            
                            const imageData = ctx.getImageData(0, 0, 64, 64);
                            const skinData = Array.from(imageData.data);
                            
                            // Helper function to extract region
                            function extractRegion(x, y, w, h) {
                                const regionCanvas = document.createElement('canvas');
                                regionCanvas.width = w;
                                regionCanvas.height = h;
                                const regionCtx = regionCanvas.getContext('2d');
                                regionCtx.drawImage(canvas, x, y, w, h, 0, 0, w, h);
                                return regionCanvas;
                            }
                            
                            // Apply base and layer textures to all body parts
                            // HEAD
                            if (headMesh) {
                                headMesh.material = createBodyPartMaterials(canvas, skinUVMaps.head, false);
                             }
                            // Remove old head layer if exists
                            if (headLayerMesh) {
                                playerModelGroup.remove(headLayerMesh);
                                headLayerMesh.geometry.dispose();
                                if (Array.isArray(headLayerMesh.material)) {
                                    headLayerMesh.material.forEach(m => m.dispose());
                                } else {
                                    headLayerMesh.material.dispose();
                                }
                            }
                            // Create new head layer (hat)
                             const headLayerGeometry = new THREE.BoxGeometry(0.52 * modelScale, 0.52 * modelScale, 0.52 * modelScale);
                             headLayerMesh = new THREE.Mesh(headLayerGeometry, createBodyPartMaterials(canvas, skinUVMaps.headLayer, true));
                             headLayerMesh.position.copy(headMesh.position);
                             headLayerMesh.visible = showSkinLayers;
                             headLayerMesh.renderOrder = 1;
                             playerModelGroup.add(headLayerMesh);
                            
                            // BODY
                             if (bodyMesh) {
                                 bodyMesh.material = createBodyPartMaterials(canvas, skinUVMaps.body, false);
                             }
                            // Remove old body layer if exists
                            if (bodyLayerMesh) {
                                playerModelGroup.remove(bodyLayerMesh);
                                bodyLayerMesh.geometry.dispose();
                                if (Array.isArray(bodyLayerMesh.material)) {
                                    bodyLayerMesh.material.forEach(m => m.dispose());
                                } else {
                                    bodyLayerMesh.material.dispose();
                                }
                            }
                             // Create new body layer (jacket)
                             const bodyLayerGeometry = new THREE.BoxGeometry(0.52 * modelScale, 0.77 * modelScale, 0.27 * modelScale);
                             bodyLayerMesh = new THREE.Mesh(bodyLayerGeometry, createBodyPartMaterials(canvas, skinUVMaps.bodyLayer, true));
                             bodyLayerMesh.position.copy(bodyMesh.position);
                             bodyLayerMesh.visible = showSkinLayers;
                             bodyLayerMesh.renderOrder = 1;
                             playerModelGroup.add(bodyLayerMesh);
                            
                            // RIGHT ARM
                             if (rightArm) {
                                 rightArm.material = createBodyPartMaterials(canvas, skinUVMaps.rightArm, false);
                             }
                            // Remove old right arm layer if exists
                            if (rightArmLayerMesh) {
                                rightArmPivot.remove(rightArmLayerMesh);
                                rightArmLayerMesh.geometry.dispose();
                                if (Array.isArray(rightArmLayerMesh.material)) {
                                    rightArmLayerMesh.material.forEach(m => m.dispose());
                                } else {
                                    rightArmLayerMesh.material.dispose();
                                }
                            }
                             // Create new right arm layer (sleeve) - adjust size based on slim skin
                             const rightArmLayerWidth = isSlimSkin ? 0.2075 * modelScale : 0.27 * modelScale;
                             const rightArmLayerGeometry = new THREE.BoxGeometry(rightArmLayerWidth, 0.77 * modelScale, 0.27 * modelScale);
                             rightArmLayerMesh = new THREE.Mesh(rightArmLayerGeometry, createBodyPartMaterials(canvas, skinUVMaps.rightArmLayer, true));
                             rightArmLayerMesh.position.copy(rightArm.position);
                             rightArmLayerMesh.visible = showSkinLayers;
                             rightArmLayerMesh.renderOrder = 1;
                             rightArmPivot.add(rightArmLayerMesh);
                            
                            // LEFT ARM
                             if (leftArm) {
                                 leftArm.material = createBodyPartMaterials(canvas, skinUVMaps.leftArm, false);
                             }
                            // Remove old left arm layer if exists
                            if (leftArmLayerMesh) {
                                leftArmPivot.remove(leftArmLayerMesh);
                                leftArmLayerMesh.geometry.dispose();
                                if (Array.isArray(leftArmLayerMesh.material)) {
                                    leftArmLayerMesh.material.forEach(m => m.dispose());
                                } else {
                                    leftArmLayerMesh.material.dispose();
                                }
                            }
                             // Create new left arm layer (sleeve) - adjust size based on slim skin
                             const leftArmLayerWidth = isSlimSkin ? 0.2075 * modelScale : 0.27 * modelScale;
                             const leftArmLayerGeometry = new THREE.BoxGeometry(leftArmLayerWidth, 0.77 * modelScale, 0.27 * modelScale);
                             leftArmLayerMesh = new THREE.Mesh(leftArmLayerGeometry, createBodyPartMaterials(canvas, skinUVMaps.leftArmLayer, true));
                             leftArmLayerMesh.position.copy(leftArm.position);
                             leftArmLayerMesh.visible = showSkinLayers;
                             leftArmLayerMesh.renderOrder = 1;
                             leftArmPivot.add(leftArmLayerMesh);
                            
                            // RIGHT LEG
                             if (rightLeg) {
                                 rightLeg.material = createBodyPartMaterials(canvas, skinUVMaps.rightLeg, false);
                             }
                            // Remove old right leg layer if exists
                            if (rightLegLayerMesh) {
                                rightLegPivot.remove(rightLegLayerMesh);
                                rightLegLayerMesh.geometry.dispose();
                                if (Array.isArray(rightLegLayerMesh.material)) {
                                    rightLegLayerMesh.material.forEach(m => m.dispose());
                                } else {
                                    rightLegLayerMesh.material.dispose();
                                }
                            }
                             // Create new right leg layer (pants)
                             const rightLegLayerGeometry = new THREE.BoxGeometry(0.27 * modelScale, 0.77 * modelScale, 0.27 * modelScale);
                             rightLegLayerMesh = new THREE.Mesh(rightLegLayerGeometry, createBodyPartMaterials(canvas, skinUVMaps.rightLegLayer, true));
                             rightLegLayerMesh.position.copy(rightLeg.position);
                             rightLegLayerMesh.visible = showSkinLayers;
                             rightLegLayerMesh.renderOrder = 1;
                             rightLegPivot.add(rightLegLayerMesh);
                            
                            // LEFT LEG
                             if (leftLeg) {
                                 leftLeg.material = createBodyPartMaterials(canvas, skinUVMaps.leftLeg, false);
                             }
                            // Remove old left leg layer if exists
                            if (leftLegLayerMesh) {
                                leftLegPivot.remove(leftLegLayerMesh);
                                leftLegLayerMesh.geometry.dispose();
                                if (Array.isArray(leftLegLayerMesh.material)) {
                                    leftLegLayerMesh.material.forEach(m => m.dispose());
                                } else {
                                    leftLegLayerMesh.material.dispose();
                                }
                            }
                             // Create new left leg layer (pants)
                             const leftLegLayerGeometry = new THREE.BoxGeometry(0.27 * modelScale, 0.77 * modelScale, 0.27 * modelScale);
                             leftLegLayerMesh = new THREE.Mesh(leftLegLayerGeometry, createBodyPartMaterials(canvas, skinUVMaps.leftLegLayer, true));
                             leftLegLayerMesh.position.copy(leftLeg.position);
                             leftLegLayerMesh.visible = showSkinLayers;
                             leftLegLayerMesh.renderOrder = 1;
                             leftLegPivot.add(leftLegLayerMesh);
                             
                             // Store the full skin texture for hand mesh
                            customSkinTexture = {
                                width: 64,
                                height: 64,
                                data: skinData
                            };
                            
                            // IMPORTANT: Extract and store texture data for the texture editor
                            // This makes the uploaded skin editable in the model customization system
                            if (!modelTextures) modelTextures = {};
                            
                            // Extract each body part's BASE and LAYER textures from the uploaded skin
                            const bodyPartMappings = {
                                'head': { base: skinUVMaps.head, layer: skinUVMaps.headLayer },
                                'torso': { base: skinUVMaps.body, layer: skinUVMaps.bodyLayer },
                                'leftArm': { base: skinUVMaps.leftArm, layer: skinUVMaps.leftArmLayer },
                                'rightArm': { base: skinUVMaps.rightArm, layer: skinUVMaps.rightArmLayer },
                                'leftLeg': { base: skinUVMaps.leftLeg, layer: skinUVMaps.leftLegLayer },
                                'rightLeg': { base: skinUVMaps.rightLeg, layer: skinUVMaps.rightLegLayer }
                            };
                            
                            for (let part in bodyPartMappings) {
                                const maps = bodyPartMappings[part];
                                
                                // Extract base layer textures
                                if (!modelTextures[part]) modelTextures[part] = {};
                                const sides = ['right', 'left', 'top', 'bottom', 'front', 'back'];
                                sides.forEach(side => {
                                    const uv = maps.base[side];
                                    const extractedCanvas = extractSkinRegion(canvas, uv.x, uv.y, uv.w, uv.h);
                                    const extractedCtx = extractedCanvas.getContext('2d');
                                    const extractedData = extractedCtx.getImageData(0, 0, uv.w, uv.h);
                                    modelTextures[part][side] = extractedData;
                                });
                                
                                // Extract outer layer textures (hat, jacket, sleeves, pants)
                                const layerPartName = part + 'Layer';
                                if (!modelTextures[layerPartName]) modelTextures[layerPartName] = {};
                                sides.forEach(side => {
                                    const uv = maps.layer[side];
                                    const extractedCanvas = extractSkinRegion(canvas, uv.x, uv.y, uv.w, uv.h);
                                    const extractedCtx = extractedCanvas.getContext('2d');
                                    const extractedData = extractedCtx.getImageData(0, 0, uv.w, uv.h);
                                    modelTextures[layerPartName][side] = extractedData;
                                });
                            }
                            
                            // Save the texture data to localStorage so it persists
                            saveModelTextures();
                            
                            saveSettings();
                            
                            // Recreate hand mesh with skin texture (including layer)
                            if (fpHandMesh) handScene.remove(fpHandMesh);
                            fpHandMesh = createHandMesh();
                            if (fpHandMesh) {
                                // Make hand bigger and move to bottom-right corner
                                fpHandMesh.scale.set(1.5, 1.5, 1.5); // 1.5x bigger
                                fpHandMesh.userData.basePosition = { x: 0.4, y: -0.35, z: -0.5 }; // Bottom-right corner (Minecraft style)
                                fpHandMesh.userData.baseRotation = { x: 0.15, y: -0.2, z: 0.0 }; // Natural arm holding position (Minecraft style)
                                fpHandMesh.position.set(0.4, -0.35, -0.5);
                                fpHandMesh.rotation.set(0.15, -0.2, 0.0);
                                fpHandMesh.visible = showItemInHand; // Show based on setting
                                handScene.add(fpHandMesh);
                                // Apply textures after creating
                                applyTexturesToModels();
                            }
                            
                            alert(' Skin uploaded successfully! Your custom Minecraft skin with all layers is now active.\n' + 
                                  (img.height === 32 ? '(Legacy 64x32 format - layers duplicated)' : '(Modern 64x64 format)'));
                            saveSettings(); // Save the uploaded skin
                        } else {
                            alert(' Invalid skin dimensions. Please use a 64x64 (modern) or 64x32 (legacy) PNG file following Minecraft skin format.');
                        }
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            });
        }
        
        // NEW: Export Skin System
        if (exportSkinBtn) {
            exportSkinBtn.addEventListener('click', function() {
                // Check if we have a custom skin to export
                if (!customSkinTexture || !customSkinTexture.data) {
                    alert(' No custom skin to export. Please upload a skin first or the default skin cannot be exported.');
                    return;
                }
                
                try {
                    // Create a canvas to reconstruct the skin
                    const canvas = document.createElement('canvas');
                    canvas.width = customSkinTexture.width;
                    canvas.height = customSkinTexture.height;
                    const ctx = canvas.getContext('2d');
                    
                    // Create ImageData from the stored skin data
                    const imageData = ctx.createImageData(canvas.width, canvas.height);
                    for (let i = 0; i < customSkinTexture.data.length; i++) {
                        imageData.data[i] = customSkinTexture.data[i];
                    }
                    ctx.putImageData(imageData, 0, 0);
                    
                    // Convert canvas to blob and download
                    canvas.toBlob(function(blob) {
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'minecraft-skin-' + Date.now() + '.png';
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        
                        alert(' Skin exported successfully! Check your downloads folder.');
                    }, 'image/png');
                } catch (error) {
                    console.error('Error exporting skin:', error);
                    alert(' Error exporting skin. Please try again.');
                }
            });
        }
        
        // Download skin template
        if (downloadSkinTemplate) {
            downloadSkinTemplate.addEventListener('click', function(e) {
                e.preventDefault();
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, 64, 64);
                ctx.strokeStyle = '#888888';
                ctx.lineWidth = 1;
                
                // Draw template guides
                ctx.strokeRect(0, 0, 32, 16); // Head layer 1
                ctx.strokeRect(32, 0, 32, 16); // Head layer 2
                ctx.strokeRect(16, 16, 24, 16); // Body layer 1
                ctx.strokeRect(16, 32, 24, 16); // Body layer 2
                ctx.strokeRect(40, 16, 16, 16); // Right arm
                ctx.strokeRect(32, 48, 16, 16); // Left arm
                ctx.strokeRect(0, 16, 16, 16); // Right leg
                ctx.strokeRect(16, 48, 16, 16); // Left leg
                
                canvas.toBlob(function(blob) {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'minecraft_skin_template.png';
                    a.click();
                    URL.revokeObjectURL(url);
                });
            });
        }
        
        // Skin layers toggle
        if (showSkinLayersToggle) {
            showSkinLayersToggle.addEventListener('change', function() {
                showSkinLayers = this.checked;
                saveSettings();
                
                // Update all layer visibility
                updateSkinLayers();
                
                // Recreate hand mesh to update its layer
                if (fpHandMesh) handScene.remove(fpHandMesh);
                fpHandMesh = createHandMesh();
                if (fpHandMesh && showItemInHand) {
                    // Make hand bigger and move to bottom-right corner
                    fpHandMesh.scale.set(1.5, 1.5, 1.5); // 1.5x bigger
                    fpHandMesh.userData.basePosition = { x: 0.4, y: -0.35, z: -0.5 }; // Bottom-right corner (Minecraft style)
                    fpHandMesh.userData.baseRotation = { x: 0.15, y: -0.2, z: 0.0 }; // Natural arm holding position (Minecraft style)
                    fpHandMesh.position.set(0.4, -0.35, -0.5);
                    fpHandMesh.rotation.set(0.15, -0.2, 0.0);
                    handScene.add(fpHandMesh);
                }
            });
            showSkinLayersToggle.checked = showSkinLayers;
        }
        
        // NEW: Hand Bob Intensity Slider
        const handBobIntensitySlider = document.getElementById('handBobIntensitySlider');
        const handBobIntensityValueSpan = document.getElementById('handBobIntensityValue');
        
        if (handBobIntensitySlider && handBobIntensityValueSpan) {
            handBobIntensitySlider.addEventListener('input', function() {
                handBobIntensity = parseInt(this.value);
                handBobIntensityValueSpan.textContent = handBobIntensity;
                updateDefaultIndicator(handBobIntensity, DEFAULT_HAND_BOB_INTENSITY, 'handBobIntensityDefault');
                
                // Sync with quick settings
                const quickSlider = document.getElementById('quick-handBob');
                const quickValue = document.getElementById('quick-handBob-value');
                const quickDefault = document.getElementById('quick-handBob-default');
                if (quickSlider && quickValue) {
                    quickSlider.value = handBobIntensity;
                    quickValue.textContent = handBobIntensity + '%';
                    if (quickDefault) {
                        quickDefault.style.color = handBobIntensity === DEFAULT_HAND_BOB_INTENSITY ? '#79C05A' : 'transparent';
                    }
                }
                
                saveSettings();
            });
            handBobIntensitySlider.value = handBobIntensity;
            handBobIntensityValueSpan.textContent = handBobIntensity;
            updateDefaultIndicator(handBobIntensity, DEFAULT_HAND_BOB_INTENSITY, 'handBobIntensityDefault');
        }
        
        // --- KEYBIND CUSTOMIZATION SYSTEM ---
        
        // Open keybinds modal
        const openKeybindsModalBtn = document.getElementById('openKeybindsModalBtn');
        const keybindsModal = document.getElementById('keybinds-modal');
        const closeKeybindsModalBtn = document.getElementById('closeKeybindsModalBtn');
        
        if (openKeybindsModalBtn && keybindsModal) {
            openKeybindsModalBtn.addEventListener('click', function() {
                keybindsModal.style.display = 'flex';
                initKeybindButtons();
                playClickSound();
            });
        }
        
        if (closeKeybindsModalBtn && keybindsModal) {
            closeKeybindsModalBtn.addEventListener('click', function() {
                keybindsModal.style.display = 'none';
                if (waitingForKey) {
                    waitingForKey.textContent = getKeyDisplay(keybinds[waitingForKey.dataset.action]);
                    waitingForKey.style.background = 'rgba(0, 191, 255, 0.2)';
                    waitingForKey = null;
                }
                playClickSound();
            });
        }
        
        function getKeyDisplay(code) {
            const keyMap = {
                'Space': 'SPACE',
                'ShiftLeft': 'SHIFT',
                'ShiftRight': 'R.SHIFT',
                'ControlLeft': 'CTRL',
                'ControlRight': 'R.CTRL',
                'AltLeft': 'ALT',
                'AltRight': 'R.ALT',
                'Escape': 'ESC',
                'Enter': 'ENTER',
                'Backspace': 'BKSP',
                'Tab': 'TAB',
                'CapsLock': 'CAPS',
                'ArrowUp': '',
                'ArrowDown': '',
                'ArrowLeft': '',
                'ArrowRight': ''
            };
            
            if (keyMap[code]) return keyMap[code];
            if (code.startsWith('Key')) return code.substring(3);
            if (code.startsWith('Digit')) return code.substring(5);
            return code;
        }
        
        // Initialize keybind buttons
        function initKeybindButtons() {
            document.querySelectorAll('.keybind-btn').forEach(btn => {
                const action = btn.dataset.action;
                btn.textContent = getKeyDisplay(keybinds[action]);
                
                btn.addEventListener('click', function(e) {
                    e.preventDefault();
                    if (waitingForKey) {
                        waitingForKey.textContent = getKeyDisplay(keybinds[waitingForKey.dataset.action]);
                        waitingForKey.style.background = 'rgba(0, 191, 255, 0.2)';
                    }
                    
                    waitingForKey = this;
                    this.textContent = 'Press any key...';
                    this.style.background = 'rgba(0, 191, 255, 0.6)';
                    this.style.borderColor = '#00bfff';
                    playClickSound();
                });
            });
        }
        
        // Reset keybinds button
        const resetKeybindsBtn = document.getElementById('resetKeybindsBtn');
        if (resetKeybindsBtn) {
            resetKeybindsBtn.addEventListener('click', function() {
                keybinds = {...DEFAULT_KEYBINDS};
                saveSettings();
                initKeybindButtons();
                playClickSound();
            });
        }
        
        // --- FULLSCREEN WITH KEYBOARD LOCK ---
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        let isFullscreen = false;
        
        async function enterFullscreen() {
            try {
                const elem = document.documentElement;
                
                // Request fullscreen with options to prevent accidental exit
                const options = { navigationUI: "hide" };
                
                if (elem.requestFullscreen) {
                    await elem.requestFullscreen(options);
                } else if (elem.webkitRequestFullscreen) {
                    await elem.webkitRequestFullscreen();
                } else if (elem.mozRequestFullScreen) {
                    await elem.mozRequestFullScreen();
                } else if (elem.msRequestFullscreen) {
                    await elem.msRequestFullscreen();
                }
                
                // Request keyboard lock to prevent browser shortcuts
                try {
                    if (navigator.keyboard && navigator.keyboard.lock) {
                        await navigator.keyboard.lock([
                            'KeyW', 'KeyA', 'KeyS', 'KeyD',
                            'Space', 'ShiftLeft', 'ShiftRight',
                            'ControlLeft', 'ControlRight',
                            'Escape', 'Tab', 'KeyE', 'F11'
                        ]);
                        console.log(' Keyboard lock activated');
                    }
                } catch (e) {
                    console.log(' Keyboard lock not supported:', e.message);
                }
                
                isFullscreen = true;
                if (fullscreenBtn) {
                    fullscreenBtn.textContent = 'EXIT FULLSCREEN';
                    fullscreenBtn.style.background = '#d9534f';
                }
                
                console.log(' Fullscreen activated');
            } catch (err) {
                console.error(' Fullscreen error:', err);
                alert('Fullscreen failed. Try pressing F11 or check browser settings.');
            }
        }
        
        async function exitFullscreen() {
            try {
                if (document.exitFullscreen) {
                    await document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    await document.webkitExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    await document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    await document.msExitFullscreen();
                }
                
                // Unlock keyboard
                if (navigator.keyboard && navigator.keyboard.unlock) {
                    try {
                        navigator.keyboard.unlock();
                        console.log(' Keyboard unlocked');
                    } catch (e) {
                        console.log(' Keyboard unlock error:', e.message);
                    }
                }
                
                isFullscreen = false;
                if (fullscreenBtn) {
                    fullscreenBtn.textContent = 'ENTER FULLSCREEN';
                    fullscreenBtn.style.background = 'var(--main-action)';
                }
                
                console.log(' Exited fullscreen');
            } catch (err) {
                console.error(' Exit fullscreen error:', err);
            }
        }
        
        if (fullscreenBtn) {
            fullscreenBtn.addEventListener('click', async function() {
                if (!isFullscreen) {
                    await enterFullscreen();
                } else {
                    await exitFullscreen();
                }
                playClickSound();
            });
        }
        
        // F11 key support for fullscreen toggle
        document.addEventListener('keydown', function(e) {
            if (e.key === 'F11') {
                e.preventDefault();
                if (!isFullscreen) {
                    enterFullscreen();
                } else {
                    exitFullscreen();
                }
            }
            
            // F3 key for debug hitbox and info visualization
            if (e.key === 'F3') {
                e.preventDefault();
                showHitbox = !showHitbox;
                hitboxWireframe.visible = showHitbox;
                
                // Show/hide debug info indicator
                const debugInfo = document.getElementById('debug-info');
                debugInfo.style.display = showHitbox ? 'block' : 'none';
                
                // Show/hide game info UI (Day, Time, Coordinates, etc.)
                const uiElement = document.getElementById('ui');
                if (uiElement) {
                    uiElement.style.display = showHitbox ? 'block' : 'none';
                }
                
                // Show/hide FPS based on settings and game state
                const fpsElement = document.getElementById('fps');
                if (fpsElement) {
                    // Show FPS when: (always visible setting + in game) OR debug mode is on
                    fpsElement.style.display = ((fpsAlwaysVisible && currentGameState === GAME_STATE.IN_GAME) || showHitbox) ? 'block' : 'none';
                }
                
                console.log('Debug mode: ' + (showHitbox ? 'ON' : 'OFF'));
            }
            
            // F5 key for perspective switching
            if (e.key === 'F5') {
                e.preventDefault();
                perspectiveMode = (perspectiveMode + 1) % 3;
                console.log('Perspective mode: ' + (perspectiveMode === 0 ? 'First Person' : perspectiveMode === 1 ? 'Third Person (Back)' : 'Third Person (Front)'));
            }
        }, true);
        
        // Handle fullscreen change events - Enhanced stability
        const handleFullscreenChange = () => {
            const fullscreenElement = document.fullscreenElement || 
                                     document.webkitFullscreenElement || 
                                     document.mozFullScreenElement || 
                                     document.msFullscreenElement;
            
            if (!fullscreenElement) {
                isFullscreen = false;
                if (fullscreenBtn) {
                    fullscreenBtn.textContent = 'ENTER FULLSCREEN';
                    fullscreenBtn.style.background = 'var(--main-action)';
                }
                if (navigator.keyboard && navigator.keyboard.unlock) {
                    try {
                        navigator.keyboard.unlock();
                    } catch (e) {
                        console.log('Keyboard unlock error:', e);
                    }
                }
            } else {
                isFullscreen = true;
                if (fullscreenBtn) {
                    fullscreenBtn.textContent = 'EXIT FULLSCREEN';
                    fullscreenBtn.style.background = '#d9534f';
                }
            }
        };
        
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.addEventListener('mozfullscreenchange', handleFullscreenChange);
        document.addEventListener('msfullscreenchange', handleFullscreenChange);
        
        // Prevent default behavior for common browser shortcuts when in game
        document.addEventListener('keydown', function(e) {
            if (locked && !paused) {
                // Prevent browser shortcuts when playing
                if (e.ctrlKey || e.metaKey) {
                    e.preventDefault();
                }
            }
        }, true);
        
        // Initialize keybind buttons on load
        initKeybindButtons();
        
        // ==================== AUDIO SLIDERS INITIALIZATION ====================
        // Initialize audio sliders with proper event listeners and saved values
        
        // Helper function to update default indicator
        function updateDefaultIndicator(value, defaultValue, indicatorId) {
            const indicator = document.getElementById(indicatorId);
            if (indicator) {
                indicator.style.display = (value === defaultValue) ? 'inline' : 'none';
            }
        }
        
        function initAudioSliders() {
            if (window.__audioSlidersInitialized) return;
            window.__audioSlidersInitialized = true;
            console.log(' INIT AUDIO SLIDERS - Current values:', {masterVolume, musicVolume, sfxVolume, tabOutMuteLevel});
            
            // Master Volume Slider
            const masterVolumeSlider = document.getElementById('masterVolumeSlider');
            const masterVolumeValueSpan = document.getElementById('masterVolumeValue');
            if (masterVolumeSlider && masterVolumeValueSpan) {
                // Set initial values from loaded settings
                masterVolumeSlider.value = masterVolume * 100;
                masterVolumeValueSpan.textContent = Math.round(masterVolume * 100);
                updateDefaultIndicator(Math.round(masterVolume * 100), DEFAULT_MASTER_VOLUME, 'masterVolumeDefault');
                console.log(' Set master volume slider to:', masterVolume * 100);
                
                // Add event listener
                masterVolumeSlider.addEventListener('input', function() {
                    const value = parseInt(this.value);
                    masterVolumeValueSpan.textContent = value;
                    updateDefaultIndicator(value, DEFAULT_MASTER_VOLUME, 'masterVolumeDefault');
                    updateMasterVolume(value);
                    saveSettings();
                });
            }
            
            // Music Volume Slider
            const musicVolumeSlider = document.getElementById('musicVolumeSlider');
            const musicVolumeValueSpan = document.getElementById('musicVolumeValue');

            if (musicVolumeSlider && musicVolumeValueSpan) {
                // Set initial values from loaded settings
                musicVolumeSlider.value = musicVolume * 100;
                musicVolumeValueSpan.textContent = Math.round(musicVolume * 100);
                updateDefaultIndicator(Math.round(musicVolume * 100), DEFAULT_MUSIC_VOLUME, 'musicVolumeDefault');
                
                // Add event listener
                musicVolumeSlider.addEventListener('input', function() {
                    const value = parseInt(this.value);
                    musicVolumeValueSpan.textContent = value;
                    updateDefaultIndicator(value, DEFAULT_MUSIC_VOLUME, 'musicVolumeDefault');
                    updateMusicVolume(value);
                    saveSettings();
                });
            }
            
            // SFX Volume Slider
            const sfxVolumeSlider = document.getElementById('sfxVolumeSlider');
            const sfxVolumeValueSpan = document.getElementById('sfxVolumeValue');

            if (sfxVolumeSlider && sfxVolumeValueSpan) {
                // Set initial values from loaded settings
                sfxVolumeSlider.value = sfxVolume * 100;
                sfxVolumeValueSpan.textContent = Math.round(sfxVolume * 100);
                updateDefaultIndicator(Math.round(sfxVolume * 100), DEFAULT_SFX_VOLUME, 'sfxVolumeDefault');
                
                // Add event listener
                sfxVolumeSlider.addEventListener('input', function() {
                    const value = parseInt(this.value);
                    sfxVolumeValueSpan.textContent = value;
                    updateDefaultIndicator(value, DEFAULT_SFX_VOLUME, 'sfxVolumeDefault');
                    updateSFXVolume(value);
                    saveSettings();
                });
            }
            
            // Tab Out Mute Slider
            const tabOutMuteSlider = document.getElementById('tabOutMuteSlider');
            const tabOutMuteValueSpan = document.getElementById('tabOutMuteValue');

            if (tabOutMuteSlider && tabOutMuteValueSpan) {
                // Set initial values from loaded settings
                tabOutMuteSlider.value = tabOutMuteLevel * 100;
                tabOutMuteValueSpan.textContent = Math.round(tabOutMuteLevel * 100);
                updateDefaultIndicator(Math.round(tabOutMuteLevel * 100), DEFAULT_TAB_OUT_MUTE, 'tabOutMuteDefault');
                
                // Add event listener
                tabOutMuteSlider.addEventListener('input', function() {
                    const value = parseInt(this.value);
                    tabOutMuteValueSpan.textContent = value;
                    updateDefaultIndicator(value, DEFAULT_TAB_OUT_MUTE, 'tabOutMuteDefault');
                    updateTabOutMuteLevel(value);
                    saveSettings();
                });
            }
            
            // Show Music Toast Toggle
            const showMusicToastToggle = document.getElementById('showMusicToastToggle');
            if (showMusicToastToggle) {
                // Load saved state (default: true)
                const savedState = localStorage.getItem('showMusicToast');
                showMusicToastToggle.checked = savedState !== 'false';
                
                // Update visibility on load
                updateToastVisibility();
                
                // Add event listener
                showMusicToastToggle.addEventListener('change', function() {
                    // Only allow disabling from pause menu, not during active gameplay
                    if (!this.checked && currentGameState === GAME_STATE.IN_GAME) {
                        // Prevent disabling during active gameplay
                        this.checked = true;
                        console.log(' Music toast can only be disabled from the pause menu');
                        return;
                    }
                    
                    // Show notification when disabling from pause menu
                    if (!this.checked && currentGameState === GAME_STATE.PAUSE_MENU) {
                        // Create temporary notification
                        const notification = document.createElement('div');
                        notification.style.cssText = `
                            position: fixed;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            background: rgba(0, 0, 0, 0.9);
                            color: #fff;
                            padding: 20px 40px;
                            border-radius: 8px;
                            border: 2px solid #79C05A;
                            font-family: 'Pixelify Sans', monospace;
                            font-size: 16px;
                            z-index: 10000;
                            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
                            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6);
                            animation: fadeIn 0.3s ease;
                        `;
                        notification.textContent = ' Music Toast Disabled';
                        document.body.appendChild(notification);
                        
                        // Remove notification after 2 seconds
                        setTimeout(() => {
                            notification.style.opacity = '0';
                            notification.style.transition = 'opacity 0.3s ease';
                            setTimeout(() => notification.remove(), 300);
                        }, 2000);
                    }
                    
                    localStorage.setItem('showMusicToast', this.checked);
                    updateToastVisibility();
                    playClickSound();
                });
            }
            
            // Music Toast Position Selector
            const musicToastPositionSelector = document.getElementById('musicToastPositionSelector');
            const musicToast = document.getElementById('music-toast');
            
            if (musicToastPositionSelector && musicToast) {
                // Load saved position (default: top-left)
                const savedPosition = localStorage.getItem('musicToastPosition') || 'top-left';
                musicToastPositionSelector.value = savedPosition;
                
                // Apply position class
                musicToast.classList.add(`position-${savedPosition}`);
                
                // Add event listener
                musicToastPositionSelector.addEventListener('change', function() {
                    // Remove all position classes
                    musicToast.classList.remove('position-top-left', 'position-top-right', 'position-bottom-left', 'position-bottom-right');
                    
                    // Add new position class
                    musicToast.classList.add(`position-${this.value}`);
                    
                    // Save to localStorage
                    localStorage.setItem('musicToastPosition', this.value);
                    playClickSound();
                });
            }
            
            // Music Toast Click to Expand
            let toastExpandTimeout = null;
            
            if (musicToast) {
                musicToast.addEventListener('click', function() {
                    // Only expand if in pill mode
                    if (!this.classList.contains('pill-mode')) return;
                    
                    console.log(' Expanding music toast...');
                    
                    // Clear any existing timeout
                    if (toastExpandTimeout) {
                        clearTimeout(toastExpandTimeout);
                    }
                    
                    // Add expanded class
                    this.classList.add('expanded');
                    this.classList.remove('pill-mode');
                    
                    // Revert to pill mode after 5 seconds
                    toastExpandTimeout = setTimeout(() => {
                        if (currentGameState === GAME_STATE.IN_GAME) {
                            musicToast.classList.remove('expanded');
                            musicToast.classList.add('pill-mode');
                            console.log(' Reverting to pill mode');
                        }
                    }, 5000);
                });
            }
            
            // Music Track Selector
            const musicTrackSelector = document.getElementById('musicTrackSelector');
            if (musicTrackSelector) {
                // Set initial value from loaded settings
                musicTrackSelector.value = selectedMusicTrack;
                
                // Add event listener
                musicTrackSelector.addEventListener('change', function() {
                    selectedMusicTrack = this.value;
                    saveSettings();
                    
                    // If music is playing, restart it with the new track
                    if (isMusicPlaying) {
                        stopBackgroundMusic();
                        setTimeout(() => {
                            startBackgroundMusic();
                        }, 100);
                    }
                    
                    playClickSound();
                });
            }
            
            // Parallax Speed Slider
            const parallaxSpeedSlider = document.getElementById('parallaxSpeedSlider');
            const parallaxSpeedValueSpan = document.getElementById('parallaxSpeedValue');
            if (parallaxSpeedSlider && parallaxSpeedValueSpan) {
                parallaxSpeedSlider.value = currentParallaxSpeed;
                parallaxSpeedValueSpan.textContent = currentParallaxSpeed;
                
                // Add event listener
                parallaxSpeedSlider.addEventListener('input', function() {
                    const value = parseInt(this.value);
                    currentParallaxSpeed = value;
                    parallaxSpeedValueSpan.textContent = value;
                    
                    // Update animation immediately if in a parallax view
                    const mainMenu = document.getElementById('main-menu');
                    const currentView = document.querySelector('#main-menu .menu-view[style*="display: flex"]');
                    if (currentView && currentView.id !== 'main-controls' && currentView.id !== 'credits-view') {
                        mainMenu.style.animation = `bgParallax ${value}s linear infinite`;
                    }
                });
            }
        }
        
        // Reset Audio Settings Button
        const resetAudioBtn = document.getElementById('resetAudioBtn');
        if (resetAudioBtn) {
            resetAudioBtn.addEventListener('click', function() {
                // Reset all audio settings to defaults
                masterVolume = DEFAULT_MASTER_VOLUME / 100;
                musicVolume = DEFAULT_MUSIC_VOLUME / 100;
                sfxVolume = DEFAULT_SFX_VOLUME / 100;
                tabOutMuteLevel = DEFAULT_TAB_OUT_MUTE / 100;
                
                // Update sliders and displays
                const masterVolumeSlider = document.getElementById('masterVolumeSlider');
                const masterVolumeValueSpan = document.getElementById('masterVolumeValue');
                if (masterVolumeSlider && masterVolumeValueSpan) {
                    masterVolumeSlider.value = DEFAULT_MASTER_VOLUME;
                    masterVolumeValueSpan.textContent = DEFAULT_MASTER_VOLUME;
                    updateDefaultIndicator(DEFAULT_MASTER_VOLUME, DEFAULT_MASTER_VOLUME, 'masterVolumeDefault');
                }
                
                const musicVolumeSlider = document.getElementById('musicVolumeSlider');
                const musicVolumeValueSpan = document.getElementById('musicVolumeValue');
                if (musicVolumeSlider && musicVolumeValueSpan) {
                    musicVolumeSlider.value = DEFAULT_MUSIC_VOLUME;
                    musicVolumeValueSpan.textContent = DEFAULT_MUSIC_VOLUME;
                    updateDefaultIndicator(DEFAULT_MUSIC_VOLUME, DEFAULT_MUSIC_VOLUME, 'musicVolumeDefault');
                }
                
                const sfxVolumeSlider = document.getElementById('sfxVolumeSlider');
                const sfxVolumeValueSpan = document.getElementById('sfxVolumeValue');
                if (sfxVolumeSlider && sfxVolumeValueSpan) {
                    sfxVolumeSlider.value = DEFAULT_SFX_VOLUME;
                    sfxVolumeValueSpan.textContent = DEFAULT_SFX_VOLUME;
                    updateDefaultIndicator(DEFAULT_SFX_VOLUME, DEFAULT_SFX_VOLUME, 'sfxVolumeDefault');
                }
                
                const tabOutMuteSlider = document.getElementById('tabOutMuteSlider');
                const tabOutMuteValueSpan = document.getElementById('tabOutMuteValue');
                if (tabOutMuteSlider && tabOutMuteValueSpan) {
                    tabOutMuteSlider.value = DEFAULT_TAB_OUT_MUTE;
                    tabOutMuteValueSpan.textContent = DEFAULT_TAB_OUT_MUTE;
                    updateDefaultIndicator(DEFAULT_TAB_OUT_MUTE, DEFAULT_TAB_OUT_MUTE, 'tabOutMuteDefault');
                }
                
                // Reset music track selector to random
                selectedMusicTrack = 'random';
                const musicTrackSelector = document.getElementById('musicTrackSelector');
                if (musicTrackSelector) {
                    musicTrackSelector.value = 'random';
                }
                
                // Apply the volume changes
                updateMasterVolume(DEFAULT_MASTER_VOLUME);
                updateMusicVolume(DEFAULT_MUSIC_VOLUME);
                updateSFXVolume(DEFAULT_SFX_VOLUME);
                updateTabOutMuteLevel(DEFAULT_TAB_OUT_MUTE);
                
                // Save settings
                saveSettings();
                
                // Play confirmation sound
                playClickSound();
                
                console.log(' Audio settings reset to defaults');
            });
        }
        
        // Reset Video Settings Button
        const resetVideoBtn = document.getElementById('resetVideoBtn');
        if (resetVideoBtn) {
            resetVideoBtn.addEventListener('click', function() {
                // Reset video settings to defaults
                renderDistance = DEFAULT_RENDER_DISTANCE;
                fieldOfView = DEFAULT_FOV;
                
                // Update sliders and displays
                const renderDistanceSlider = document.getElementById('renderDistanceSlider');
                const renderDistanceValueSpan = document.getElementById('renderDistanceValue');
                if (renderDistanceSlider && renderDistanceValueSpan) {
                    renderDistanceSlider.value = DEFAULT_RENDER_DISTANCE;
                    renderDistanceValueSpan.textContent = DEFAULT_RENDER_DISTANCE;
                    updateDefaultIndicator(DEFAULT_RENDER_DISTANCE, DEFAULT_RENDER_DISTANCE, 'renderDistanceDefault');
                }
                
                const fovSlider = document.getElementById('fovSlider');
                const fovValueSpan = document.getElementById('fovValue');
                if (fovSlider && fovValueSpan) {
                    fovSlider.value = DEFAULT_FOV;
                    fovValueSpan.textContent = DEFAULT_FOV;
                    updateDefaultIndicator(DEFAULT_FOV, DEFAULT_FOV, 'fovDefault');
                    camera.fov = DEFAULT_FOV;
                    camera.updateProjectionMatrix();
                }
                
                // Save settings
                saveSettings();
                
                // Play feedback sound
                playClickSound();
                
                console.log(' Video settings reset to defaults');
            });
        }
        
        // Reset Controls Settings Button
        const resetControlsBtn = document.getElementById('resetControlsBtn');
        if (resetControlsBtn) {
            resetControlsBtn.addEventListener('click', function() {
                // Reset controls settings to defaults
                mouseSensitivity = DEFAULT_MOUSE_SENSITIVITY / 100;
                handBobIntensity = DEFAULT_HAND_BOB_INTENSITY;
                
                // Update sliders and displays
                const sensitivitySlider = document.getElementById('sensitivitySlider');
                const sensitivityValueSpan = document.getElementById('sensitivityValue');
                if (sensitivitySlider && sensitivityValueSpan) {
                    sensitivitySlider.value = DEFAULT_MOUSE_SENSITIVITY;
                    sensitivityValueSpan.textContent = DEFAULT_MOUSE_SENSITIVITY;
                    updateDefaultIndicator(DEFAULT_MOUSE_SENSITIVITY, DEFAULT_MOUSE_SENSITIVITY, 'sensitivityDefault');
                }
                
                const handBobIntensitySlider = document.getElementById('handBobIntensitySlider');
                const handBobIntensityValueSpan = document.getElementById('handBobIntensityValue');
                if (handBobIntensitySlider && handBobIntensityValueSpan) {
                    handBobIntensitySlider.value = DEFAULT_HAND_BOB_INTENSITY;
                    handBobIntensityValueSpan.textContent = DEFAULT_HAND_BOB_INTENSITY;
                    updateDefaultIndicator(DEFAULT_HAND_BOB_INTENSITY, DEFAULT_HAND_BOB_INTENSITY, 'handBobIntensityDefault');
                }
                
                // Save settings
                saveSettings();
                
                // Play feedback sound
                playClickSound();
                
                console.log(' Controls settings reset to defaults');
            });
        }
        
        // ==================== GRAPHICS PRESETS SYSTEM ====================
        const graphicsPresets = {
            ultra: {
                name: 'Ultra',
                renderDistance: 50
            },
            high: {
                name: 'High',
                renderDistance: 40
            },
            medium: {
                name: 'Medium',
                renderDistance: 30
            },
            low: {
                name: 'Low',
                renderDistance: 20
            },
            potato: {
                name: 'Potato',
                renderDistance: 15
            }
        };
        
        function applyGraphicsPreset(presetName) {
            if (!presetName || !graphicsPresets[presetName]) return;
            
            const preset = graphicsPresets[presetName];
            
            // Apply render distance (in blocks)
            const quickRenderSlider = document.getElementById('quick-renderDistance');
            const quickRenderValue = document.getElementById('quick-renderDistance-value');
            const detailedRenderSlider = document.getElementById('renderDistanceSlider');
            const detailedRenderValue = document.getElementById('renderDistanceValue');
            
            if (quickRenderSlider && quickRenderValue) {
                quickRenderSlider.value = preset.renderDistance;
                quickRenderValue.textContent = preset.renderDistance + ' blocks';
            }
            
            if (detailedRenderSlider && detailedRenderValue) {
                detailedRenderSlider.value = preset.renderDistance;
                detailedRenderValue.textContent = preset.renderDistance;
                updateDefaultIndicator(preset.renderDistance, DEFAULT_RENDER_DISTANCE, 'renderDistanceDefault');
            }
            
            // Update global renderDistance
            renderDistance = preset.renderDistance;
            
            // Track the change
            trackSettingChange('Graphics Preset', preset.name);
            
            // Save settings
            saveSettings();
            
            // Play feedback sound
            playClickSound();
            
            console.log(` Applied ${preset.name} graphics preset`);
        }
        
        // Graphics preset selector event listener
        const graphicsPresetSelect = document.getElementById('graphicsPreset');
        if (graphicsPresetSelect) {
            graphicsPresetSelect.addEventListener('change', function() {
                const presetName = this.value;
                if (presetName) {
                    applyGraphicsPreset(presetName);
                }
            });
        }
        
        // ==================== SETTINGS HISTORY SYSTEM ====================
        let settingsHistory = [];
        const MAX_HISTORY_ITEMS = 10;
        
        function trackSettingChange(settingName, newValue) {
            const timestamp = new Date().toLocaleTimeString();
            const historyItem = {
                setting: settingName,
                value: newValue,
                time: timestamp
            };
            
            // Add to beginning of array
            settingsHistory.unshift(historyItem);
            
            // Keep only the last MAX_HISTORY_ITEMS
            if (settingsHistory.length > MAX_HISTORY_ITEMS) {
                settingsHistory = settingsHistory.slice(0, MAX_HISTORY_ITEMS);
            }
            
            // Update the display
            updateSettingsHistoryDisplay();
            
            // Save to localStorage
            try {
                localStorage.setItem('settingsHistory', JSON.stringify(settingsHistory));
            } catch (e) {
                console.warn('Could not save settings history:', e);
            }
        }
        
        function updateSettingsHistoryDisplay() {
            const historyContainer = document.getElementById('settings-history');
            if (!historyContainer) return;
            
            if (settingsHistory.length === 0) {
                historyContainer.innerHTML = '<p style="font-size: 12px; color: #666; text-align: center; padding: 20px;">No recent changes</p>';
                return;
            }
            
            let html = '<div style="display: flex; flex-direction: column; gap: 8px;">';
            settingsHistory.forEach((item, index) => {
                html += `
                    <div style="padding: 10px; background: rgba(0,0,0,0.3); border-radius: 4px; border: 1px solid rgba(255,255,255,0.1);">
                        <div style="font-size: 12px; font-weight: bold; color: var(--main-action); margin-bottom: 4px;">${item.setting}</div>
                        <div style="font-size: 11px; color: #ccc;">Value: ${item.value}</div>
                        <div style="font-size: 10px; color: #666; margin-top: 4px;">${item.time}</div>
                    </div>
                `;
            });
            html += '</div>';
            
            historyContainer.innerHTML = html;
        }
        
        function clearSettingsHistory() {
            settingsHistory = [];
            updateSettingsHistoryDisplay();
            try {
                localStorage.removeItem('settingsHistory');
            } catch (e) {
                console.warn('Could not clear settings history:', e);
            }
            playClickSound();
            console.log(' Settings history cleared');
        }
        
        // Load settings history on startup
        function loadSettingsHistory() {
            try {
                const saved = localStorage.getItem('settingsHistory');
                if (saved) {
                    settingsHistory = JSON.parse(saved);
                    updateSettingsHistoryDisplay();
                }
            } catch (e) {
                console.warn('Could not load settings history:', e);
            }
        }
        
        // Initialize settings history
        loadSettingsHistory();
        
        // ==================== SETTINGS SEARCH FILTER ====================
        const allSettings = [
            { name: 'Render Distance', page: 'video', element: 'renderDistanceSlider' },
            { name: 'Field of View', page: 'video', element: 'fovSlider' },
            { name: 'FOV', page: 'video', element: 'fovSlider' },
            { name: 'Mouse Sensitivity', page: 'controls', element: 'sensitivitySlider' },
            { name: 'Sensitivity', page: 'controls', element: 'sensitivitySlider' },
            { name: 'Keybinds', page: 'controls', element: 'openKeybindsModalBtn' },
            { name: 'Controls', page: 'controls', element: 'sensitivitySlider' },
            { name: 'Hand Bobbing', page: 'controls', element: 'handBobToggle' },
            { name: 'Bob Intensity', page: 'controls', element: 'handBobIntensitySlider' },
            { name: 'Master Volume', page: 'audio', element: 'masterVolumeSlider' },
            { name: 'Music Volume', page: 'audio', element: 'musicVolumeSlider' },
            { name: 'Volume', page: 'audio', element: 'masterVolumeSlider' },
            { name: 'Audio', page: 'audio', element: 'masterVolumeSlider' },
            { name: 'Sound', page: 'audio', element: 'masterVolumeSlider' }
        ];
        
        function searchSettings(searchTerm) {
            const searchResults = document.getElementById('searchResults');
            if (!searchResults) return;
            
            if (!searchTerm || searchTerm.length < 2) {
                searchResults.style.display = 'none';
                return;
            }
            
            const term = searchTerm.toLowerCase();
            const matches = allSettings.filter(setting => 
                setting.name.toLowerCase().includes(term)
            );
            
            if (matches.length === 0) {
                searchResults.style.display = 'block';
                searchResults.innerHTML = '<p style="color: #888; font-size: 12px; padding: 10px;">No settings found</p>';
                return;
            }
            
            let html = '<div style="display: flex; flex-direction: column; gap: 5px;">';
            // Remove duplicates based on page
            const uniqueMatches = matches.filter((match, index, self) => 
                index === self.findIndex(m => m.page === match.page && m.element === match.element)
            );
            
            uniqueMatches.forEach(match => {
                html += `
                    <button onclick="navigateToSetting('${match.page}')" style="padding: 10px; background: rgba(0,191,255,0.2); border: 1px solid var(--main-action); border-radius: 4px; color: white; font-family: inherit; cursor: pointer; text-align: left; transition: all 0.2s;" onmouseover="this.style.background='rgba(0,191,255,0.3)'" onmouseout="this.style.background='rgba(0,191,255,0.2)'">
                        <div style="font-size: 13px; font-weight: bold;">${match.name}</div>
                        <div style="font-size: 11px; color: #aaa; text-transform: uppercase;">${match.page} settings</div>
                    </button>
                `;
            });
            html += '</div>';
            
            searchResults.style.display = 'block';
            searchResults.innerHTML = html;
        }
        
        function navigateToSetting(page) {
            // Hide search results
            const searchResults = document.getElementById('searchResults');
            if (searchResults) searchResults.style.display = 'none';
            
            // Clear search input
            const searchInput = document.getElementById('settingsSearchInput');
            if (searchInput) searchInput.value = '';
            
            // Navigate to appropriate settings page
            if (page === 'video') {
                showVideoSettings();
            } else if (page === 'controls') {
                showControlSettings();
            } else if (page === 'audio') {
                showAudioSettings();
            }
            
            playClickSound();
        }
        
        // ==================== UPDATE FUNCTIONS ====================
        function updateRenderDistance() {
            const renderSlider = document.getElementById('quick-render-distance');
            if (renderSlider) {
                renderDistance = parseInt(renderSlider.value);
                saveSettings();
            }
        }
        
        function updateFOV() {
            const fovSlider = document.getElementById('quick-fov');
            if (fovSlider && camera) {
                fieldOfView = parseInt(fovSlider.value);
                camera.fov = fieldOfView;
                camera.updateProjectionMatrix();
                saveSettings();
            }
        }
        
        // ==================== END NEW SETTINGS FEATURES ====================
        
        // ==================== PRESET COMPARISON TOOL ====================
        let selectedComparisonPreset = null;
        
        function showPresetComparison() {
            const modal = document.getElementById('preset-comparison-modal');
            const presetSelect = document.getElementById('graphicsPreset');
            const compareSelect = document.getElementById('presetCompareSelect');
            
            if (!modal || !presetSelect) return;
            
            // Set initial comparison preset
            if (compareSelect) {
                compareSelect.value = 'ultra';
                selectedComparisonPreset = 'ultra';
            }
            
            updateComparisonTable();
            modal.style.display = 'flex';
            playClickSound();
        }
        
        function closePresetComparison() {
            const modal = document.getElementById('preset-comparison-modal');
            if (modal) {
                modal.style.display = 'none';
                playClickSound();
            }
        }
        
        function updateComparisonTable() {
            const compareSelect = document.getElementById('presetCompareSelect');
            const comparisonTable = document.getElementById('comparisonTable');
            
            if (!compareSelect || !comparisonTable) return;
            
            const presetName = compareSelect.value;
            selectedComparisonPreset = presetName;
            const preset = graphicsPresets[presetName];
            
            if (!preset) return;
            
            // Get current values
            const currentRenderDist = renderDistance || 5;
            
            let html = `
                <table style="width: 100%; color: white; font-size: 13px;">
                    <thead>
                        <tr style="border-bottom: 2px solid rgba(255,255,255,0.2);">
                            <th style="padding: 10px; text-align: left;">Setting</th>
                            <th style="padding: 10px; text-align: center;">Current</th>
                            <th style="padding: 10px; text-align: center;">${preset.name}</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr style="border-bottom: 1px solid rgba(255,255,255,0.1);">
                            <td style="padding: 10px;">Render Distance</td>
                            <td style="padding: 10px; text-align: center;">${currentRenderDist} chunks</td>
                            <td style="padding: 10px; text-align: center; color: var(--main-action); font-weight: bold;">${preset.renderDistance} chunks</td>
                        </tr>
                    </tbody>
                </table>
            `;
            
            comparisonTable.innerHTML = html;
        }
        
        function applyComparedPreset() {
            if (selectedComparisonPreset) {
                const presetSelect = document.getElementById('graphicsPreset');
                if (presetSelect) {
                    presetSelect.value = selectedComparisonPreset;
                }
                applyGraphicsPreset(selectedComparisonPreset);
            }
            closePresetComparison();
        }
        
        // Update comparison table when preset selection changes
        const compareSelect = document.getElementById('presetCompareSelect');
        if (compareSelect) {
            compareSelect.addEventListener('change', updateComparisonTable);
        }
        
        // ==================== QUICK SETTINGS CUSTOMIZATION ====================
        const availableQuickSettings = [
            { id: 'renderDistance', name: 'Render Distance', type: 'slider', min: 10, max: 50, value: 'renderDistance', suffix: ' blocks' },
            { id: 'fov', name: 'Field of View', type: 'slider', min: 50, max: 110, value: 'fieldOfView', suffix: '' },
            { id: 'sensitivity', name: 'Mouse Sensitivity', type: 'slider', min: 25, max: 200, value: 'mouseSensitivity', suffix: '%' },
            { id: 'masterVolume', name: 'Master Volume', type: 'slider', min: 0, max: 100, value: 'masterVolume', suffix: '%' },
            { id: 'musicVolume', name: 'Music Volume', type: 'slider', min: 0, max: 100, value: 'musicVolume', suffix: '%' },
            { id: 'handBob', name: 'Hand Bob Intensity', type: 'slider', min: 0, max: 200, value: 'handBobIntensity', suffix: '%' }
        ];
        
        let activeQuickSettings = ['renderDistance', 'fov', 'sensitivity']; // Default
        
        function customizeQuickSettings() {
            const modal = document.getElementById('quick-settings-modal');
            const optionsContainer = document.getElementById('quickSettingsOptions');
            
            if (!modal || !optionsContainer) return;
            
            // Generate options
            let html = '';
            availableQuickSettings.forEach(setting => {
                const isActive = activeQuickSettings.includes(setting.id);
                html += `
                    <label style="display: flex; align-items: center; gap: 10px; padding: 12px; background: rgba(0,0,0,0.4); border-radius: 4px; cursor: pointer; border: 2px solid ${isActive ? 'var(--main-action)' : 'rgba(255,255,255,0.1)'};">
                        <input type="checkbox" value="${setting.id}" ${isActive ? 'checked' : ''} style="width: 20px; height: 20px; cursor: pointer;">
                        <span style="color: white; flex: 1;">${setting.name}</span>
                    </label>
                `;
            });
            
            optionsContainer.innerHTML = html;
            modal.style.display = 'flex';
            playClickSound();
        }
        
        function closeQuickSettingsModal() {
            const modal = document.getElementById('quick-settings-modal');
            if (modal) {
                modal.style.display = 'none';
                playClickSound();
            }
        }
        
        function saveQuickSettings() {
            const optionsContainer = document.getElementById('quickSettingsOptions');
            if (!optionsContainer) return;
            
            const checkboxes = optionsContainer.querySelectorAll('input[type="checkbox"]');
            activeQuickSettings = [];
            
            checkboxes.forEach(checkbox => {
                if (checkbox.checked && activeQuickSettings.length < 6) {
                    activeQuickSettings.push(checkbox.value);
                }
            });
            
            // Save to localStorage
            try {
                localStorage.setItem('activeQuickSettings', JSON.stringify(activeQuickSettings));
            } catch (e) {
                console.warn('Could not save quick settings:', e);
            }
            
            // Regenerate quick settings panel
            generateQuickSettingsPanel();
            
            closeQuickSettingsModal();
            playClickSound();
            console.log(' Quick settings saved');
        }
        
        function generateQuickSettingsPanel() {
            const container = document.getElementById('quickSettingsContainer');
            if (!container) return;
            
            let html = '';
            activeQuickSettings.forEach(settingId => {
                const setting = availableQuickSettings.find(s => s.id === settingId);
                if (!setting) return;
                
                const currentValue = getCurrentSettingValue(setting);
                
                // Get default value for this setting
                let defaultValue;
                if (settingId === 'renderDistance') defaultValue = DEFAULT_RENDER_DISTANCE;
                else if (settingId === 'fov') defaultValue = DEFAULT_FOV;
                else if (settingId === 'sensitivity') defaultValue = DEFAULT_MOUSE_SENSITIVITY;
                else if (settingId === 'handBob') defaultValue = DEFAULT_HAND_BOB_INTENSITY;
                else defaultValue = null;
                
                const isDefault = defaultValue !== null && currentValue === defaultValue;
                
                html += `
                    <div style="padding: 15px; background: rgba(0,0,0,0.3); border-radius: 4px; border: 1px solid rgba(255,255,255,0.1);">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <span style="font-size: 13px; color: white;">${setting.name}</span>
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span id="quick-${setting.id}-value" style="font-size: 13px; color: var(--main-action); font-weight: bold;">${currentValue}${setting.suffix}</span>
                                ${defaultValue !== null ? '<span style="color: ' + (isDefault ? '#79C05A' : 'transparent') + '; font-size: 0.9em;" id="quick-' + setting.id + '-default"> Default</span>' : ''}
                            </div>
                        </div>
                        <input type="range" id="quick-${setting.id}" class="custom-slider" min="${setting.min}" max="${setting.max}" value="${currentValue}" oninput="updateQuickSetting('${setting.id}')" style="width: 100%;">
                    </div>
                `;
            });
            
            container.innerHTML = html || '<p style="color: #888; text-align: center; padding: 20px;">No quick settings selected</p>';
        }
        
        function getCurrentSettingValue(setting) {
            // Return current value based on setting type
            if (setting.id === 'renderDistance') return renderDistance || DEFAULT_RENDER_DISTANCE;
            if (setting.id === 'fov') return (camera ? camera.fov : 75);
            if (setting.id === 'sensitivity') return Math.round((mouseSensitivity || 1.0) * 100);
            if (setting.id === 'masterVolume') return 100; // Placeholder
            if (setting.id === 'musicVolume') return 50; // Placeholder
            if (setting.id === 'handBob') return handBobIntensity || 100;
            return setting.min;
        }
        
        function updateQuickSetting(settingId) {
            const slider = document.getElementById(`quick-${settingId}`);
            const valueDisplay = document.getElementById(`quick-${settingId}-value`);
            const defaultIndicator = document.getElementById(`quick-${settingId}-default`);
            const setting = availableQuickSettings.find(s => s.id === settingId);
            
            if (!slider || !valueDisplay || !setting) return;
            
            const value = parseInt(slider.value);
            valueDisplay.textContent = value + setting.suffix;
            
            // Get default value for this setting
            let defaultValue;
            if (settingId === 'renderDistance') defaultValue = DEFAULT_RENDER_DISTANCE;
            else if (settingId === 'fov') defaultValue = DEFAULT_FOV;
            else if (settingId === 'sensitivity') defaultValue = DEFAULT_MOUSE_SENSITIVITY;
            else if (settingId === 'handBob') defaultValue = DEFAULT_HAND_BOB_INTENSITY;
            else defaultValue = null;
            
            // Update default indicator for quick settings
            if (defaultIndicator && defaultValue !== null) {
                if (value === defaultValue) {
                    defaultIndicator.style.color = '#79C05A';
                    defaultIndicator.textContent = ' Default';
                } else {
                    defaultIndicator.style.color = 'transparent';
                }
            }
            
            // Update the actual setting and sync with detailed settings
            if (settingId === 'renderDistance') {
                renderDistance = value;
                const detailedSlider = document.getElementById('renderDistanceSlider');
                if (detailedSlider) {
                    detailedSlider.value = value;
                    const detailedValue = document.getElementById('renderDistanceValue');
                    if (detailedValue) detailedValue.textContent = value;
                    updateDefaultIndicator(value, DEFAULT_RENDER_DISTANCE, 'renderDistanceDefault');
                }
            } else if (settingId === 'fov') {
                if (camera) {
                    camera.fov = value;
                    camera.updateProjectionMatrix();
                }
                fieldOfView = value;
                const detailedSlider = document.getElementById('fovSlider');
                if (detailedSlider) {
                    detailedSlider.value = value;
                    const detailedValue = document.getElementById('fovValue');
                    if (detailedValue) detailedValue.textContent = value;
                    updateDefaultIndicator(value, DEFAULT_FOV, 'fovDefault');
                }
            } else if (settingId === 'sensitivity') {
                mouseSensitivity = value / 100;
                const detailedSlider = document.getElementById('sensitivitySlider');
                if (detailedSlider) {
                    detailedSlider.value = value;
                    const detailedValue = document.getElementById('sensitivityValue');
                    if (detailedValue) detailedValue.textContent = value;
                    updateDefaultIndicator(value, DEFAULT_MOUSE_SENSITIVITY, 'sensitivityDefault');
                }
            } else if (settingId === 'handBob') {
                handBobIntensity = value;
                const detailedSlider = document.getElementById('handBobIntensitySlider');
                if (detailedSlider) {
                    detailedSlider.value = value;
                    const detailedValue = document.getElementById('handBobIntensityValue');
                    if (detailedValue) detailedValue.textContent = value;
                    updateDefaultIndicator(value, DEFAULT_HAND_BOB_INTENSITY, 'handBobIntensityDefault');
                }
            }
            
            trackSettingChange(setting.name, value + setting.suffix);
            saveSettings();
        }
        
        // Load quick settings on startup
        function loadQuickSettings() {
            try {
                const saved = localStorage.getItem('activeQuickSettings');
                if (saved) {
                    activeQuickSettings = JSON.parse(saved);
                }
            } catch (e) {
                console.warn('Could not load quick settings:', e);
            }
            generateQuickSettingsPanel();
        }
        
        // Initialize quick settings
        loadQuickSettings();
        
        // ==================== MODEL TEXTURE CUSTOMIZATION SYSTEM ====================
        let currentBodyPart = 'head';
        let currentTextureSide = 'front';
        let selectedTextureColor = '#d4a574';
        let isTexturePainting = false;
        
        // Texture dimensions for each body part (width x height in pixels for each side)
        // Function to get texture dimensions based on skin type
        function getTexturePartDimensions() {
            const armWidth = isSlimSkin ? 3 : 4;
            return {
                head: { front: {w: 8, h: 8}, back: {w: 8, h: 8}, left: {w: 8, h: 8}, right: {w: 8, h: 8}, top: {w: 8, h: 8}, bottom: {w: 8, h: 8} },
                headLayer: { front: {w: 8, h: 8}, back: {w: 8, h: 8}, left: {w: 8, h: 8}, right: {w: 8, h: 8}, top: {w: 8, h: 8}, bottom: {w: 8, h: 8} },
                torso: { front: {w: 8, h: 12}, back: {w: 8, h: 12}, left: {w: 4, h: 12}, right: {w: 4, h: 12}, top: {w: 8, h: 4}, bottom: {w: 8, h: 4} },
                torsoLayer: { front: {w: 8, h: 12}, back: {w: 8, h: 12}, left: {w: 4, h: 12}, right: {w: 4, h: 12}, top: {w: 8, h: 4}, bottom: {w: 8, h: 4} },
                leftArm: { front: {w: armWidth, h: 12}, back: {w: armWidth, h: 12}, left: {w: armWidth, h: 12}, right: {w: armWidth, h: 12}, top: {w: armWidth, h: 4}, bottom: {w: armWidth, h: 4} },
                leftArmLayer: { front: {w: armWidth, h: 12}, back: {w: armWidth, h: 12}, left: {w: armWidth, h: 12}, right: {w: armWidth, h: 12}, top: {w: armWidth, h: 4}, bottom: {w: armWidth, h: 4} },
                rightArm: { front: {w: armWidth, h: 12}, back: {w: armWidth, h: 12}, left: {w: armWidth, h: 12}, right: {w: armWidth, h: 12}, top: {w: armWidth, h: 4}, bottom: {w: armWidth, h: 4} },
                rightArmLayer: { front: {w: armWidth, h: 12}, back: {w: armWidth, h: 12}, left: {w: armWidth, h: 12}, right: {w: armWidth, h: 12}, top: {w: armWidth, h: 4}, bottom: {w: armWidth, h: 4} },
                leftLeg: { front: {w: 4, h: 12}, back: {w: 4, h: 12}, left: {w: 4, h: 12}, right: {w: 4, h: 12}, top: {w: 4, h: 4}, bottom: {w: 4, h: 4} },
                leftLegLayer: { front: {w: 4, h: 12}, back: {w: 4, h: 12}, left: {w: 4, h: 12}, right: {w: 4, h: 12}, top: {w: 4, h: 4}, bottom: {w: 4, h: 4} },
                rightLeg: { front: {w: 4, h: 12}, back: {w: 4, h: 12}, left: {w: 4, h: 12}, right: {w: 4, h: 12}, top: {w: 4, h: 4}, bottom: {w: 4, h: 4} },
                rightLegLayer: { front: {w: 4, h: 12}, back: {w: 4, h: 12}, left: {w: 4, h: 12}, right: {w: 4, h: 12}, top: {w: 4, h: 4}, bottom: {w: 4, h: 4} },
                fpHand: { front: {w: armWidth, h: 12}, back: {w: armWidth, h: 12}, left: {w: armWidth, h: 12}, right: {w: armWidth, h: 12}, top: {w: armWidth, h: 4}, bottom: {w: armWidth, h: 4} }
            };
        }
        
        let texturePartDimensions = getTexturePartDimensions();
        
        // Store textures as ImageData for each part and side
        let modelTextures = {};
        
        function initializeModelTextures() {
            for (let part in texturePartDimensions) {
                modelTextures[part] = {};
                for (let side in texturePartDimensions[part]) {
                    const dims = texturePartDimensions[part][side];
                    const canvas = document.createElement('canvas');
                    canvas.width = dims.w;
                    canvas.height = dims.h;
                    const ctx = canvas.getContext('2d');
                    
                    // Default color based on part
                    // Layer parts (hat, jacket, sleeves, pants) are transparent by default
                    if (part.includes('Layer')) {
                        // Transparent - don't fill
                        ctx.clearRect(0, 0, dims.w, dims.h);
                    } else {
                        // Base parts have colors
                        let defaultColor = '#d4a574'; // skin tone
                        if (part === 'torso') defaultColor = '#4080ff'; // blue shirt
                        if (part.includes('Leg')) defaultColor = '#404080'; // blue pants
                        
                        ctx.fillStyle = defaultColor;
                        ctx.fillRect(0, 0, dims.w, dims.h);
                    }
                    
                    modelTextures[part][side] = ctx.getImageData(0, 0, dims.w, dims.h);
                }
            }
        }
        
        function openModelCustomizer() {
            const modal = document.getElementById('model-customizer-modal');
            if (!modal) return;
            loadModelTextures();
            if (Object.keys(modelTextures).length === 0) {
                initializeModelTextures();
            }
            initTextureColorPalette();
            selectBodyPart('head');
            selectTextureSide('front');
            modal.style.display = 'flex';
            
            // Initialize 3D preview
            if (!previewScene) {
                init3DPreview();
            }
            
            // Apply current textures to both game models and preview
            applyTexturesToModels();
            update3DPreview();
            
            playClickSound();
        }
        
        function closeModelCustomizer() {
            const modal = document.getElementById('model-customizer-modal');
            if (modal) {
                modal.style.display = 'none';
                playClickSound();
            }
        }
        
        function selectBodyPart(part) {
            currentBodyPart = part;
            document.querySelectorAll('.part-selector-btn').forEach(btn => {
                if (btn.dataset.part === part) {
                    btn.style.background = 'var(--main-action)';
                } else {
                    btn.style.background = 'rgba(255,255,255,0.2)';
                }
            });
            renderTextureCanvas();
            playClickSound();
        }
        
        function selectTextureSide(side) {
            currentTextureSide = side;
            document.querySelectorAll('.side-selector-btn').forEach(btn => {
                if (btn.dataset.side === side) {
                    btn.style.background = 'var(--main-action)';
                } else {
                    btn.style.background = 'rgba(255,255,255,0.2)';
                }
            });
            renderTextureCanvas();
            playClickSound();
        }
        
        function initTextureColorPalette() {
            const palette = document.getElementById('textureColorPalette');
            if (!palette) return;
            
            const colors = [
                '#d4a574', '#8b5a2b', '#4a2511', '#2c1810',
                '#f5deb3', '#ffffff', '#000000', '#808080',
                '#4080ff', '#404080', '#00ff00', '#ff0000',
                '#ffff00', '#ff8800', '#8b4513', '#a0522d'
            ];
            
            palette.innerHTML = '';
            colors.forEach(color => {
                const btn = document.createElement('button');
                btn.style.cssText = `width: 30px; height: 30px; background: ${color}; border: 2px solid #666; cursor: pointer; border-radius: 3px; transition: all 0.2s;`;
                btn.onclick = () => {
                    selectedTextureColor = color;
                    document.getElementById('textureCustomColor').value = color;
                    playClickSound();
                };
                btn.onmouseenter = () => { btn.style.transform = 'scale(1.1)'; };
                btn.onmouseleave = () => { btn.style.transform = 'scale(1)'; };
                palette.appendChild(btn);
            });
            
            const customColorPicker = document.getElementById('textureCustomColor');
            if (customColorPicker) {
                customColorPicker.addEventListener('input', (e) => {
                    selectedTextureColor = e.target.value;
                });
            }
        }
        
        function renderTextureCanvas() {
            const canvas = document.getElementById('texturePixelGrid');
            if (!canvas) return;
            
            const dims = texturePartDimensions[currentBodyPart][currentTextureSide];
            const texture = modelTextures[currentBodyPart]?.[currentTextureSide];
            
            if (!texture) return;
            
            const ctx = canvas.getContext('2d');
            const pixelSize = 192 / Math.max(dims.w, dims.h);
            
            // Clear canvas with checkerboard
            ctx.fillStyle = '#555';
            ctx.fillRect(0, 0, 192, 192);
            
            // Draw texture with pixel grid
            for (let y = 0; y < dims.h; y++) {
                for (let x = 0; x < dims.w; x++) {
                    const i = (y * dims.w + x) * 4;
                    const r = texture.data[i];
                    const g = texture.data[i + 1];
                    const b = texture.data[i + 2];
                    const a = texture.data[i + 3];
                    
                    if (a > 0) {
                        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${a / 255})`;
                        ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
                    }
                }
            }
            
            // Draw grid lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
            ctx.lineWidth = 1;
            for (let y = 0; y <= dims.h; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * pixelSize);
                ctx.lineTo(dims.w * pixelSize, y * pixelSize);
                ctx.stroke();
            }
            for (let x = 0; x <= dims.w; x++) {
                ctx.beginPath();
                ctx.moveTo(x * pixelSize, 0);
                ctx.lineTo(x * pixelSize, dims.h * pixelSize);
                ctx.stroke();
            }
            
            // Update 3D preview in real-time
            update3DPreview();
        }
        
        // ========== 3D PREVIEW SYSTEM ==========
        let previewScene, previewCamera, previewRenderer;
        let previewPlayerGroup, previewHead, previewBody, previewLeftArm, previewRightArm, previewLeftLeg, previewRightLeg;
        let previewHeadLayer, previewBodyLayer, previewLeftArmLayer, previewRightArmLayer, previewLeftLegLayer, previewRightLegLayer;
        let previewRotation = 0;
        let previewAutoRotate = true;
        
        function init3DPreview() {
            const canvas = document.getElementById('texturePreview3D');
            if (!canvas) return;
            
            // Create scene
            previewScene = new THREE.Scene();
            previewScene.background = new THREE.Color(0x87CEEB);
            
            // Camera
            previewCamera = new THREE.PerspectiveCamera(45, 300/400, 0.1, 1000);
            previewCamera.position.set(0, 1.5, 4);
            previewCamera.lookAt(0, 1, 0);
            
            // Renderer
            previewRenderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            previewRenderer.setSize(300, 400);
            previewRenderer.shadowMap.enabled = true;
            
            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            previewScene.add(ambientLight);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 10, 5);
            dirLight.castShadow = true;
            previewScene.add(dirLight);
            
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
            fillLight.position.set(-5, 5, -5);
            previewScene.add(fillLight);
            
            // Create player model
            const modelScale = 2;
            previewPlayerGroup = new THREE.Group();
            
            // Head
            const headGeometry = new THREE.BoxGeometry(0.5 * modelScale, 0.5 * modelScale, 0.5 * modelScale);
            previewHead = new THREE.Mesh(headGeometry, new THREE.MeshLambertMaterial({ color: 0xd4a574 }));
            previewHead.position.set(0, 1.5 * modelScale, 0);
            previewPlayerGroup.add(previewHead);
            
            // Head layer
            const headLayerGeometry = new THREE.BoxGeometry(0.52 * modelScale, 0.52 * modelScale, 0.52 * modelScale);
            previewHeadLayer = new THREE.Mesh(headLayerGeometry, new THREE.MeshLambertMaterial({ transparent: true, opacity: 0 }));
            previewHeadLayer.position.copy(previewHead.position);
            previewPlayerGroup.add(previewHeadLayer);
            
            // Body
            const bodyGeometry = new THREE.BoxGeometry(0.5 * modelScale, 0.75 * modelScale, 0.25 * modelScale);
            previewBody = new THREE.Mesh(bodyGeometry, new THREE.MeshLambertMaterial({ color: 0x4080ff }));
            previewBody.position.set(0, 0.875 * modelScale, 0);
            previewPlayerGroup.add(previewBody);
            
            // Body layer
            const bodyLayerGeometry = new THREE.BoxGeometry(0.52 * modelScale, 0.77 * modelScale, 0.27 * modelScale);
            previewBodyLayer = new THREE.Mesh(bodyLayerGeometry, new THREE.MeshLambertMaterial({ transparent: true, opacity: 0 }));
            previewBodyLayer.position.copy(previewBody.position);
            previewPlayerGroup.add(previewBodyLayer);
            
            // Arms
            const armWidth = isSlimSkin ? 0.1875 * modelScale : 0.25 * modelScale;
            const armGeometry = new THREE.BoxGeometry(armWidth, 0.75 * modelScale, 0.25 * modelScale);
            
            previewRightArm = new THREE.Mesh(armGeometry, new THREE.MeshLambertMaterial({ color: 0xd4a574 }));
            previewRightArm.position.set(-0.375 * modelScale, 0.875 * modelScale, 0);
            previewPlayerGroup.add(previewRightArm);
            
            previewLeftArm = new THREE.Mesh(armGeometry, new THREE.MeshLambertMaterial({ color: 0xd4a574 }));
            previewLeftArm.position.set(0.375 * modelScale, 0.875 * modelScale, 0);
            previewPlayerGroup.add(previewLeftArm);
            
            // Arm layers
            const armLayerWidth = isSlimSkin ? 0.2075 * modelScale : 0.27 * modelScale;
            const armLayerGeometry = new THREE.BoxGeometry(armLayerWidth, 0.77 * modelScale, 0.27 * modelScale);
            
            previewRightArmLayer = new THREE.Mesh(armLayerGeometry, new THREE.MeshLambertMaterial({ transparent: true, opacity: 0 }));
            previewRightArmLayer.position.copy(previewRightArm.position);
            previewPlayerGroup.add(previewRightArmLayer);
            
            previewLeftArmLayer = new THREE.Mesh(armLayerGeometry, new THREE.MeshLambertMaterial({ transparent: true, opacity: 0 }));
            previewLeftArmLayer.position.copy(previewLeftArm.position);
            previewPlayerGroup.add(previewLeftArmLayer);
            
            // Legs
            const legGeometry = new THREE.BoxGeometry(0.25 * modelScale, 0.75 * modelScale, 0.25 * modelScale);
            
            previewRightLeg = new THREE.Mesh(legGeometry, new THREE.MeshLambertMaterial({ color: 0x404080 }));
            previewRightLeg.position.set(-0.125 * modelScale, 0.125 * modelScale, 0);
            previewPlayerGroup.add(previewRightLeg);
            
            previewLeftLeg = new THREE.Mesh(legGeometry, new THREE.MeshLambertMaterial({ color: 0x404080 }));
            previewLeftLeg.position.set(0.125 * modelScale, 0.125 * modelScale, 0);
            previewPlayerGroup.add(previewLeftLeg);
            
            // Leg layers
            const legLayerGeometry = new THREE.BoxGeometry(0.27 * modelScale, 0.77 * modelScale, 0.27 * modelScale);
            
            previewRightLegLayer = new THREE.Mesh(legLayerGeometry, new THREE.MeshLambertMaterial({ transparent: true, opacity: 0 }));
            previewRightLegLayer.position.copy(previewRightLeg.position);
            previewPlayerGroup.add(previewRightLegLayer);
            
            previewLeftLegLayer = new THREE.Mesh(legLayerGeometry, new THREE.MeshLambertMaterial({ transparent: true, opacity: 0 }));
            previewLeftLegLayer.position.copy(previewLeftLeg.position);
            previewPlayerGroup.add(previewLeftLegLayer);
            
            previewScene.add(previewPlayerGroup);
            
            // Auto-rotate toggle
            const autoRotateToggle = document.getElementById('autoRotateToggle');
            if (autoRotateToggle) {
                autoRotateToggle.addEventListener('change', (e) => {
                    previewAutoRotate = e.target.checked;
                });
            }
            
            // Start animation loop
            animate3DPreview();
        }
        
        function update3DPreview() {
            if (!previewPlayerGroup) return;
            
            // Update all body part textures
            const createMaterialArray = (partTextures, partName) => {
                if (!partTextures) return null;
                
                const sides = ['right', 'left', 'top', 'bottom', 'front', 'back'];
                const isLayer = partName.includes('Layer');
                
                return sides.map(side => {
                    const textureData = partTextures[side];
                    if (!textureData) {
                        let color = 0xd4a574;
                        if (partName === 'torso') color = 0x4080ff;
                        if (partName.includes('Leg')) color = 0x404080;
                        return new THREE.MeshLambertMaterial({ 
                            color,
                            transparent: isLayer,
                            opacity: isLayer ? 0 : 1,
                            depthWrite: !isLayer
                        });
                    }
                    
                    const dims = texturePartDimensions[partName][side];
                    const canvas = document.createElement('canvas');
                    canvas.width = dims.w;
                    canvas.height = dims.h;
                    const ctx = canvas.getContext('2d');
                    ctx.putImageData(textureData, 0, 0);
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    texture.magFilter = THREE.NearestFilter;
                    texture.minFilter = THREE.NearestFilter;
                    
                    return new THREE.MeshLambertMaterial({ 
                        map: texture,
                        transparent: isLayer,
                        alphaTest: isLayer ? 0.1 : 0,
                        depthWrite: !isLayer
                    });
                });
            };
            
            if (modelTextures.head) previewHead.material = createMaterialArray(modelTextures.head, 'head');
            if (modelTextures.headLayer) previewHeadLayer.material = createMaterialArray(modelTextures.headLayer, 'headLayer');
            if (modelTextures.torso) previewBody.material = createMaterialArray(modelTextures.torso, 'torso');
            if (modelTextures.torsoLayer) previewBodyLayer.material = createMaterialArray(modelTextures.torsoLayer, 'torsoLayer');
            if (modelTextures.leftArm) previewLeftArm.material = createMaterialArray(modelTextures.leftArm, 'leftArm');
            if (modelTextures.leftArmLayer) previewLeftArmLayer.material = createMaterialArray(modelTextures.leftArmLayer, 'leftArmLayer');
            if (modelTextures.rightArm) previewRightArm.material = createMaterialArray(modelTextures.rightArm, 'rightArm');
            if (modelTextures.rightArmLayer) previewRightArmLayer.material = createMaterialArray(modelTextures.rightArmLayer, 'rightArmLayer');
            if (modelTextures.leftLeg) previewLeftLeg.material = createMaterialArray(modelTextures.leftLeg, 'leftLeg');
            if (modelTextures.leftLegLayer) previewLeftLegLayer.material = createMaterialArray(modelTextures.leftLegLayer, 'leftLegLayer');
            if (modelTextures.rightLeg) previewRightLeg.material = createMaterialArray(modelTextures.rightLeg, 'rightLeg');
            if (modelTextures.rightLegLayer) previewRightLegLayer.material = createMaterialArray(modelTextures.rightLegLayer, 'rightLegLayer');
        }
        
        function animate3DPreview() {
            requestAnimationFrame(animate3DPreview);
            
            if (previewPlayerGroup && previewAutoRotate) {
                previewRotation += 0.01;
                previewPlayerGroup.rotation.y = previewRotation;
            }
            
            if (previewRenderer && previewScene && previewCamera) {
                previewRenderer.render(previewScene, previewCamera);
            }
        }
        
        function renderTextureCanvas() {
            const canvas = document.getElementById('texturePixelGrid');
            if (!canvas) return;
            
            const dims = texturePartDimensions[currentBodyPart][currentTextureSide];
            const texture = modelTextures[currentBodyPart]?.[currentTextureSide];
            
            if (!texture) return;
            
            const ctx = canvas.getContext('2d');
            const pixelSize = 192 / Math.max(dims.w, dims.h);
            
            // Clear canvas with checkerboard background
            ctx.fillStyle = '#444';
            ctx.fillRect(0, 0, 192, 192);
            
            // Draw texture with transparency support
            for (let y = 0; y < dims.h; y++) {
                for (let x = 0; x < dims.w; x++) {
                    const i = (y * dims.w + x) * 4;
                    const r = texture.data[i];
                    const g = texture.data[i + 1];
                    const b = texture.data[i + 2];
                    const a = texture.data[i + 3];
                    
                    if (a > 0) {
                        ctx.fillStyle = `rgba(${r},${g},${b},${a / 255})`;
                        ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
                    }
                }
            }
            
            // Draw pixel grid
            ctx.strokeStyle = 'rgba(255,255,255,0.15)';
            ctx.lineWidth = 1;
            for (let x = 0; x <= dims.w; x++) {
                ctx.beginPath();
                ctx.moveTo(x * pixelSize, 0);
                ctx.lineTo(x * pixelSize, dims.h * pixelSize);
                ctx.stroke();
            }
            for (let y = 0; y <= dims.h; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * pixelSize);
                ctx.lineTo(dims.w * pixelSize, y * pixelSize);
                ctx.stroke();
            }
            
            // Update 3D preview
            update3DPreview();
        }
        
        function setupTextureCanvasEvents() {
            const canvas = document.getElementById('texturePixelGrid');
            if (!canvas) return;
            
            const paintPixel = (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const dims = texturePartDimensions[currentBodyPart][currentTextureSide];
                const pixelSize = 192 / Math.max(dims.w, dims.h);
                
                const px = Math.floor(x / pixelSize);
                const py = Math.floor(y / pixelSize);
                
                if (px >= 0 && px < dims.w && py >= 0 && py < dims.h) {
                    const texture = modelTextures[currentBodyPart][currentTextureSide];
                    const i = (py * dims.w + px) * 4;
                    
                    // Shift+Click to erase (make transparent)
                    if (e.shiftKey) {
                        texture.data[i] = 0;
                        texture.data[i + 1] = 0;
                        texture.data[i + 2] = 0;
                        texture.data[i + 3] = 0;
                    } else {
                        // Parse selected color and paint
                        const hex = selectedTextureColor.replace('#', '');
                        const r = parseInt(hex.substr(0, 2), 16);
                        const g = parseInt(hex.substr(2, 2), 16);
                        const b = parseInt(hex.substr(4, 2), 16);
                        
                        texture.data[i] = r;
                        texture.data[i + 1] = g;
                        texture.data[i + 2] = b;
                        texture.data[i + 3] = 255;
                    }
                    
                    renderTextureCanvas();
                }
            };
            
            canvas.onmousedown = (e) => {
                isTexturePainting = true;
                paintPixel(e);
            };
            
            canvas.onmousemove = (e) => {
                if (isTexturePainting) paintPixel(e);
            };
            
            canvas.onmouseup = () => { isTexturePainting = false; };
            canvas.onmouseleave = () => { isTexturePainting = false; };
        }
        
        function clearCurrentTexture() {
            const dims = texturePartDimensions[currentBodyPart][currentTextureSide];
            const texture = modelTextures[currentBodyPart][currentTextureSide];
            
            for (let i = 0; i < texture.data.length; i += 4) {
                texture.data[i] = 0;
                texture.data[i + 1] = 0;
                texture.data[i + 2] = 0;
                texture.data[i + 3] = 0;
            }
            
            renderTextureCanvas();
            playClickSound();
        }
        
        function resetAllTextures() {
            if (!confirm('Reset all textures to default?')) return;
            initializeModelTextures();
            renderTextureCanvas();
            playClickSound();
        }
        
        function saveModelTextures() {
            try {
                // Auto-sync fpHand with rightArm
                if (modelTextures.rightArm) {
                    modelTextures.fpHand = {};
                    for (let side in modelTextures.rightArm) {
                        // Deep copy the texture data
                        const sourceData = modelTextures.rightArm[side];
                        const newData = new Uint8ClampedArray(sourceData.data);
                        modelTextures.fpHand[side] = new ImageData(newData, sourceData.width, sourceData.height);
                    }
                }
                
                // Convert ImageData to serializable format with dimensions
                // Save EVERY layer and texture with complete information
                const serialized = {};
                const dimensions = {};
                
                for (let part in modelTextures) {
                    if (!modelTextures[part]) continue;
                    
                    serialized[part] = {};
                    dimensions[part] = {};
                    
                    for (let side in modelTextures[part]) {
                        const textureData = modelTextures[part][side];
                        if (!textureData) continue;
                        
                        // Save texture pixel data
                        serialized[part][side] = Array.from(textureData.data);
                        
                        // Save dimensions for each side
                        if (texturePartDimensions[part] && texturePartDimensions[part][side]) {
                            dimensions[part][side] = {
                                w: textureData.width || texturePartDimensions[part][side].w,
                                h: textureData.height || texturePartDimensions[part][side].h
                            };
                        } else {
                            dimensions[part][side] = {
                                w: textureData.width,
                                h: textureData.height
                            };
                        }
                    }
                }
                
                // Save to localStorage with metadata
                const saveData = {
                    textures: serialized,
                    dimensions: dimensions,
                    skinType: isSlimSkin ? 'slim' : 'classic',
                    timestamp: Date.now(),
                    version: '2.0' // Version for future compatibility
                };
                
                localStorage.setItem('modelTextures', JSON.stringify(saveData));
                
                // Also save dimensions separately for backward compatibility
                localStorage.setItem('modelTextureDimensions', JSON.stringify(texturePartDimensions));
                
                // Apply textures to 3D models
                applyTexturesToModels();
                
                // Also save to settings for persistence
                saveSettings();
                
                alert(' All model textures and layers saved successfully!\n(FP Hand synced with Right Arm)');
            } catch (e) {
                console.error('Could not save model textures:', e);
                alert(' Error saving textures: ' + e.message);
            }
            closeModelCustomizer();
        }
        
        function loadModelTextures() {
            try {
                const saved = localStorage.getItem('modelTextures');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    
                    // Handle new format (v2.0) with dimensions
                    let serialized, savedDimensions;
                    if (parsed.textures && parsed.dimensions) {
                        // New format
                        serialized = parsed.textures;
                        savedDimensions = parsed.dimensions;
                        
                        // Restore skin type if saved
                        if (parsed.skinType === 'slim' && !isSlimSkin) {
                            isSlimSkin = true;
                            texturePartDimensions = getTexturePartDimensions();
                            if (typeof createArms === 'function') createArms();
                        } else if (parsed.skinType === 'classic' && isSlimSkin) {
                            isSlimSkin = false;
                            texturePartDimensions = getTexturePartDimensions();
                            if (typeof createArms === 'function') createArms();
                        }
                    } else {
                        // Old format (backward compatibility)
                        serialized = parsed;
                        savedDimensions = {};
                    }
                    
                    // Load all textures with their saved dimensions
                    for (let part in serialized) {
                        if (!modelTextures[part]) modelTextures[part] = {};
                        
                        for (let side in serialized[part]) {
                            // Get dimensions from saved data or fallback
                            let dims;
                            if (savedDimensions[part] && savedDimensions[part][side]) {
                                dims = savedDimensions[part][side];
                            } else if (texturePartDimensions[part] && texturePartDimensions[part][side]) {
                                dims = texturePartDimensions[part][side];
                            } else {
                                dims = { w: 8, h: 8 }; // Fallback
                            }
                            
                            const data = new Uint8ClampedArray(serialized[part][side]);
                            modelTextures[part][side] = new ImageData(data, dims.w, dims.h);
                        }
                    }
                    
                    console.log(' Loaded all model textures and layers from localStorage');
                }
                
                // If no saved textures, ensure defaults are initialized
                if (Object.keys(modelTextures).length === 0) {
                    initializeModelTextures();
                }
            } catch (e) {
                console.warn('Could not load model textures:', e);
                // Initialize defaults on error
                if (Object.keys(modelTextures).length === 0) {
                    initializeModelTextures();
                }
            }
        }
        
        function applyTexturesToModels() {
            // Safety check - don't apply if textures aren't initialized
            if (!modelTextures || Object.keys(modelTextures).length === 0) {
                return;
            }
            if (!texturePartDimensions || Object.keys(texturePartDimensions).length === 0) {
                return;
            }
            
            // Helper to create material array for a body part
            // Three.js BoxGeometry face order: [right, left, top, bottom, front, back]
            const createMaterialArray = (partTextures, partName) => {
                if (!partTextures) return null;
                
                const sides = ['right', 'left', 'top', 'bottom', 'front', 'back'];
                const isLayer = partName.includes('Layer'); // Check if this is a layer part
                
                return sides.map(side => {
                    const textureData = partTextures[side];
                    if (!textureData) {
                        // Fallback to default color
                        let color = 0xd4a574;
                        if (partName === 'torso') color = 0x4080ff;
                        if (partName.includes('Leg')) color = 0x404080;
                        return new THREE.MeshLambertMaterial({ 
                            color,
                            transparent: isLayer,
                            opacity: isLayer ? 0 : 1,
                            depthWrite: !isLayer
                        });
                    }
                    
                    const dims = texturePartDimensions && texturePartDimensions[partName] && texturePartDimensions[partName][side]
                        ? texturePartDimensions[partName][side]
                        : { w: 8, h: 8 }; // Fallback dimensions
                    const canvas = document.createElement('canvas');
                    canvas.width = dims.w;
                    canvas.height = dims.h;
                    const ctx = canvas.getContext('2d');
                    ctx.putImageData(textureData, 0, 0);
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    texture.magFilter = THREE.NearestFilter;
                    texture.minFilter = THREE.NearestFilter;
                    
                    return new THREE.MeshLambertMaterial({ 
                        map: texture,
                        transparent: isLayer, // Layers support transparency
                        alphaTest: isLayer ? 0.1 : 0, // Only render pixels with alpha > 0.1 for layers
                        depthWrite: !isLayer
                    });
                });
            };
            
            // Apply to head
            if (headMesh && modelTextures.head) {
                const materials = createMaterialArray(modelTextures.head, 'head');
                if (materials) {
                    headMesh.material = materials;
                }
            }
            
            // Apply to torso
            if (bodyMesh && modelTextures.torso) {
                const materials = createMaterialArray(modelTextures.torso, 'torso');
                if (materials) {
                    bodyMesh.material = materials;
                }
            }
            
            // Apply to left arm
            if (leftArm && modelTextures.leftArm) {
                const materials = createMaterialArray(modelTextures.leftArm, 'leftArm');
                if (materials) {
                    leftArm.material = materials;
                }
            }
            
            // Apply to right arm
            if (rightArm && modelTextures.rightArm) {
                const materials = createMaterialArray(modelTextures.rightArm, 'rightArm');
                if (materials) {
                    rightArm.material = materials;
                }
            }
            
            // Apply to left leg
            if (leftLeg && modelTextures.leftLeg) {
                const materials = createMaterialArray(modelTextures.leftLeg, 'leftLeg');
                if (materials) {
                    leftLeg.material = materials;
                }
            }
            
            // Apply to right leg
            if (rightLeg && modelTextures.rightLeg) {
                const materials = createMaterialArray(modelTextures.rightLeg, 'rightLeg');
                if (materials) {
                    rightLeg.material = materials;
                }
            }
            
            // Apply to first-person hand - always use rightArm texture
            // fpHandMesh is a Group, so we need to find the child meshes
            if (fpHandMesh && modelTextures.rightArm) {
                const materials = createMaterialArray(modelTextures.rightArm, 'rightArm');
                if (materials) {
                    // Find the base hand mesh (renderOrder 0)
                    fpHandMesh.traverse((child) => {
                        if (child.type === 'Mesh' && child.renderOrder === 0) {
                            child.material = materials;
                        }
                    });
                }
            }
            
            // Apply to first-person hand layer (sleeve)
            // fpHandLayerMesh is stored globally but is also a child of fpHandMesh group
            if (fpHandLayerMesh && modelTextures.rightArmLayer) {
                const layerMaterials = createMaterialArray(modelTextures.rightArmLayer, 'rightArmLayer');
                if (layerMaterials) {
                    fpHandLayerMesh.material = layerMaterials;
                    fpHandLayerMesh.visible = showSkinLayers; // Show based on setting
                }
            } else if (fpHandMesh && modelTextures.rightArmLayer) {
                // Fallback: find layer mesh in group if fpHandLayerMesh not set
                const layerMaterials = createMaterialArray(modelTextures.rightArmLayer, 'rightArmLayer');
                if (layerMaterials) {
                    fpHandMesh.traverse((child) => {
                        if (child.type === 'Mesh' && child.renderOrder === 1) {
                            child.material = layerMaterials;
                            child.visible = showSkinLayers;
                        }
                    });
                }
            }
            
            // Also apply if old heldItemMesh was a hand (legacy support)
            if (heldItemMesh && heldItemMesh.type === 'Mesh' && !heldItemMesh.userData.isItem) {
                const materials = createMaterialArray(modelTextures.rightArm, 'rightArm');
                if (materials) {
                    heldItemMesh.material = materials;
                }
            }
            
            // Apply LAYER textures (hat, jacket, sleeves, pants)
            // Apply to head layer (hat)
            if (headLayerMesh && modelTextures.headLayer) {
                const materials = createMaterialArray(modelTextures.headLayer, 'headLayer');
                if (materials) {
                    headLayerMesh.material = materials;
                    headLayerMesh.visible = showSkinLayers; // Only show when texture is applied
                }
            }
            
            // Apply to torso layer (jacket)
            if (bodyLayerMesh && modelTextures.torsoLayer) {
                const materials = createMaterialArray(modelTextures.torsoLayer, 'torsoLayer');
                if (materials) {
                    bodyLayerMesh.material = materials;
                    bodyLayerMesh.visible = showSkinLayers; // Only show when texture is applied
                }
            }
            
            // Apply to left arm layer (sleeve)
            if (leftArmLayerMesh && modelTextures.leftArmLayer) {
                const materials = createMaterialArray(modelTextures.leftArmLayer, 'leftArmLayer');
                if (materials) {
                    leftArmLayerMesh.material = materials;
                    leftArmLayerMesh.visible = showSkinLayers; // Only show when texture is applied
                }
            }
            
            // Apply to right arm layer (sleeve)
            if (rightArmLayerMesh && modelTextures.rightArmLayer) {
                const materials = createMaterialArray(modelTextures.rightArmLayer, 'rightArmLayer');
                if (materials) {
                    rightArmLayerMesh.material = materials;
                    rightArmLayerMesh.visible = showSkinLayers; // Only show when texture is applied
                }
            }
            
            // Apply to left leg layer (pants)
            if (leftLegLayerMesh && modelTextures.leftLegLayer) {
                const materials = createMaterialArray(modelTextures.leftLegLayer, 'leftLegLayer');
                if (materials) {
                    leftLegLayerMesh.material = materials;
                    leftLegLayerMesh.visible = showSkinLayers; // Only show when texture is applied
                }
            }
            
            // Apply to right leg layer (pants)
            if (rightLegLayerMesh && modelTextures.rightLegLayer) {
                const materials = createMaterialArray(modelTextures.rightLegLayer, 'rightLegLayer');
                if (materials) {
                    rightLegLayerMesh.material = materials;
                    rightLegLayerMesh.visible = showSkinLayers; // Only show when texture is applied
                }
            }
            
            // Apply to first-person hand layer (sleeve)
            if (fpHandLayerMesh && modelTextures.rightArmLayer) {
                const materials = createMaterialArray(modelTextures.rightArmLayer, 'rightArmLayer');
                if (materials) {
                    fpHandLayerMesh.material = materials;
                }
            }
            
            console.log(' Textures applied to all 6 sides of 3D models (base + layers)');
        }
        
        // Initialize texture system when modal opens
        setTimeout(() => {
            setupTextureCanvasEvents();
        }, 100);
        
        // ==================== END NEW FEATURES ====================
        
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initAudioSliders);
        } else {
            initAudioSliders();
        }
        // ==================== END AUDIO SLIDERS INITIALIZATION ====================
        
        
        // ==================== ADD SOUND EFFECTS TO ALL BUTTONS ====================
        // Add click sound to all buttons
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize audio sliders after DOM is ready
            initAudioSliders();
            
            const allButtons = document.querySelectorAll('button, .main-menu-btn');
            
            allButtons.forEach(button => {
                // Click sound
                button.addEventListener('click', function() {
                    playClickSound();
                });
                
                // Hover sound (only once per hover)
                let isHovering = false;
                button.addEventListener('mouseenter', function() {
                    if (!isHovering) {
                        isHovering = true;
                        playHoverSound();
                    }
                });
                button.addEventListener('mouseleave', function() {
                    isHovering = false;
                });
            });
            
            // Start background music when main menu is visible
            setTimeout(() => {
                if (document.getElementById('main-menu').style.display !== 'none') {
                    startBackgroundMusic();
                }
            }, 500);
        });
        // END NEW
        
        // NEW: Game Mode Toggle Listener
        if (gameModeToggleBtn) {
            gameModeToggleBtn.addEventListener('click', toggleGameMode);
        }


        // --- Game Start Logic (CREATE WORLD) ---
        document.getElementById('createWorldBtn').addEventListener('click', function() {
            const seedInput = document.getElementById('seedInput').value;
            const flatWorldCheckbox = document.getElementById('flatWorldCheckbox');
            const worldBorderCheckbox = document.getElementById('worldBorderCheckbox');
            
            WORLD_SEED = seedInput ? parseInt(seedInput) : Math.floor(Math.random() * 1000000); 
            isFlatWorld = flatWorldCheckbox.checked; // NEW: Set flat world option
            worldBorderEnabled = worldBorderCheckbox.checked; // NEW: Set world border option
            
            // Prompt for world name
            let worldName = prompt('Enter a name for your world:', 'My World ' + WORLD_SEED);
            
            // FIX: Only proceed if user didn't cancel the prompt
            if (worldName === null) {
                // User cancelled, don't create the world
                return;
            }
            
            // Use default name if empty string
            if (!worldName || worldName.trim() === '') {
                worldName = 'World_' + WORLD_SEED;
            }
            
            resetPlayer();
            generateWorld();
            generateInventorySlots(); // This now also generates the block picker
            updateToolbarSelection(); 
            updateGameModeButtonText(); // Set initial button text
            
            // Initialize game start time
            window.gameStartTime = Date.now();
            
            // Save the new world
            const savedWorldName = saveWorld(worldName);
            
            // If save failed (quota exceeded), don't start the game
            if (!savedWorldName) {
                // Reset to prevent being stuck
                return;
            }
            
            startAutoSave(worldName);

            const mainMenuEl = document.getElementById('main-menu');
            mainMenuEl.style.display = 'none';
            // Stop parallax animation completely during gameplay
            mainMenuEl.style.animation = 'none';
            mainMenuEl.style.backgroundColor = 'transparent';
            
            // Set game state to IN_GAME
            setGameState(GAME_STATE.IN_GAME);
            
            // Hide parallax/starfield effect when game starts
            const starfieldCanvas = document.getElementById('starfield-bg');
            if (starfieldCanvas) {
                starfieldCanvas.classList.remove('active');
                starfieldCanvas.style.opacity = '0';
            }
            
            // Music continues playing during gameplay
            // MODIFIED: Use cross-browser requestLock function
            requestLock(renderer.domElement); 
            document.getElementById('crosshair').style.display = 'block';
            document.getElementById('toolbar').style.display = 'flex'; // FIX: Show the hotbar
            document.getElementById('health-container').style.display = 'block'; // Show health
            document.getElementById('fps').style.display = (fpsAlwaysVisible && currentGameState === GAME_STATE.IN_GAME) ? 'block' : 'none'; // FPS only in-game
            const uiElement = document.getElementById('ui');
            if (uiElement) uiElement.style.display = 'none'; // Hidden by default, toggle with F3
            const debugInfoElement = document.getElementById('debug-info');
            if (debugInfoElement) debugInfoElement.style.display = 'none'; // Hidden by default, toggle with F3
            
            if (!window.gameLoopStarted) {
                loop();
                window.gameLoopStarted = true;
            }
        });
        
        // --- Input and Raycasting ---
        
        // --- REFACTORED: Global Mouse Move Listener ---
        document.addEventListener('mousemove', function(e) {
            if (inventoryOpen) {
                // --- FAKE CURSOR MOVEMENT ---
                if (locked) {
                    // Pointer lock active: use deltas
                    fakeCursorX += e.movementX;
                    fakeCursorY += e.movementY;
                } else {
                    // No pointer lock: use absolute mouse position
                    fakeCursorX = e.clientX;
                    fakeCursorY = e.clientY;
                }

                // Clamp to screen bounds
                fakeCursorX = Math.max(0, Math.min(window.innerWidth - 1, fakeCursorX));
                fakeCursorY = Math.max(0, Math.min(window.innerHeight - 1, fakeCursorY));

                // Apply style
                if (fakeCursorElement) {
                    fakeCursorElement.style.left = fakeCursorX + 'px';
                    fakeCursorElement.style.top = fakeCursorY + 'px';
                }
                
                // Handle scrollbar dragging
                const scrollbarWrapper = document.getElementById('crafting-recipes-wrapper');
                if (scrollbarWrapper && window.isDraggingScrollbar && window.handleScrollbarDrag) {
                    window.handleScrollbarDrag(fakeCursorY);
                }
                
                // Make picked-up item follow cursor
                if (pickedUpItem && pickedUpItemElement) {
                    pickedUpItemElement.style.left = fakeCursorX + 'px';
                    pickedUpItemElement.style.top = fakeCursorY + 'px'; 
                }

            } else if (locked && !paused && !inventoryOpen) {
                // --- CAMERA ROTATION (with sensitivity) ---
                ry -= e.movementX * 0.002 * mouseSensitivity;
                rx -= e.movementY * 0.002 * mouseSensitivity;
                // Clamp pitch to avoid gimbal and oscillations in 3rd-person while still allowing near-vertical look
                const PITCH_LIMIT = Math.PI / 2 - 0.05;
                rx = Math.max(-PITCH_LIMIT, Math.min(PITCH_LIMIT, rx));
            }
        });


        renderer.domElement.addEventListener('wheel', function(e) {
            if (!locked || paused || inventoryOpen) return; // Prevent hotbar changes when inventory is open
            e.preventDefault();
            
            const HUD_SIZE = HUD_WIDTH; 

            if (e.deltaY > 0) { sel = (sel + 1) % HUD_SIZE; } 
            else if (e.deltaY < 0) { sel = (sel - 1 + HUD_SIZE) % HUD_SIZE; }
            
            updateToolbarSelection();
        });

        var ray = new THREE.Raycaster();
        ray.far = 15;
        
        // --- MINECRAFT-ACCURATE MINING SYSTEM ---
        let isLeftMouseDown = false;
        let miningTarget = null; // {x, y, z, progress, requiredTime, crackOverlay}
        let isRightMouseDown = false;
        let placingCooldown = 0;
        let breakingCooldown = 0; // Cooldown after breaking a block
        const PLACE_DELAY = 1.0; // 1 second between placements
        const BREAK_COOLDOWN_SURVIVAL = 0.1; // 0.1 second cooldown after breaking in survival
        const BREAK_COOLDOWN_CREATIVE = 0.25; // 0.25 second cooldown after breaking in creative
        
        // Mining times in seconds (based on Minecraft)
        const MINING_TIMES = {
            // Block types with their mining times
            stone: { hand: 10.0, pickaxe: 1.5 },
            dirt: { hand: 0.5, tool: 0.5 },
            wood: { hand: 3.0, axe: 0.8 },
            planks: { hand: 3.0, axe: 0.8 },
            sand: { hand: 1.6, tool: 0.4 },
            grass: { hand: 1.0, tool: 0.5 },
            leaves: { hand: 0.2, tool: 0.2 }
        };
        
        // Function to determine mining time based on block and tool
        function getMiningTime(blockType, toolType) {
            if (isCreativeMode) return 0; // Instant break in creative
            
            const hudIndex = getHUDIndex(sel);
            const heldItem = inventoryData[hudIndex];
            const itemType = heldItem ? heldItem.type : null;
            
            // Check if holding a tool
            const isPickaxe = itemType < 0 && itemDefinitions[itemType]?.isPickaxe;
            const isAxe = itemType < 0 && itemDefinitions[itemType]?.isAxe;
            const hasTool = isPickaxe || isAxe || (itemType < 0 && itemDefinitions[itemType]?.isTool);
            
            // Map block types to mining times
            switch(blockType) {
                case 2: // Stone (STONE_TYPE)
                case 5: // Bedrock (BEDROCK_TYPE) 
                case 12: // Cobblestone (COBBLESTONE_TYPE)
                    return isPickaxe ? MINING_TIMES.stone.pickaxe : MINING_TIMES.stone.hand;
                    
                case 1: // Dirt (DIRT_TYPE)
                    return hasTool ? MINING_TIMES.dirt.tool : MINING_TIMES.dirt.hand;
                    
                case 3: // Wood (WOOD_TYPE)
                    return isAxe ? MINING_TIMES.wood.axe : MINING_TIMES.wood.hand;
                    
                case 12: // Planks (PLANKS_TYPE)
                    return isAxe ? MINING_TIMES.planks.axe : MINING_TIMES.planks.hand;
                    
                case 4: // Sand (SAND_TYPE)
                    return hasTool ? MINING_TIMES.sand.tool : MINING_TIMES.sand.hand;
                    
                case 0: // Grass (GRASS_TYPE)
                    return MINING_TIMES.grass.hand; // Always 0.5s
                    
                case 6: // Leaves (LEAVES_TYPE)
                    return MINING_TIMES.leaves.hand; // Always 0.2s
                    
                case 7: // Glass (GLASS_TYPE)
                    return hasTool ? 0.3 : 1.2;
                    
                case 8: // Door (DOOR_TYPE)
                case 9: // Torch (TORCH_TYPE)
                    return isAxe ? 0.5 : 2.0;
                    
                default:
                    return hasTool ? 1.0 : 3.0; // Default times
            }
        }
        
        // Function to check if block drops when mined with current tool
        function shouldDropBlock(blockType) {
            if (isCreativeMode) return false; // Creative doesn't need drops
            
            const hudIndex = getHUDIndex(sel);
            const heldItem = inventoryData[hudIndex];
            const itemType = heldItem ? heldItem.type : null;
            const isPickaxe = itemType < 0 && itemDefinitions[itemType]?.isPickaxe;
            
            // Stone, cobblestone, bedrock require pickaxe
            if (blockType === 2 || blockType === 5 || blockType === 12) {
                return isPickaxe;
            }
            
            // All other blocks always drop (grass, leaves, dirt, sand, wood, etc.)
            return true;
        }
        
        // Create crack overlay mesh for mining animation
        function createCrackOverlay(x, y, z, progress) {
            // Calculate crack stage (0-9 based on progress 0-1)
            const stage = Math.floor(progress * 10);
            if (stage >= 10 || stage < 0) return null; // Safety check for invalid stages
            
            // Create a slightly larger box around the block to show cracks
            const crackGeometry = new THREE.BoxGeometry(bs * 1.005, bs * 1.005, bs * 1.005);
            
            // Create canvas for crack texture
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            // Draw crack pattern based on stage
            ctx.fillStyle = 'rgba(0, 0, 0, 0)';
            ctx.fillRect(0, 0, 64, 64);
            
            // Draw realistic fracture-style cracks
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1.5 + (stage * 0.3);
            ctx.globalAlpha = 0.7 + (stage * 0.03);
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            // Use a seed based on block position for consistent crack patterns
            const seed = (x * 73856093) ^ (y * 19349663) ^ (z * 83492791);
            const random = (n) => {
                const val = Math.sin(seed + n) * 43758.5453123;
                return val - Math.floor(val);
            };
            
            // Draw main crack lines with branches
            const numMainCracks = 1 + Math.floor(stage / 3);
            for (let i = 0; i < numMainCracks; i++) {
                // Start from a random edge point
                const startSide = Math.floor(random(i * 4) * 4);
                let startX, startY;
                
                switch(startSide) {
                    case 0: // Top
                        startX = random(i * 4 + 1) * 64;
                        startY = 0;
                        break;
                    case 1: // Right
                        startX = 64;
                        startY = random(i * 4 + 1) * 64;
                        break;
                    case 2: // Bottom
                        startX = random(i * 4 + 1) * 64;
                        startY = 64;
                        break;
                    default: // Left
                        startX = 0;
                        startY = random(i * 4 + 1) * 64;
                }
                
                // Draw main crack line with organic curves
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                
                let currentX = startX;
                let currentY = startY;
                let targetX = 32 + (random(i * 4 + 2) - 0.5) * 40;
                let targetY = 32 + (random(i * 4 + 3) - 0.5) * 40;
                
                const segments = 3 + Math.floor(stage / 2);
                for (let j = 0; j < segments; j++) {
                    const t = (j + 1) / segments;
                    const nextX = currentX + (targetX - currentX) * 0.7 + (random(i * 10 + j) - 0.5) * 15;
                    const nextY = currentY + (targetY - currentY) * 0.7 + (random(i * 10 + j + 100) - 0.5) * 15;
                    
                    ctx.lineTo(nextX, nextY);
                    
                    // Add branch cracks as stage increases
                    if (stage > 3 && j > 0 && random(i * 20 + j) > 0.6) {
                        const branchLength = 10 + stage * 2;
                        const branchAngle = (random(i * 30 + j) - 0.5) * Math.PI;
                        const branchX = nextX + Math.cos(branchAngle) * branchLength;
                        const branchY = nextY + Math.sin(branchAngle) * branchLength;
                        
                        ctx.moveTo(nextX, nextY);
                        ctx.lineTo(branchX, branchY);
                        ctx.moveTo(nextX, nextY);
                    }
                    
                    currentX = nextX;
                    currentY = nextY;
                }
                ctx.stroke();
            }
            
            // Add small crack details for higher stages
            if (stage > 5) {
                ctx.lineWidth = 1;
                ctx.globalAlpha = 0.5;
                const numSmallCracks = (stage - 5) * 2;
                
                for (let i = 0; i < numSmallCracks; i++) {
                    ctx.beginPath();
                    const sx = random(i * 50) * 64;
                    const sy = random(i * 50 + 25) * 64;
                    const ex = sx + (random(i * 50 + 50) - 0.5) * 15;
                    const ey = sy + (random(i * 50 + 75) - 0.5) * 15;
                    
                    ctx.moveTo(sx, sy);
                    ctx.lineTo(ex, ey);
                    ctx.stroke();
                }
            }
            
            // Create texture from canvas
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            
            // Create materials for all 6 faces with the crack texture
            const materials = [];
            for (let i = 0; i < 6; i++) {
                materials.push(new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    opacity: 0.8,
                    depthTest: true,
                    depthWrite: false,
                    side: THREE.FrontSide
                }));
            }
            
            const crackMesh = new THREE.Mesh(crackGeometry, materials);
            crackMesh.position.set(x * bs, y * bs, z * bs);
            
            return crackMesh;
        }
        
        // --- REFACTORED: Global Mousedown Listener ---
        renderer.domElement.addEventListener('mousedown', function(e) {
            // Request pointer lock if not already locked and not in menu/inventory
            if (!locked && !paused && !inventoryOpen && !isDead) {
                requestLock(renderer.domElement);
                return;
            }
            
            if (inventoryOpen) {
                // --- FAKE CURSOR CLICK LOGIC ---
                // We are in the inventory. Do not fire a raycaster.
                
                // 1. Get the element under the *fake cursor*
                if (!fakeCursorElement) return; // Safety check
                fakeCursorElement.style.display = 'none'; // Hide cursor to perform hit test
                let elementUnderCursor = document.elementFromPoint(fakeCursorX, fakeCursorY);
                fakeCursorElement.style.display = 'block'; // Show it again

                if (!elementUnderCursor) return;

                const slotElement = elementUnderCursor.closest('.inventory-slot');
                
                if (slotElement) {
                    // We clicked a slot in *either* inventory or block picker
                    if (slotElement.closest('#creative-block-picker')) {
                        // --- Clicked on Block Picker ---
                        if (!isCreativeMode) return;
                        const type = parseInt(slotElement.dataset.type);
                        
                        // Check if it's a tool
                        const isTool = type < 0 && itemDefinitions[type] && itemDefinitions[type].isTool;
                        
                        if (isTool) {
                            // Tools: grab 1 with full durability
                            const itemDef = itemDefinitions[type];
                            pickedUpItem = { 
                                type: type, 
                                count: 1,
                                durability: itemDef.maxDurability 
                            };
                        } else {
                            // Regular items: grab a stack
                            pickedUpItem = { type: type, count: 64 };
                        }
                        
                        playClickSound(); // Audio feedback
                        updateInventoryUI();

                    } else if (slotElement.closest('.inventory-container')) {
                        // --- Clicked on Main Inventory ---
                        
                        // Move keyboard cursor to match (for visual feedback)
                        cursorX = parseInt(slotElement.dataset.x);
                        cursorY = parseInt(slotElement.dataset.y);
                        const slotIndex = parseInt(slotElement.dataset.index);

                        if (e.button === 0) { // Left-Click
                            playClickSound(); // Audio feedback
                            swapItems(slotIndex);
                        } else if (e.button === 2) { // Right-Click
                            e.preventDefault();
                            playClickSound(); // Audio feedback
                            handleInventoryRightClick(slotIndex); // Use new function
                        }
                    }
                } else if (elementUnderCursor.classList && elementUnderCursor.classList.contains('crafting-slot')) {
                    // --- Clicked on Crafting Grid ---
                    const craftIndex = parseInt(elementUnderCursor.dataset.index);
                    
                    if (e.button === 0) { // Left-Click
                        const craftItem = craftingGrid[craftIndex];
                        
                        if (pickedUpItem) {
                            playClickSound(); // Audio feedback
                            // Placing item in crafting grid
                            if (craftItem && pickedUpItem.type === craftItem.type) {
                                // Stack items
                                craftItem.count += pickedUpItem.count;
                                pickedUpItem = null;
                            } else {
                                // Swap items
                                craftingGrid[craftIndex] = { ...pickedUpItem, count: 1 };
                                pickedUpItem.count--;
                                if (pickedUpItem.count === 0) pickedUpItem = null;
                            }
                        } else if (craftItem) {
                            playClickSound(); // Audio feedback
                            // Picking up item from crafting grid
                            pickedUpItem = craftItem;
                            craftingGrid[craftIndex] = null;
                        }
                        
                        updateCraftingUI();
                        updateInventoryUI();
                    }
                } else if (elementUnderCursor.id === 'crafting-output') {
                    // --- Clicked on Crafting Output ---
                    if (craftingOutput && e.button === 0) {
                        playClickSound(); // Audio feedback
                        craftItem();
                    }
                } else if (elementUnderCursor.id === 'gameModeToggleBtn') {
                    // Clicked the toggle button
                    toggleGameMode();
                } else if (elementUnderCursor.classList && elementUnderCursor.classList.contains('category-tab')) {
                    // --- Clicked on Category Tab ---
                    const category = elementUnderCursor.dataset.category;
                    if (category) {
                        currentCategory = category;
                        
                        // Update active tab
                        const tabs = document.querySelectorAll('.category-tab');
                        tabs.forEach(t => t.classList.remove('active'));
                        elementUnderCursor.classList.add('active');
                        
                        // Regenerate picker with new category
                        generateBlockPicker(category);
                        
                        // Play click sound
                        playClickSound();
                    }
                } else if (elementUnderCursor.closest('#delete-slot')) {
                    // --- NEW: Clicked on Delete Slot ---
                    if (pickedUpItem) {
                        playClickSound(); // Audio feedback
                        pickedUpItem = null;
                        updateInventoryUI(); // Update UI to remove item from keyboard slot
                    }
                }

                return; // IMPORTANT: Stop processing, don't break/place blocks
            }

            // --- Original Raycasting Logic (if inventory is not open) ---
            if (!locked || paused || isDead) return;

            ray.setFromCamera(new THREE.Vector2(0, 0), camera);
            
            var objs = Object.values(world); 
            var hits = ray.intersectObjects(objs);
            
            if (hits.length > 0) {
                var hit = hits[0];
                var pos = hit.object.position;
                var bx = Math.round(pos.x / bs);
                var by = Math.round(pos.y / bs);
                var bz = Math.round(pos.z / bs);
                
                // Check if clicked block is a door
                const clickedBlock = world[key(bx, by, bz)];
                const isDoor = clickedBlock && clickedBlock.userData.blockType === DOOR_TYPE;

                if (e.button === 0) { // Left-Click (Start Mining)
                    isLeftMouseDown = true;
                    breakingCooldown = 0; // Reset cooldown on new click to allow immediate mining
                    
                    // Start mining this block
                    if (!miningTarget || miningTarget.x !== bx || miningTarget.y !== by || miningTarget.z !== bz) {
                        const requiredTime = getMiningTime(clickedBlock.userData.blockType);
                        miningTarget = {
                            x: bx,
                            y: by,
                            z: bz,
                            progress: 0,
                            requiredTime: requiredTime,
                            crackOverlay: null
                        };
                    }
                    
                    // Trigger hand swing animation
                    isSwinging = true;
                    handSwingTimer = 0;
                    
                } else if (e.button === 1) { // Middle-Click (Block Picker)
                    e.preventDefault();
                    
                    // Get the block type being looked at
                    if (clickedBlock && clickedBlock.userData.blockType !== undefined) {
                        const blockType = clickedBlock.userData.blockType;
                        handleMiddleClickBlockPick(blockType);
                    }
                    
                } else if (e.button === 2) { // Right-Click
                    isRightMouseDown = true; // Track right mouse down for continuous placing
                    
                    // If clicking on a door, toggle it instead of placing a block
                    if (isDoor) {
                        toggleDoor(bx, by, bz);
                        return; // Don't place blocks when clicking on door
                    }
                    
                    // Get current held item
                    const hudIndex = getHUDIndex(sel);
                    const item = inventoryData[hudIndex];
                    
                    // Otherwise, place block as normal
                    if (item && item.count > 0) {
                        // Check if it's a placeable item (like planks)
                        let placeableType = item.type;
                        if (item.type < 0) {
                            // It's an item, check if placeable
                            const itemDef = itemDefinitions[item.type];
                            if (!itemDef || !itemDef.isPlaceable) {
                                return; // Can't place tools/non-placeable items
                            }
                            // Place planks as planks blocks (not wood)
                            placeableType = PLANKS_TYPE;
                        }
                        
                        if (window.activeBlockType !== null || placeableType >= 0) {
                            var n = hit.face.normal;
                            // Determine placement coords
                            var plx, ply, plz;
                            const clickedType = clickedBlock?.userData.blockType;
                            if (clickedType === WATER_TYPE || clickedType === LAVA_TYPE) {
                                // Place inside the liquid block (replace it)
                                plx = bx; ply = by; plz = bz;
                            } else {
                                plx = bx + Math.round(n.x);
                                ply = by + Math.round(n.y);
                                plz = bz + Math.round(n.z);
                            }
                            
                            var pbx = Math.round(px / bs);
                            var pby = Math.round(py / bs);
                            var pbz = Math.round(pz / bs);
                            
                            var ok = true;
                            if (plx === pbx && ply === pby && plz === pbz) ok = false;
                            if (plx === pbx && ply === pby - 1 && plz === pbz) ok = false; 
                            
                            // Check occupancy, but allow replacing liquids
                            const targetBlock = world[key(plx, ply, plz)];
                            if (targetBlock) {
                                const tType = targetBlock.userData.blockType;
                                const isLiquid = (tType === WATER_TYPE || tType === LAVA_TYPE);
                                if (!isLiquid) ok = false; // solid or non-replaceable blocks prevent placement
                            }
                            
                            // For doors, also check if space above is free (unless replacing a liquid there)
                            if (placeableType === DOOR_TYPE) {
                                const aboveBlock = world[key(plx, ply + 1, plz)];
                                const aboveIsLiquid = aboveBlock && (aboveBlock.userData.blockType === WATER_TYPE || aboveBlock.userData.blockType === LAVA_TYPE);
                                if (aboveBlock && !aboveIsLiquid) ok = false;
                            }

                            if (ok) {
                                // Calculate camera facing angle for door placement
                                const facingAngle = ry; // Camera's yaw rotation
                                add(plx, ply, plz, placeableType, facingAngle);
                                playPlaceSound(placeableType);

                                // --- SURVIVAL MODE: Consume Block ---
                                if (!isCreativeMode) {
                                    item.count--; 
                                    if (item.count <= 0) { inventoryData[hudIndex] = null; } 
                                }

                                updateInventoryUI();
                                updateToolbarSelection();
                                
                                // Trigger hand placing animation
                                isSwinging = true;
                                handSwingTimer = 0;
                                
                                // Set cooldown for continuous placing
                                placingCooldown = PLACE_DELAY;
                            }
                        }
                    }
                }
            }
        });

        renderer.domElement.addEventListener('contextmenu', function(e) { e.preventDefault(); });
        
        // --- MOUSEUP: Stop continuous mining and placing ---
        renderer.domElement.addEventListener('mouseup', function(e) {
            if (e.button === 0) {
                isLeftMouseDown = false;
                // Reset mining target and remove crack overlay
                if (miningTarget) {
                    if (miningTarget.crackOverlay) {
                        scene.remove(miningTarget.crackOverlay);
                    }
                    miningTarget = null;
                }
            } else if (e.button === 2) {
                isRightMouseDown = false;
            }
        });

        btns.forEach(function(btn, index) {
            btn.addEventListener('click', function() {
                sel = index; 
                updateToolbarSelection();
            });
        });
        
        updateToolbarSelection(); 

        
        function check(x, y, z, r) {
            // OPTIMIZED: Efficient hitbox collision detection with sweep test
            // Only check immediately adjacent blocks
            var cx = Math.round(x / bs);
            var cy = Math.round(y / bs);
            var cz = Math.round(z / bs);
            
            // Reduced test area - only check blocks that could actually collide
            var tests = [
                [0, 0, 0],                         // Current position
                [0, -1, 0], [0, 1, 0],            // Vertical
                [-1, 0, 0], [1, 0, 0],             // X-axis
                [0, 0, -1], [0, 0, 1]              // Z-axis
            ]; 
            
            for (var i = 0; i < tests.length; i++) {
                var tx = cx + tests[i][0];
                var ty = cy + tests[i][1];
                var tz = cz + tests[i][2];
                
                var blockKey = key(tx, ty, tz);
                if (world[blockKey]) {
                    var block = world[blockKey];
                    
                    // Skip collision for torches
                    if (block.userData.isTorch) {
                        continue;
                    }
                    
                    // Skip collision for water and lava (allow swimming through)
                    if (block.userData.blockType === WATER_TYPE || block.userData.blockType === LAVA_TYPE) {
                        continue;
                    }
                    
                    // Skip collision for open doors
                    if (block.userData.blockType === DOOR_TYPE && block.userData.doorOpen) {
                        continue;
                    }
                    
                    // For closed doors, check both blocks (2 blocks tall) with thin hitbox
                    if (block.userData.blockType === DOOR_TYPE) {
                        var doorBottomY = block.userData.doorBottomY;
                        var doorTopY = doorBottomY + 1;
                        
                        // Check collision for full 2-block height
                        if (ty === doorBottomY || ty === doorTopY) {
                            var bpx = tx * bs;
                            var bpz = tz * bs;
                            
                            var margin = 0.02;
                            var doorThickness = bs * 0.125; // Door is 0.25 blocks wide, so half is 0.125
                            
                            // Get door rotation to determine orientation
                            var doorRotation = block.rotation.y % (Math.PI * 2);
                            var isNorthSouth = Math.abs(Math.sin(doorRotation)) > 0.5; // N/S or E/W
                            
                            // Full 2-block height collision
                            var doorBottomWorldY = doorBottomY * bs;
                            var doorTopWorldY = (doorTopY + 1) * bs; // Top of the 2nd block
                            
                            // Thin collision box based on door orientation
                            if (isNorthSouth) {
                                // Door runs North-South (thin on X axis)
                                if (x + r > bpx - doorThickness + margin && 
                                    x - r < bpx + doorThickness - margin &&
                                    z + r > bpz - bs/2 + margin && 
                                    z - r < bpz + bs/2 - margin &&
                                    y + margin > doorBottomWorldY && 
                                    y - PLAYER_HEIGHT < doorTopWorldY - margin) {
                                    return block;
                                }
                            } else {
                                // Door runs East-West (thin on Z axis)
                                if (x + r > bpx - bs/2 + margin && 
                                    x - r < bpx + bs/2 - margin &&
                                    z + r > bpz - doorThickness + margin && 
                                    z - r < bpz + doorThickness - margin &&
                                    y + margin > doorBottomWorldY && 
                                    y - PLAYER_HEIGHT < doorTopWorldY - margin) {
                                    return block;
                                }
                            }
                        }
                        continue;
                    }
                    
                    var bpx = tx * bs;
                    var bpy = ty * bs;
                    var bpz = tz * bs;
                    
                    // OPTIMIZED: Slightly tighter boundaries with margin to prevent sticking
                    var halfBlock = bs / 2;
                    var margin = 0.02; // Small margin to prevent edge cases
                    
                    // AABB collision with margin
                    if (x + r > bpx - halfBlock + margin && 
                        x - r < bpx + halfBlock - margin &&
                        z + r > bpz - halfBlock + margin && 
                        z - r < bpz + halfBlock - margin &&
                        y + margin > bpy - halfBlock && 
                        y - PLAYER_HEIGHT < bpy + halfBlock - margin) {
                        return world[blockKey]; 
                    }
                }
            }
            return null;
        }
        
        // Camera collision detection for third-person view
        function checkCameraCollision(playerX, playerY, playerZ, cameraX, cameraY, cameraZ, maxDistance) {
            // Calculate direction from player to camera
            const dx = cameraX - playerX;
            const dy = cameraY - playerY;
            const dz = cameraZ - playerZ;
            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
            
            if (distance < 0.1) return maxDistance; // Too close, no need to check
            
            // Normalize direction
            const dirX = dx / distance;
            const dirY = dy / distance;
            const dirZ = dz / distance;
            
            // Step along the ray from player to camera
            const steps = Math.ceil(distance / (bs * 0.5)); // Check every half block
            let closestHitDistance = maxDistance;
            
            for (let i = 1; i <= steps; i++) {
                const t = (i / steps) * distance;
                const testX = playerX + dirX * t;
                const testY = playerY + dirY * t;
                const testZ = playerZ + dirZ * t;
                
                // Convert to block coordinates
                const bx = Math.floor(testX / bs);
                const by = Math.floor(testY / bs);
                const bz = Math.floor(testZ / bs);
                
                const blockKey = key(bx, by, bz);
                if (world[blockKey]) {
                    const block = world[blockKey];
                    
                    // Skip non-solid blocks
                    if (block.userData.isTorch || 
                        block.userData.blockType === WATER_TYPE || 
                        block.userData.blockType === LAVA_TYPE ||
                        (block.userData.blockType === DOOR_TYPE && block.userData.doorOpen)) {
                        continue;
                    }
                    
                    // Found a collision - return distance minus padding
                    closestHitDistance = Math.max(0.5, t - CAMERA_COLLISION_PADDING);
                    break;
                }
            }
            
            return closestHitDistance;
        }

        var last = performance.now();
        var fc = 0; var ft = 0;
        var fpsElement = document.getElementById('fps');
        
        // Minecraft-style physics values (tuned for better feel)
        var BASE_SPD = 9; // Walking speed (blocks/sec) - increased for better feel
        var SPRINT_MULTIPLIER = 1.3; // Sprinting speed multiplier
        var SNEAK_MULTIPLIER = 0.3; // Sneaking speed multiplier
        var JUMP_FORCE = 20; // Jump velocity - allows jumping over 1 block easily
        var GRAVITY = 73; // Gravity acceleration (blocks/sec)
        var TERMINAL_VELOCITY = -78.4; // Maximum falling speed (blocks/sec)
        var FRICTION = 0.6; // Ground friction
        var AIR_RESISTANCE = 0.02; // Air resistance while falling
        
        var dt = 0; // Make dt global for sand physics
        var isSprinting = false; // Sprint state
        var isSneaking = false; // Sneak state
        var sprintFOVBoost = 10; // FOV increase when sprinting (additive)
        var currentFOVOffset = 0; // Current FOV offset from base
        var fovTransitionSpeed = 10; // FOV transition speed
        
        // Performance optimization: Frustum culling
        var frustum = new THREE.Frustum();
        var cameraViewProjectionMatrix = new THREE.Matrix4();
        var lastCullingUpdate = 0;
        var CULLING_UPDATE_INTERVAL = 0.1; // Update culling 10 times per second

        function loop() {
            requestAnimationFrame(loop);
            
            var now = performance.now();
            
            if (!paused) { 
                dt = Math.min((now - last) / 1000, 0.1); 
                last = now;

                fc++; ft += dt;
                if (ft >= 1) { 
                    fpsElement.textContent = fc + ' FPS'; 
                    
                    // Update debug info with player position
                    if (showHitbox) {
                        const debugInfo = document.getElementById('debug-info');
                        const blockX = Math.round(px / bs);
                        const blockY = Math.round((py - EYE_HEIGHT) / bs);
                        const blockZ = Math.round(pz / bs);
                        debugInfo.innerHTML = `DEBUG MODE: Hitbox ON<br>Position: ${px.toFixed(1)}, ${py.toFixed(1)}, ${pz.toFixed(1)}<br>Block: ${blockX}, ${blockY}, ${blockZ}<br>Ground: ${ground ? 'YES' : 'NO'}`;
                    }
                    
                    fc = 0; 
                    ft = 0; 
                }
                
                // --- ANIMATE WATER & LAVA TEXTURES ---
                // Water flows smoothly and continuously
                waterTexture.offset.x += dt * 0.05; // Slow horizontal flow
                waterTexture.offset.y += dt * 0.03; // Slight vertical movement
                
                // Lava flows slower and more dramatically
                lavaTexture.offset.x += dt * 0.02; // Very slow horizontal flow
                lavaTexture.offset.y -= dt * 0.015; // Downward flow effect
                
                // Keep offsets in 0-1 range for performance
                if (waterTexture.offset.x > 1) waterTexture.offset.x -= 1;
                if (waterTexture.offset.y > 1) waterTexture.offset.y -= 1;
                if (lavaTexture.offset.x > 1) lavaTexture.offset.x -= 1;
                if (lavaTexture.offset.y < -1) lavaTexture.offset.y += 1;
                // -------------------------------------
                
                // Performance: Update frustum culling less frequently
                lastCullingUpdate += dt;
                if (lastCullingUpdate >= CULLING_UPDATE_INTERVAL) {
                    lastCullingUpdate = 0;
                    camera.updateMatrixWorld();
                    camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
                    cameraViewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
                    frustum.setFromProjectionMatrix(cameraViewProjectionMatrix);
                    
                    // Hide/show blocks based on frustum
                    for (var k in world) {
                        var block = world[k];
                        if (block && block.geometry) {
                            var wasVisible = block.visible;
                            var inFrustum = frustum.intersectsObject(block);
                            
                            // Only update if visibility changed
                            if (wasVisible !== inFrustum) {
                                block.visible = inFrustum;
                            }
                        }
                    }
                }
                
                // --- MINECRAFT-ACCURATE CONTINUOUS MINING & PLACING ---
                
                // Performance: Reduce raycast frequency to every other frame
                var shouldRaycast = fc % 2 === 0;
                
                // Update cooldowns
                if (breakingCooldown > 0) {
                    breakingCooldown -= dt;
                }
                
                // Mining logic
                if (isLeftMouseDown && locked && !inventoryOpen && !isDead && shouldRaycast) {
                    // Perform raycast to get block player is looking at
                    ray.setFromCamera(new THREE.Vector2(0, 0), camera);
                    
                    // Performance: Only raycast against visible blocks
                    var objs = Object.values(world).filter(function(obj) { return obj.visible !== false; });
                    var hits = ray.intersectObjects(objs);
                    
                    if (hits.length > 0) {
                        var hit = hits[0];
                        var distance = hit.distance;
                        
                        // Only mine if within reach (5 blocks)
                        if (distance < 5 * bs) {
                            var pos = hit.object.position;
                            var bx = Math.round(pos.x / bs);
                            var by = Math.round(pos.y / bs);
                            var bz = Math.round(pos.z / bs);
                            
                            const clickedBlock = world[key(bx, by, bz)];
                            
                            // Check if we're still mining the same block
                            if (!miningTarget || miningTarget.x !== bx || miningTarget.y !== by || miningTarget.z !== bz) {
                                // Started mining a new block - check cooldown only for continuous mining
                                if (breakingCooldown <= 0) {
                                    // Reset progress
                                    if (miningTarget && miningTarget.crackOverlay) {
                                        scene.remove(miningTarget.crackOverlay);
                                    }
                                    
                                    const requiredTime = getMiningTime(clickedBlock.userData.blockType);
                                    miningTarget = {
                                        x: bx,
                                        y: by,
                                        z: bz,
                                        progress: 0,
                                        requiredTime: requiredTime,
                                        crackOverlay: null
                                    };
                                }
                            }
                            
                            // Update mining progress
                            if (miningTarget) {
                                miningTarget.progress += dt / miningTarget.requiredTime;
                                
                                // Update crack overlay
                                if (miningTarget.crackOverlay) {
                                    scene.remove(miningTarget.crackOverlay);
                                }
                                miningTarget.crackOverlay = createCrackOverlay(bx, by, bz, miningTarget.progress);
                                if (miningTarget.crackOverlay) {
                                    scene.add(miningTarget.crackOverlay);
                                }
                                
                                // Trigger hand swing animation periodically
                                if (!isSwinging) {
                                    isSwinging = true;
                                    handSwingTimer = 0;
                                }
                                
                                // Break block when progress complete
                                if (miningTarget.progress >= 1.0) {
                                    // Remove crack overlay
                                    if (miningTarget.crackOverlay) {
                                        scene.remove(miningTarget.crackOverlay);
                                    }
                                    
                                    // Break the block
                                    var k = key(bx, by, bz);
                                    if (world[k]) {
                                        const blockType = world[k].userData.blockType;
                                        const shouldDrop = shouldDropBlock(blockType);
                                        
                                        // Special handling for bedrock in survival
                                        if (blockType === 5 && !isCreativeMode) {
                                            console.log("Bedrock cannot be destroyed in Survival Mode.");
                                            miningTarget = null;
                                            breakingCooldown = isCreativeMode ? BREAK_COOLDOWN_CREATIVE : BREAK_COOLDOWN_SURVIVAL;
                                            return;
                                        }
                                        
                                        // Remove block
                                        remove(bx, by, bz);
                                        
                                        // Reset if not creative (creative doesn't add to inventory)
                                        if (!shouldDrop && !isCreativeMode) {
                                            // Block was broken but didn't drop (wrong tool)
                                            console.log("Block broken but didn't drop - wrong tool!");
                                        }
                                    }
                                    
                                    // Reset mining target and set cooldown before next break
                                    miningTarget = null;
                                    breakingCooldown = isCreativeMode ? BREAK_COOLDOWN_CREATIVE : BREAK_COOLDOWN_SURVIVAL; // 0.25s in creative, 0.1s in survival
                                }
                            }
                        } else {
                            // Out of reach - reset mining
                            if (miningTarget) {
                                if (miningTarget.crackOverlay) {
                                    scene.remove(miningTarget.crackOverlay);
                                }
                                miningTarget = null;
                            }
                        }
                    } else {
                        // Not looking at a block - reset mining
                        if (miningTarget) {
                            if (miningTarget.crackOverlay) {
                                scene.remove(miningTarget.crackOverlay);
                            }
                            miningTarget = null;
                        }
                    }
                }
                
                // Continuous placing logic
                if (isRightMouseDown && locked && !inventoryOpen && !isDead && shouldRaycast) {
                    placingCooldown -= dt;
                    
                    if (placingCooldown <= 0) {
                        // Perform raycast to get block placement location
                        ray.setFromCamera(new THREE.Vector2(0, 0), camera);
                        
                        // Performance: Only raycast against visible blocks
                        var objs = Object.values(world).filter(function(obj) { return obj.visible !== false; });
                        var hits = ray.intersectObjects(objs);
                        
                        if (hits.length > 0) {
                            var hit = hits[0];
                            var distance = hit.distance;
                            
                            // Only place if within reach (5 blocks)
                            if (distance < 5 * bs) {
                                var pos = hit.object.position;
                                var bx = Math.round(pos.x / bs);
                                var by = Math.round(pos.y / bs);
                                var bz = Math.round(pos.z / bs);
                                
                                const clickedBlock = world[key(bx, by, bz)];
                                const isDoor = clickedBlock && clickedBlock.userData.blockType === 8;
                                
                                // Don't place if it's a door
                                if (!isDoor) {
                                    // Get current held item
                                    const hudIndex = getHUDIndex(sel);
                                    const item = inventoryData[hudIndex];
                                    
                                    if (item && item.count > 0) {
                                        let placeableType = item.type;
                                        if (item.type < 0) {
                                            const itemDef = itemDefinitions[item.type];
                                            if (!itemDef || !itemDef.isPlaceable) {
                                                // Can't place tools/non-placeable items
                                                placingCooldown = PLACE_DELAY;
                                            } else {
                                                placeableType = 3; // Wood type
                                            }
                                        }
                                        
                                        if ((window.activeBlockType !== null || placeableType >= 0) && placeableType !== undefined) {
                                            var n = hit.face.normal;
                                            var plx, ply, plz;
                                            const clickedType = clickedBlock?.userData.blockType;
                                            if (clickedType === 10 || clickedType === 11) { // Water or lava
                                                plx = bx; ply = by; plz = bz;
                                            } else {
                                                plx = bx + Math.round(n.x);
                                                ply = by + Math.round(n.y);
                                                plz = bz + Math.round(n.z);
                                            }
                                            
                                            var pbx = Math.round(px / bs);
                                            var pby = Math.round(py / bs);
                                            var pbz = Math.round(pz / bs);
                                            
                                            var ok = true;
                                            if (plx === pbx && ply === pby && plz === pbz) ok = false;
                                            if (plx === pbx && ply === (pby + 1) && plz === pbz) ok = false;
                                            
                                            if (ok && !world[key(plx, ply, plz)]) {
                                                add(plx, ply, plz, window.activeBlockType !== null ? window.activeBlockType : placeableType);
                                                playPlaceSound(window.activeBlockType !== null ? window.activeBlockType : placeableType);
                                                
                                                if (!isCreativeMode) {
                                                    item.count--;
                                                    if (item.count <= 0) { inventoryData[hudIndex] = null; }
                                                }
                                                
                                                updateInventoryUI();
                                                updateToolbarSelection();
                                                
                                                // Trigger hand placing animation
                                                isSwinging = true;
                                                handSwingTimer = 0;
                                            }
                                        }
                                    }
                                }
                                
                                placingCooldown = PLACE_DELAY; // Reset cooldown
                            }
                        }
                    }
                }
                // --- END MINECRAFT-ACCURATE MINING & PLACING ---
                
                const roundedX = px.toFixed(2);
                const roundedY = py.toFixed(2);
                const roundedZ = pz.toFixed(2);
                
                // Check if player's head is underwater
                const headY = py + (PLAYER_TOTAL_HEIGHT - EYE_HEIGHT);
                const headBlockX = Math.round(px / bs);
                const headBlockY = Math.round(headY / bs);
                const headBlockZ = Math.round(pz / bs);
                const headBlock = world[key(headBlockX, headBlockY, headBlockZ)];
                isUnderwater = headBlock && headBlock.userData.blockType === WATER_TYPE;
                
                // Oxygen and Health system (only in survival mode)
                if (!isCreativeMode && !isDead) {
                    if (isUnderwater) {
                        // Deplete oxygen when underwater
                        currentOxygen -= oxygenDepletionRate * dt;
                        currentOxygen = Math.max(0, currentOxygen);
                        
                        // Update oxygen UI
                        updateOxygenUI();
                        
                        // Drowning damage when oxygen runs out
                        if (currentOxygen <= 0) {
                            drownDamageTimer += dt;
                            if (drownDamageTimer >= drownDamageInterval) {
                                takeDamage(drownDamageRate);
                                drownDamageTimer = 0;
                            }
                        }
                    } else {
                        // Regenerate oxygen when not underwater
                        if (currentOxygen < maxOxygen) {
                            currentOxygen += oxygenRegenRate * dt;
                            currentOxygen = Math.min(maxOxygen, currentOxygen);
                            updateOxygenUI();
                        } else {
                            updateOxygenUI(); // Will hide when full
                        }
                        
                        drownDamageTimer = 0;
                    }
                    
                    // --- LAVA DAMAGE SYSTEM ---
                    // Check if player is touching lava (ANY part of player, not just center)
                    isInLava = false;
                    
                    // Check multiple points around the player's body
                    const playerBlockX = Math.round(px / bs);
                    const playerBlockZ = Math.round(pz / bs);
                    const feetBlockY = Math.floor((py - EYE_HEIGHT) / bs);
                    const headBlockY = Math.ceil((py - EYE_HEIGHT + PLAYER_TOTAL_HEIGHT) / bs);
                    
                    // Check from feet to head
                    for (let checkY = feetBlockY; checkY <= headBlockY; checkY++) {
                        // Check center and around the player's radius
                        const checkPositions = [
                            [playerBlockX, checkY, playerBlockZ],
                            [playerBlockX + 1, checkY, playerBlockZ],
                            [playerBlockX - 1, checkY, playerBlockZ],
                            [playerBlockX, checkY, playerBlockZ + 1],
                            [playerBlockX, checkY, playerBlockZ - 1]
                        ];
                        
                        for (const [cx, cy, cz] of checkPositions) {
                            const checkBlock = world[key(cx, cy, cz)];
                            if (checkBlock && checkBlock.userData.blockType === LAVA_TYPE) {
                                isInLava = true;
                                break;
                            }
                        }
                        if (isInLava) break;
                    }
                    
                    if (isInLava) {
                        // Take damage while in lava
                        lavaDamageTimer += dt;
                        if (lavaDamageTimer >= lavaDamageInterval) {
                            takeDamage(lavaDamageAmount);
                            lavaDamageTimer = 0;
                        }
                    } else {
                        lavaDamageTimer = 0;
                    }
                    // ---------------------------
                    
                    // Update health UI
                    updateHealthUI();
                } else if (isCreativeMode) {
                    // Creative mode - keep oxygen and health full, hide UI
                    currentOxygen = maxOxygen;
                    currentHealth = maxHealth;
                    document.getElementById('oxygen-container').style.display = 'none';
                    document.getElementById('health-container').style.display = 'none';
                }
                
                // Note: UI will be updated below after time calculation

                // --- DAY/NIGHT CYCLE UPDATE ---
                dayTime += dt;
                if (dayTime >= dayLength) {
                    dayTime -= dayLength; // Loop the cycle
                    dayCounter++; // Increment day counter when a full day passes
                    moonPhase = (moonPhase + 1) % 8; // Cycle through 8 moon phases
                    updateMoonPhase(); // Update moon texture
                }
                
                // Calculate cycle progress (0 to 1)
                const cycleProgress = dayTime / dayLength;
                
                // Correct angle mapping: 6 AM = -/2 (horizon east), noon = 0 (overhead), 6 PM = /2 (horizon west), midnight = -
                const angle = (cycleProgress * Math.PI * 2) - Math.PI;
                
                // Position sun and moon fixed in sky (follows player position, not camera rotation)
                // Like Minecraft: they stay in world space based on day/night cycle
                const camX = camera.position.x;
                const camY = camera.position.y;
                const camZ = camera.position.z;
                
                // Sun position in sky - circular path around player
                // At 6 AM (angle = -/2): sun is at horizon in east
                // At noon (angle = 0): sun is directly overhead
                // At 6 PM (angle = /2): sun is at horizon in west
                sun.position.set(
                    camX + Math.sin(angle) * celestialDistance,
                    camY + Math.cos(angle) * celestialDistance,
                    camZ
                );
                
                // Moon is opposite to sun (12 hours offset)
                moon.position.set(
                    camX - Math.sin(angle) * celestialDistance,
                    camY - Math.cos(angle) * celestialDistance,
                    camZ
                );
                
                // Make planes face the camera position (billboard effect)
                sun.lookAt(camera.position);
                moon.lookAt(camera.position);
                
                // Calculate game time in hours (0-24)
                const gameHour = (dayTime / dayLength) * 24;
                
                // Calculate precise time components
                const hours = Math.floor(gameHour);
                const minutes = Math.floor((gameHour - hours) * 60);
                const seconds = Math.floor(((gameHour - hours) * 60 - minutes) * 60);
                
                // Format time string
                const timeString = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                
                // Calculate player speed in blocks per second (3 decimal places like Minecraft)
                const horizontalSpeed = Math.sqrt(vx * vx + vz * vz);
                const speedBPS = horizontalSpeed.toFixed(3);
                
                // Update UI element with all game info including time, day, and speed
                uiElement.innerHTML = `Day ${dayCounter} | Time: ${timeString}\nGame Mode: ${isCreativeMode ? 'Creative' : 'Survival'}\nFly Mode: ${isFlying ? 'ON' : 'OFF'}\nSpeed: ${speedBPS} blocks/sec\nSeed: ${WORLD_SEED}\nWorld Size: ${ws}\nX: ${roundedX}\nY: ${roundedY}\nZ: ${roundedZ}`;
                
                // Enhanced sun/moon visibility with twilight transitions
                // Both sun and moon are visible during sunrise and sunset
                // Sunrise: 6:00 AM - 7:00 AM (gameHour 6-7)
                // Sunset: 6:00 PM - 7:00 PM (gameHour 18-19)
                
                const sunriseStart = 6.0;
                const sunriseEnd = 7.0;
                const sunsetStart = 18.0;
                const sunsetEnd = 19.0;
                
                // Calculate sun and moon opacity based on time
                let sunOpacity = 1.0;
                let moonOpacity = 1.0;
                
                if (gameHour >= sunriseStart && gameHour < sunriseEnd) {
                    // Sunrise transition - sun fading in, moon fading out
                    const progress = (gameHour - sunriseStart) / (sunriseEnd - sunriseStart);
                    sunOpacity = progress;
                    moonOpacity = 1.0 - progress;
                    sun.visible = true;
                    moon.visible = true;
                } else if (gameHour >= sunsetStart && gameHour < sunsetEnd) {
                    // Sunset transition - sun fading out, moon fading in
                    const progress = (gameHour - sunsetStart) / (sunsetEnd - sunsetStart);
                    sunOpacity = 1.0 - progress;
                    moonOpacity = progress;
                    sun.visible = true;
                    moon.visible = true;
                } else if (gameHour >= sunriseEnd && gameHour < sunsetStart) {
                    // Full daytime - only sun visible
                    sun.visible = true;
                    moon.visible = false;
                    sunOpacity = 1.0;
                } else {
                    // Full nighttime - only moon visible
                    sun.visible = false;
                    moon.visible = true;
                    moonOpacity = 1.0;
                }
                
                // Apply opacity to materials
                sunMaterial.opacity = sunOpacity;
                moonMaterial.opacity = moonOpacity;
                
                // Calculate light intensity based on sun height
                // Day is when sun is above horizon (cos(angle) > 0)
                const sunHeight = Math.cos(angle);
                const isDay = sunHeight > 0;
                
                // Smooth transition for lighting with moon phase effects
                let lightIntensity;
                if (sunHeight > 0.1) {
                    // Full day - bright lighting
                    lightIntensity = 0.4 + sunHeight * 0.3;
                } else if (sunHeight > -0.1) {
                    // Twilight transition
                    lightIntensity = 0.2 + (sunHeight + 0.1) * 1.0;
                } else {
                    // Night - brightness affected by moon phase
                    // Full moon (phase 0) = brighter, New moon (phase 4) = darkest
                    const moonBrightness = moonPhase === 4 ? 0.10 : // New moon - very dark
                                          moonPhase === 0 ? 0.20 : // Full moon - brightest night
                                          moonPhase === 1 || moonPhase === 7 ? 0.18 : // Gibbous - bright
                                          moonPhase === 2 || moonPhase === 6 ? 0.15 : // Quarter - medium
                                          0.12; // Crescent - dim
                    lightIntensity = moonBrightness;
                }
                
                // Update ambient light (reduced brightness)
                aLight.intensity = lightIntensity;
                dLight.intensity = lightIntensity * 0.8;
                
                // Calculate sky color based on time of day and moon phase
                let skyColor;
                if (sunHeight > 0.2) {
                    // Day - bright blue
                    skyColor = new THREE.Color(0x87CEEB);
                } else if (sunHeight > 0) {
                    // Dawn/Dusk - orange/pink
                    const t = sunHeight / 0.2;
                    skyColor = new THREE.Color().lerpColors(
                        new THREE.Color(0xFF6B35), // Orange
                        new THREE.Color(0x87CEEB), // Blue
                        t
                    );
                } else if (sunHeight > -0.2) {
                    // Twilight - dark blue
                    const t = (sunHeight + 0.2) / 0.2;
                    skyColor = new THREE.Color().lerpColors(
                        new THREE.Color(0x1a1a2e), // Dark blue
                        new THREE.Color(0xFF6B35), // Orange
                        t
                    );
                } else {
                    // Night - color varies slightly with moon phase
                    if (moonPhase === 0) {
                        // Full moon - slightly lighter night sky
                        skyColor = new THREE.Color(0x1e1e3e);
                    } else if (moonPhase === 4) {
                        // New moon - darkest night
                        skyColor = new THREE.Color(0x0a0a1a);
                    } else {
                        // Other phases - normal dark blue
                        skyColor = new THREE.Color(0x1a1a2e);
                    }
                }
                
                scene.background = skyColor;
                scene.fog.color = skyColor;
                
                // --- UNDERWATER VISUAL EFFECT ---
                if (isUnderwater) {
                    // Apply blue underwater tint and close fog
                    const underwaterColor = new THREE.Color(0x1a4d6d); // Dark blue-green underwater color
                    scene.background = underwaterColor;
                    scene.fog.color = underwaterColor;
                    scene.fog.near = 10;
                    scene.fog.far = 30;
                } else {
                    // Reset fog to normal distance
                    scene.fog.near = 500;
                    scene.fog.far = 1000;
                }
                
                // --- UPDATE PARTICLES ---
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.lifetime -= dt;
                    
                    if (p.lifetime <= 0) {
                        scene.remove(p);
                        particles.splice(i, 1);
                    } else {
                        p.velocity.y -= GRAVITY * dt;
                        p.position.x += p.velocity.x * dt;
                        p.position.y += p.velocity.y * dt;
                        p.position.z += p.velocity.z * dt;
                        p.material.opacity = p.lifetime;
                        // Billboard effect - make particles face camera
                        p.lookAt(camera.position);
                    }
                }
                
                // --- UPDATE BLOCK OUTLINE ---
                // Performance: Only update outline every few frames when not mining/placing
                if (shouldRaycast && !inventoryOpen) {
                    ray.setFromCamera(new THREE.Vector2(0, 0), camera);
                    
                    // Performance: Only raycast against visible blocks
                    var objs = Object.values(world).filter(function(obj) { return obj.visible !== false; });
                    var hits = ray.intersectObjects(objs);
                    
                    if (hits.length > 0) {
                        var hit = hits[0];
                        var distance = hit.distance;
                        
                        // Only show outline if within reach (5 blocks)
                        if (distance < 5 * bs) {
                            const hitBlock = hit.object;
                            
                            // Check if looking at a door
                            if (hitBlock.userData.blockType === DOOR_TYPE) {
                                // Switch to door outline geometry
                                blockOutline.geometry = doorOutlineGeometry;
                            } else {
                                // Use regular block outline
                                blockOutline.geometry = outlineGeometry;
                            }
                            
                            blockOutline.position.copy(hitBlock.position);
                            blockOutline.rotation.copy(hitBlock.rotation);
                            blockOutline.visible = true;
                        } else {
                            blockOutline.visible = false;
                        }
                    } else {
                        blockOutline.visible = false;
                    }
                } else if (inventoryOpen) {
                    blockOutline.visible = false;
                }

                // Visibility culling handled after camera position update below



                if (locked && !isDead) { 
                    var fx = Math.sin(ry); 
                    var fz = Math.cos(ry); 
                    var rx2 = Math.sin(ry + Math.PI / 2); 
                    var rz = Math.cos(ry + Math.PI / 2); 
                    
                    var inputX = 0; var inputZ = 0;
                    
                    // Sprint and sneak detection (Ctrl for sprint while moving forward, Shift for sneak)
                    // Sprinting now works when jumping and only when moving forward
                    isSprinting = keys['ControlLeft'] && keys[keybinds.forward] && !inventoryOpen && !isSneaking;
                    isSneaking = keys['ShiftLeft'] && !inventoryOpen && !isSprinting;
                    
                    // Calculate speed based on movement state
                    var currentSpeed = BASE_SPD;
                    if (isSprinting) {
                        currentSpeed *= SPRINT_MULTIPLIER;
                    } else if (isSneaking) {
                        currentSpeed *= SNEAK_MULTIPLIER;
                    }

                    if (keys[keybinds.forward] && !inventoryOpen) { inputX -= fx; inputZ -= fz; } 
                    if (keys[keybinds.backward] && !inventoryOpen) { inputX += fx; inputZ += fz; } 
                    if (keys[keybinds.left] && !inventoryOpen) { inputX -= rx2; inputZ -= rz; } 
                    if (keys[keybinds.right] && !inventoryOpen) { inputX += rx2; inputZ += rz; }
                    
                    // Check if player is moving for hand bob
                    isMovingForBob = (inputX !== 0 || inputZ !== 0) && ground;
                    
                    if (isFlying) { 
                        // --- FLYING LOGIC WITH MINECRAFT-STYLE AABB COLLISION ---
                        ground = false;
                        vx = 0; vy = 0; vz = 0;
                        
                        let flySpeed = currentSpeed * dt;
                        
                        var mag = Math.sqrt(inputX * inputX + inputZ * inputZ);
                        if (mag > 0) {
                            inputX /= mag; inputZ /= mag;
                            vx = inputX * flySpeed;
                            vz = inputZ * flySpeed;
                        }
                        
                        if (keys[keybinds.jump] && !inventoryOpen) { vy = flySpeed; }
                        if (keys[keybinds.sneak] && !inventoryOpen) { vy = -flySpeed; }
                        
                        // Create player AABB (eye position is reference point)
                        const feetY = py - EYE_HEIGHT;
                        const playerAABB = AABB.fromCenter(px, feetY, pz, 0.6 * bs, 1.8 * bs);
                        
                        // Use Minecraft-style per-axis collision (no step-up in flying)
                        const collision = moveWithCollision(playerAABB, vx, vy, vz, 0);
                        
                        px += collision.dx;
                        py += collision.dy;
                        pz += collision.dz;
                        
                        if (collision.collidedX) vx = 0;
                        if (collision.collidedY) vy = 0;
                        if (collision.collidedZ) vz = 0;
                        
                    } else {
                        // --- WALKING/FALLING LOGIC WITH MINECRAFT-STYLE AABB COLLISION ---
                        
                        // Check if player is in water or lava (check at feet/waist level, not head)
                        const feetY = py - EYE_HEIGHT; // Player's feet position
                        const waterCheckY = feetY + (PLAYER_TOTAL_HEIGHT * 0.4); // Check at about waist height (40% up from feet)
                        const playerBlockX = Math.round(px / bs);
                        const playerBlockY = Math.round(waterCheckY / bs); // Changed from py to waterCheckY
                        const playerBlockZ = Math.round(pz / bs);
                        const playerBlock = world[key(playerBlockX, playerBlockY, playerBlockZ)];
                        const inFluid = playerBlock && (playerBlock.userData.blockType === WATER_TYPE || playerBlock.userData.blockType === LAVA_TYPE);
                        const inWater = playerBlock && playerBlock.userData.blockType === WATER_TYPE;
                        const inLava = playerBlock && playerBlock.userData.blockType === LAVA_TYPE;
                        
                        var mag = Math.sqrt(inputX * inputX + inputZ * inputZ);

                        if (mag > 0) {
                            inputX /= mag; inputZ /= mag;
                            // Slower movement in fluids
                            const fluidMultiplier = inFluid ? 0.6 : 1.0;
                            vx = inputX * currentSpeed * dt * fluidMultiplier;
                            vz = inputZ * currentSpeed * dt * fluidMultiplier;
                        } else {
                            vx *= FRICTION; vz *= FRICTION; 
                        }
                        
                        // Modified gravity for fluids - Minecraft-style water physics
                        if (inFluid) {
                            // Reset fall damage when entering water/lava
                            if (wasFalling) {
                                wasFalling = false;
                            }
                            
                        // Minecraft-style buoyancy - natural floating
                        if (inWater) {
                            // Check if there's a solid block above water level to jump onto
                            const blockAboveWater = world[key(playerBlockX, playerBlockY + 1, playerBlockZ)];
                            const canJumpOut = !blockAboveWater || blockAboveWater.userData.blockType === WATER_TYPE;
                            
                            // Very slow sinking when idle (almost floating)
                            vy -= GRAVITY * dt * 0.15; // 15% gravity in water - feels like floating
                            
                            // Add slight upward buoyancy force for natural floating
                            vy += GRAVITY * dt * 0.08; // Upward buoyancy
                            
                            // Swimming controls - Minecraft style
                            if (keys[keybinds.jump] && !inventoryOpen) {
                                // Jump out of water with normal jump force
                                vy = JUMP_FORCE;
                            }
                            if (keys[keybinds.sneak] && !inventoryOpen) {
                                vy = -JUMP_FORCE * 0.4; // Swim down
                            }
                            
                            // Apply drag only if not jumping (allow jump momentum to work)
                            if (!keys[keybinds.jump] || vy < 0) {
                                vy *= 0.85; // Strong drag in water for realistic feel
                            }
                            vx *= 0.92;
                            vz *= 0.92;
                            } else if (inLava) {
                                // Lava physics - same as water for easy escape
                                vy -= GRAVITY * dt * 0.15; // Same gravity as water
                                vy += GRAVITY * dt * 0.08; // Same buoyancy as water
                                
                                if (keys[keybinds.jump] && !inventoryOpen) {
                                    vy = JUMP_FORCE; // Full jump force - same as water
                                }
                                if (keys[keybinds.sneak] && !inventoryOpen) {
                                    vy = -JUMP_FORCE * 0.4; // Same sink speed as water
                                }
                                
                                // Apply drag only if not jumping (same as water)
                                if (!keys[keybinds.jump] || vy < 0) {
                                    vy *= 0.85; // Same drag as water
                                }
                                vx *= 0.92; // Same horizontal movement as water
                                vz *= 0.92; // Same horizontal movement as water
                            }
                        } else {
                            // Minecraft-accurate gravity with terminal velocity
                            vy -= GRAVITY * dt;
                            
                            // Apply terminal velocity limit
                            if (vy < TERMINAL_VELOCITY) {
                                vy = TERMINAL_VELOCITY;
                            }
                            
                            // Apply air resistance when falling
                            if (vy < 0) {
                                vy *= (1 - AIR_RESISTANCE);
                            }
                            
                            // --- FALL DAMAGE TRACKING ---
                            // Track when player starts falling
                            if (!ground && vy < 0 && !wasFalling && !isCreativeMode) {
                                fallStartY = py; // Record height when fall started
                                wasFalling = true;
                            }
                            // ---------------------------
                            
                            if (keys[keybinds.jump] && ground && !inventoryOpen) { 
                                vy = JUMP_FORCE; 
                                ground = false; 
                                const blockUnderPlayer = getBlockUnderPlayer();
                                playJumpSound(blockUnderPlayer); // Play jump sound based on block type
                            }
                        }
                        
                        // Create player AABB (feet position as base)
                        // feetY already declared above
                        let playerAABB = AABB.fromCenter(px, feetY, pz, 0.6 * bs, 1.8 * bs);
                        
                        // Use Minecraft-style per-axis collision with 0.6 block step-up
                        const stepUpHeight = 0.6 * bs;
                        const collision = moveWithCollision(playerAABB, vx, vy * dt, vz, stepUpHeight);
                        
                        // --- FALL DAMAGE CALCULATION ---
                        if (collision.onGround && wasFalling && !isCreativeMode && !isDead && !inFluid) {
                            const fallDistance = (fallStartY - py) / bs; // Convert to blocks
                            if (fallDistance > SAFE_FALL_DISTANCE) {
                                const damageBlocks = fallDistance - SAFE_FALL_DISTANCE;
                                const fallDamage = Math.floor(damageBlocks * FALL_DAMAGE_MULTIPLIER * 2); // *2 for half-hearts
                                if (fallDamage > 0) {
                                    takeDamage(fallDamage);
                                }
                            }
                            wasFalling = false;
                        }
                        // -----------------------------
                        
                        // Update position
                        px += collision.dx;
                        py += collision.dy;
                        pz += collision.dz;
                        
                        // Update ground state
                        ground = collision.onGround;
                        
                        // Update velocities
                        if (collision.collidedX) vx = 0;
                        if (collision.collidedY) vy = 0;
                        if (collision.collidedZ) vz = 0;
                        
                        // Sneaking - prevent falling off edges
                        if (isSneaking && ground) {
                            // Check if player is near an edge
                            const sneakCheckDist = 0.4 * bs;
                            const futureX = px + (vx * dt);
                            const futureZ = pz + (vz * dt);
                            const feetY = py - EYE_HEIGHT;
                            const blockBelowFuture = world[key(Math.round(futureX / bs), Math.round((feetY - 0.1) / bs), Math.round(futureZ / bs))];
                            
                            // If no block below future position, stop movement
                            if (!blockBelowFuture) {
                                vx = 0;
                                vz = 0;
                            }
                        }
                        
                        // Smooth FOV transition for sprinting (relative to user's FOV setting)
                        const targetFOVOffset = isSprinting ? sprintFOVBoost : 0;
                        if (Math.abs(currentFOVOffset - targetFOVOffset) > 0.1) {
                            currentFOVOffset += (targetFOVOffset - currentFOVOffset) * fovTransitionSpeed * dt;
                            camera.fov = fieldOfView + currentFOVOffset;
                            camera.updateProjectionMatrix();
                        }
                        
                        // Update movement status indicator
                        const movementStatus = document.getElementById('movement-status');
                        if (movementStatus) {
                            if (isSprinting) {
                                movementStatus.textContent = ' SPRINTING (Ctrl)';
                                movementStatus.className = 'sprinting';
                            } else if (isSneaking) {
                                movementStatus.textContent = ' SNEAKING (Shift)';
                                movementStatus.className = 'sneaking';
                            } else {
                                movementStatus.className = '';
                                movementStatus.style.display = 'none';
                            }
                        }
                        
                        // --- WORLD BORDER COLLISION ---
                        if (worldBorderEnabled) {
                            const halfWorldSize = (ws / 2) * bs; // World size in world units (matches generation range)
                            const borderMargin = PLAYER_RADIUS + 0.1;
                            
                            // Check X boundaries
                            if (px > halfWorldSize - borderMargin) {
                                px = halfWorldSize - borderMargin;
                                vx = 0;
                            } else if (px < -halfWorldSize + borderMargin) {
                                px = -halfWorldSize + borderMargin;
                                vx = 0;
                            }
                            
                            // Check Z boundaries
                            if (pz > halfWorldSize - borderMargin) {
                                pz = halfWorldSize - borderMargin;
                                vz = 0;
                            } else if (pz < -halfWorldSize + borderMargin) {
                                pz = -halfWorldSize + borderMargin;
                                vz = 0;
                            }
                        }
                        
                        // Handle entity pushing
                        const currentPlayerAABB = AABB.fromCenter(px, py - EYE_HEIGHT, pz, 0.6 * bs, 1.8 * bs);
                        handleEntityPushing(currentPlayerAABB, vx, vz);
                        
                        // --- WALKING SOUND SYSTEM WITH BLOCK DETECTION ---
                        // Footsteps now react to movement speed
                        const isMoving = mag > 0 && ground;
                        if (isMoving) {
                            // Adjust step interval based on speed (faster when sprinting)
                            const speedMultiplier = isSprinting ? SPRINT_MULTIPLIER : (isSneaking ? SNEAK_MULTIPLIER : 1.0);
                            stepTimer += dt * speedMultiplier;
                            if (stepTimer >= stepInterval) {
                                const blockUnderPlayer = getBlockUnderPlayer();
                                playStepSound(blockUnderPlayer);
                                stepTimer = 0;
                            }
                            wasMoving = true;
                            
                            // Update walking animation timer
                            walkAnimationTimer += dt * WALK_ANIMATION_SPEED;
                        } else {
                            stepTimer = 0;
                            wasMoving = false;
                            
                            // Reset animation timer when not moving
                            walkAnimationTimer = 0;
                        }
                    }
                    
                    // --- STUCK DETECTION SYSTEM REMOVED ---
                    // (Teleporting disabled to prevent unexpected movement)
                    
                    // --- PERSPECTIVE SWITCHING ---
                    if (perspectiveMode === 0) {
                        // First person view with camera shake effect
                        camera.position.set(px, py, pz);
                        camera.rotation.set(rx + shakeOffset.x, ry + shakeOffset.y, shakeOffset.z, 'YXZ');
                        playerModelGroup.visible = false;
                    } else {
                        // Third person view with collision detection
                        let distance = THIRD_PERSON_DISTANCE;
                        const direction = perspectiveMode === 1 ? 1 : -1; // 1 = back, -1 = front
                        
                        // Calculate intended camera position
                        const cosPitch = Math.cos(rx);
                        const offsetX = Math.sin(ry) * cosPitch * distance * direction;
                        const offsetZ = Math.cos(ry) * cosPitch * distance * direction;
                        const offsetY = Math.sin(rx) * distance;
                        
                        const intendedCameraX = px - offsetX;
                        const intendedCameraY = py - 0.8 + offsetY;
                        const intendedCameraZ = pz - offsetZ;
                        
                        // Check for collision and adjust distance
                        const safeDistance = checkCameraCollision(px, py, pz, intendedCameraX, intendedCameraY, intendedCameraZ, distance);
                        
                        // Recalculate camera position with safe distance
                        const finalOffsetX = Math.sin(ry) * cosPitch * safeDistance * direction;
                        const finalOffsetZ = Math.cos(ry) * cosPitch * safeDistance * direction;
                        const finalOffsetY = Math.sin(rx) * safeDistance;
                        
                        camera.position.set(
                          px - finalOffsetX,
                          py - 0.8 + finalOffsetY,
                          pz - finalOffsetZ
                        );
                        
                        // Show and update player model
        playerModelGroup.visible = true;
        // Position model properly - account for scaled model and eye height
        const feetY = py - EYE_HEIGHT; // Player's feet position
        // Add small downward offset to prevent floating appearance (1 pixel up from previous = 0.0625 blocks)
        const MODEL_OFFSET_Y = -0.1125 * bs; // Offset to lower model (adjusted up by 1 pixel)
        const modelCenterY = feetY + (PLAYER_TOTAL_HEIGHT * modelScale) / 2 + MODEL_OFFSET_Y; // Center of scaled model with offset
        playerModelGroup.position.set(px, modelCenterY, pz);
        playerModelGroup.rotation.y = ry + Math.PI; // Face correct direction
        
        // Camera locked on head position
        const headWorldY = modelCenterY + (0.125 * modelScale); // Head offset from model center
        camera.lookAt(px, headWorldY, pz);
                        
                        // Apply animations to limbs
                        const isCurrentlyMoving = (Math.abs(vx) > 0.01 || Math.abs(vz) > 0.01) && ground;
                        
                        if (isCurrentlyMoving) {
                            // Walking animation
                            const swingAngle = Math.sin(walkAnimationTimer);
                            
                            // Animate arms (opposite swing)
                            leftArmPivot.rotation.x = swingAngle * ARM_SWING_AMPLITUDE;
                            rightArmPivot.rotation.x = -swingAngle * ARM_SWING_AMPLITUDE;
                            leftArmPivot.rotation.z = 0;
                            rightArmPivot.rotation.z = 0;
                            
                            // Animate legs (opposite swing)
                            leftLegPivot.rotation.x = -swingAngle * LEG_SWING_AMPLITUDE;
                            rightLegPivot.rotation.x = swingAngle * LEG_SWING_AMPLITUDE;
                            
                            // Reset head and body to neutral when moving
                            headMesh.position.y = 0.125 * modelScale;
                            bodyMesh.rotation.y = 0;
                        } else {
                            // Idle animation (Minecraft-style breathing)
                            idleAnimationTimer += 0.016 * IDLE_ANIMATION_SPEED; // ~60 FPS
                            const idleSway = Math.sin(idleAnimationTimer);
                            const idleBreathe = Math.sin(idleAnimationTimer * 0.7); // Slower breathing
                            
                            // Subtle arm sway (arms swing slightly inward/outward)
                            leftArmPivot.rotation.x = idleBreathe * IDLE_ARM_SWAY;
                            rightArmPivot.rotation.x = idleBreathe * IDLE_ARM_SWAY;
                            leftArmPivot.rotation.z = idleSway * IDLE_ARM_SWAY * 0.5;
                            rightArmPivot.rotation.z = -idleSway * IDLE_ARM_SWAY * 0.5;
                            
                            // Legs stay still during idle
                            leftLegPivot.rotation.x = 0;
                            rightLegPivot.rotation.x = 0;
                            
                            // Subtle head bob
                            headMesh.position.y = (0.125 * modelScale) + (idleBreathe * IDLE_HEAD_BOB);
                            
                            // Very subtle body rotation (breathing effect)
                            bodyMesh.rotation.y = idleSway * IDLE_BODY_SWAY;
                        }
                    }
                    // --- END PERSPECTIVE SWITCHING ---
                    
                    
                    // --- UPDATE DEBUG HITBOX POSITION ---
                    if (showHitbox) {
                        // Position hitbox at player's center (feet + half height)
                        const feetY = py - EYE_HEIGHT;
                        const centerY = feetY + PLAYER_TOTAL_HEIGHT / 2;
                        hitboxWireframe.position.set(px, centerY, pz);
                    }
                    // --- END DEBUG HITBOX UPDATE ---

                    if (py < -50) { 
                        resetPlayer();
                    }
                } else {
                    // Paused - apply same perspective logic
                    if (perspectiveMode === 0) {
                        camera.position.set(px, py, pz);
                        camera.rotation.set(rx, ry, 0, 'YXZ');
                        playerModelGroup.visible = false;
                    } else {
                    // Third person view with collision detection (paused)
                    let distance = THIRD_PERSON_DISTANCE;
                    const direction = perspectiveMode === 1 ? 1 : -1;
                    
                    const cosPitch = Math.cos(rx);
                    const offsetX = Math.sin(ry) * cosPitch * distance * direction;
                    const offsetZ = Math.cos(ry) * cosPitch * distance * direction;
                    const offsetY = Math.sin(rx) * distance;
                    
                    const intendedCameraX = px - offsetX;
                    const intendedCameraY = py - 0.8 + offsetY;
                    const intendedCameraZ = pz - offsetZ;
                    
                    // Check for collision and adjust distance
                    const safeDistance = checkCameraCollision(px, py, pz, intendedCameraX, intendedCameraY, intendedCameraZ, distance);
                    
                    // Recalculate with safe distance
                    const finalOffsetX = Math.sin(ry) * cosPitch * safeDistance * direction;
                    const finalOffsetZ = Math.cos(ry) * cosPitch * safeDistance * direction;
                    const finalOffsetY = Math.sin(rx) * safeDistance;
                    
                    playerModelGroup.visible = true;
                    const feetY = py - EYE_HEIGHT;
                    // Add small downward offset to prevent floating appearance (1 pixel up from previous = 0.0625 blocks)
                    const MODEL_OFFSET_Y = -0.1125 * bs; // Offset to lower model (adjusted up by 1 pixel)
                    const modelCenterY = feetY + (PLAYER_TOTAL_HEIGHT * modelScale) / 2 + MODEL_OFFSET_Y;
                    playerModelGroup.position.set(px, modelCenterY, pz);
                    playerModelGroup.rotation.y = ry + Math.PI;
                    
                    // Apply idle animation even when paused
                    idleAnimationTimer += 0.016 * IDLE_ANIMATION_SPEED;
                    const idleSway = Math.sin(idleAnimationTimer);
                    const idleBreathe = Math.sin(idleAnimationTimer * 0.7);
                    
                    leftArmPivot.rotation.x = idleBreathe * IDLE_ARM_SWAY;
                    rightArmPivot.rotation.x = idleBreathe * IDLE_ARM_SWAY;
                    leftArmPivot.rotation.z = idleSway * IDLE_ARM_SWAY * 0.5;
                    rightArmPivot.rotation.z = -idleSway * IDLE_ARM_SWAY * 0.5;
                    leftLegPivot.rotation.x = 0;
                    rightLegPivot.rotation.x = 0;
                    headMesh.position.y = (0.125 * modelScale) + (idleBreathe * IDLE_HEAD_BOB);
                    bodyMesh.rotation.y = idleSway * IDLE_BODY_SWAY;
                    
                    // Camera locked on head position
                    const headWorldY = modelCenterY + (0.125 * modelScale);
                    camera.position.set(px - finalOffsetX, py - 0.8 + finalOffsetY, pz - finalOffsetZ);
                    camera.lookAt(px, headWorldY, pz);
                    }
                    
                    // --- UPDATE DEBUG HITBOX POSITION (paused) ---
                    if (showHitbox) {
                        const feetY = py - EYE_HEIGHT;
                        const centerY = feetY + PLAYER_TOTAL_HEIGHT / 2;
                        hitboxWireframe.position.set(px, centerY, pz);
                    }
                    // --- END DEBUG HITBOX UPDATE ---
                }
            } else { last = now; }
            
            // --- UPDATE LOOKING-AT DISPLAY (Raycast from eye) ---
            if (locked && !paused && !inventoryOpen) {
                // Get camera direction
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                
                // Perform raycast from eye position
                const rayResult = raycastFromEye(
                    px, py, pz,
                    direction.x, direction.y, direction.z,
                    8 * bs // Max distance: 8 blocks
                );
                
                const lookingAtInfo = document.getElementById('looking-at-info');
                if (rayResult.hit) {
                    const block = rayResult.block;
                    const blockType = block.userData.blockType;
                    
                    // Get block name from type
                    let blockName = '';
                    for (const [name, type] of Object.entries(window)) {
                        if (name.endsWith('_TYPE') && type === blockType) {
                            blockName = name.replace('_TYPE', '').toLowerCase()
                                .split('_')
                                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                                .join(' ');
                            break;
                        }
                    }
                    
                    if (blockName) {
                        lookingAtInfo.textContent = `${blockName} [${rayResult.blockX}, ${rayResult.blockY}, ${rayResult.blockZ}]`;
                        lookingAtInfo.style.display = 'block';
                    } else {
                        lookingAtInfo.style.display = 'none';
                    }
                } else {
                    lookingAtInfo.style.display = 'none';
                }
            } else {
                const lookingAtInfo = document.getElementById('looking-at-info');
                if (lookingAtInfo) lookingAtInfo.style.display = 'none';
            }
            // --- END LOOKING-AT DISPLAY ---
            
            // --- OPTIMIZED VISIBILITY CULLING (for large worlds) ---
            // Per-face culling is handled at geometry creation time in createCulledGeometry()
            (function(){
                var playerBlockX = Math.round(px / bs);
                var playerBlockY = Math.round(py / bs);
                var playerBlockZ = Math.round(pz / bs);
                var forward = new THREE.Vector3();
                camera.getWorldDirection(forward);
                var vFovRad = camera.fov * Math.PI / 180;
                var hFovRad = 2 * Math.atan(Math.tan(vFovRad / 2) * camera.aspect);
                var halfAngle = Math.max(vFovRad, hFovRad) * 0.5 + 1.2;
                var cosThreshold = Math.cos(halfAngle);
                
                // Optimization: Only check blocks within a reasonable range
                const checkRadius = renderDistance + 5;

                for (var k in world) {
                    var mesh = world[k];
                    var bx = Math.round(mesh.position.x / bs);
                    var by = Math.round(mesh.position.y / bs);
                    var bz = Math.round(mesh.position.z / bs);
                    
                    // Quick distance check before expensive calculations
                    var blockDistX = Math.abs(bx - playerBlockX);
                    var blockDistZ = Math.abs(bz - playerBlockZ);
                    var blockDistY = Math.abs(by - playerBlockY);
                    
                    // Fast rejection for blocks way outside render distance
                    if (blockDistX > checkRadius || blockDistZ > checkRadius || blockDistY > checkRadius) {
                        mesh.visible = false;
                        continue;
                    }
                    
                    var distanceBlocks = Math.sqrt(
                        blockDistX * blockDistX +
                        blockDistZ * blockDistZ
                    );

                    if (distanceBlocks > renderDistance) { 
                        mesh.visible = false; 
                        continue; 
                    }
                    
                    // FOV culling (only for distant blocks to save performance)
                    if (distanceBlocks > renderDistance * 0.5) {
                        var dx = mesh.position.x - camera.position.x;
                        var dy = mesh.position.y - camera.position.y;
                        var dz = mesh.position.z - camera.position.z;
                        var len = Math.sqrt(dx*dx + dy*dy + dz*dz) || 1;
                        var ux = dx / len, uy = dy / len, uz = dz / len;
                        var cosA = ux*forward.x + uy*forward.y + uz*forward.z;
                        
                        if (cosA < cosThreshold) { 
                            mesh.visible = false; 
                            continue; 
                        }
                    }

                    mesh.visible = true;
                }
            })();

            // --- Sand Falling Physics (Falls through water) ---
            if (!paused && dt > 0) { 
                sandFallTimer += dt;
                if (sandFallTimer >= SAND_FALL_CHECK_INTERVAL) {
                    sandFallTimer = 0;

                    const fallingBlocks = [];
                    for (const k in world) {
                        const mesh = world[k];
                        if (mesh.userData.blockType === SAND_TYPE) {
                            const [bx, by, bz] = k.split(',').map(Number);
                            const blockBelow = world[key(bx, by - 1, bz)];
                            
                            // Sand falls if there's nothing below OR if there's water below
                            if (by > 1 && (!blockBelow || blockBelow.userData.blockType === WATER_TYPE)) {
                                fallingBlocks.push({ oldKey: k, x: bx, y: by, z: bz, type: SAND_TYPE });
                            }
                        }
                    }
                    
                    for (const block of fallingBlocks) {
                        const { oldKey, x, y, z, type } = block;
                        
                        const meshToRemove = world[oldKey];
                        if (meshToRemove) {
                            scene.remove(meshToRemove);
                            if (meshToRemove.geometry) meshToRemove.geometry.dispose(); 
                            delete world[oldKey];
                            refreshNeighborFaces(x, y, z);
                        }

                        // If landing position has water, remove the water first
                        const targetKey = key(x, y - 1, z);
                        const targetBlock = world[targetKey];
                        if (targetBlock && targetBlock.userData.blockType === WATER_TYPE) {
                            scene.remove(targetBlock);
                            delete world[targetKey];
                        }

                        add(x, y - 1, z, type); 
                    }
                }
            }
            
            // --- NEW: Grass Spreading Physics ---
            if (!paused && dt > 0) {
                grassSpreadTimer += dt;
                
                if (grassSpreadTimer >= GRASS_SPREAD_CHECK_INTERVAL) {
                    grassSpreadTimer = 0;

                    // Calculate the chance of growth for this interval (1/300 for an average 5 minute spread)
                    const spreadChance = GRASS_SPREAD_CHECK_INTERVAL / GRASS_SPREAD_CHANCE_MAX_SECONDS; 

                    // Only process a small, random number of dirt blocks for performance
                    const dirtBlocks = [];
                    for (const k in world) {
                        const mesh = world[k];
                        if (mesh.userData.blockType === DIRT_TYPE) { // 1 is DIRT
                            dirtBlocks.push(k);
                        }
                    }
                    
                    // Shuffle the dirt blocks and only check a fraction (e.g., 50 max)
                    dirtBlocks.sort(() => Math.random() - 0.5);
                    const maxChecks = Math.min(dirtBlocks.length, 50); 
                    
                    for (let i = 0; i < maxChecks; i++) {
                        const k = dirtBlocks[i];
                        const [bx, by, bz] = k.split(',').map(Number);
                        
                        // 1. Check for light (Air/Non-solid block above it)
                        const hasLight = !world[key(bx, by + 1, bz)]; 
                        
                        if (hasLight) {
                            let hasGrassNeighbor = false;
                            
                            // 2. Check for an adjacent Grass block (source) in a 3x3 horizontal area
                            for (let dx = -1; dx <= 1; dx++) {
                                for (let dz = -1; dz <= 1; dz++) {
                                    if (dx === 0 && dz === 0) continue; // Skip self

                                    const neighbor = world[key(bx + dx, by, bz + dz)];
                                    if (neighbor && neighbor.userData.blockType === GRASS_TYPE) {
                                        hasGrassNeighbor = true;
                                        break;
                                    }
                                }
                                if (hasGrassNeighbor) break;
                            }
                            
                            if (hasGrassNeighbor) {
                                // 3. Random chance check
                                if (Math.random() < spreadChance) {
                                    
                                    // Remove old dirt block
                                    const meshToRemove = world[k];
                                    if (meshToRemove) {
                                        scene.remove(meshToRemove);
                                        if (meshToRemove.geometry) meshToRemove.geometry.dispose(); 
                                        delete world[k];
                                    }
                                    
                                    // Add new grass block (type 0) silently
                                    const grassKey = key(bx, by, bz);
                                    var m = mats[GRASS_TYPE];
                                    var mesh = new THREE.Mesh(blockGeometry, Array.isArray(m) ? m : [m, m, m, m, m, m]); 
                                    mesh.position.set(bx * bs, by * bs, bz * bs);
                                    mesh.castShadow = true;
                                    mesh.receiveShadow = true;
                                    mesh.userData.blockType = GRASS_TYPE;
                                    mesh.userData.silentPlace = true; // Flag to prevent sound
                                    scene.add(mesh);
                                    world[grassKey] = mesh;
                                }
                            }
                        }
                    }
                }
            }
            // --- END NEW: Grass Spreading Physics ---
            
            // --- LIQUID FLOW SYSTEM UPDATE ---
            if (!paused && dt > 0) {
                liquidFlowTimer += dt;
                if (liquidFlowTimer >= LIQUID_FLOW_INTERVAL) {
                    liquidFlowTimer = 0;
                    flowLiquids();
                }
            }
            // --- END LIQUID FLOW SYSTEM ---
            
            // --- HAND SWING & BOB ANIMATION ---
            // Apply animations to whichever mesh is visible (hand or item)
            const activeHandMesh = (fpHandMesh && fpHandMesh.visible) ? fpHandMesh : heldItemMesh;
            
            if (activeHandMesh && !inventoryOpen && !isDead && showItemInHand) {
                // Get base position and rotation
                const basePos = activeHandMesh.userData.basePosition || { x: 0.2, y: -0.15, z: -0.4 };
                const baseRot = activeHandMesh.userData.baseRotation || { x: -0.6, y: 0.3, z: -0.1 };
                
                // Update swing animation
                let swingOffsetY = 0;
                let swingRotX = 0;
                let swingRotZ = 0;
                
                if (isSwinging) {
                    handSwingTimer += dt;
                    
                    if (handSwingTimer >= SWING_DURATION) {
                        // Swing complete
                        isSwinging = false;
                        handSwingTimer = 0;
                    } else {
                        // Calculate swing progress (0 to 1)
                        const progress = handSwingTimer / SWING_DURATION;
                        
                        // Minecraft-style swing: fast down, slower return
                        // Use ease-out-quad for smooth deceleration
                        const easeOut = 1 - Math.pow(1 - progress, 2);
                        
                        // Swing motion: rotate around X axis (pitch) and translate Y
                        swingRotX = Math.sin(easeOut * Math.PI) * -1.2; // Big downward swing
                        swingRotZ = Math.sin(easeOut * Math.PI) * 0.3;  // Slight roll
                        swingOffsetY = Math.sin(easeOut * Math.PI) * 0.15; // Move down during swing
                    }
                }
                
                // Update bob timer only if bobbing is enabled and not swinging
                // Hand bobbing now reacts to movement speed (faster when sprinting, slower when sneaking)
                if (handBobEnabled && isMovingForBob && !isSwinging) {
                    const speedMultiplier = isSprinting ? SPRINT_MULTIPLIER : (isSneaking ? SNEAK_MULTIPLIER : 1.0);
                    handBobTimer += dt * 6.28 * speedMultiplier; // Speed-reactive bobbing
                } else {
                    handBobTimer = 0;
                }
                
                // Apply Minecraft-style bobbing motion with intensity multiplier
                const intensityMultiplier = handBobIntensity / 100; // Convert percentage to multiplier
                
                // Minecraft bobbing: primarily vertical with slight horizontal sway
                const bobY = (handBobEnabled && !isSwinging) ? 
                    Math.abs(Math.sin(handBobTimer)) * 0.04 * intensityMultiplier : 0;
                    
                const bobX = (handBobEnabled && !isSwinging) ? 
                    Math.sin(handBobTimer * 2) * 0.01 * intensityMultiplier : 0;
                
                // Minecraft bobbing also includes Z movement (forward/back)
                // When hand bobbing is disabled, use resting position (same as handBobTimer = 0)
                const bobZ = (handBobEnabled && !isSwinging) ? 
                    Math.cos(handBobTimer * 2) * 0.015 * intensityMultiplier : 0.015 * intensityMultiplier;
                
                // Apply combined position (base + bob + swing)
                activeHandMesh.position.set(
                    basePos.x + bobX,
                    basePos.y - bobY + swingOffsetY, // Negative because hand bobs down
                    basePos.z + bobZ
                );
                
                // Apply Minecraft-style rotation bobbing (more pronounced tilt)
                const tiltX = (handBobEnabled && !isSwinging) ? 
                    Math.sin(handBobTimer) * 0.15 * intensityMultiplier : 0;
                // When hand bobbing is disabled, use resting rotation (same as handBobTimer = 0)
                const tiltZ = (handBobEnabled && !isSwinging) ? 
                    Math.cos(handBobTimer * 2) * 0.08 * intensityMultiplier : 0.08 * intensityMultiplier;
                
                activeHandMesh.rotation.set(
                    baseRot.x + tiltX + swingRotX, // Natural pitch animation like Minecraft
                    baseRot.y, // Keep base yaw
                    baseRot.z + tiltZ + swingRotZ // Natural roll without flip
                );
            }
            
            // Render main scene
            renderer.render(scene, camera);
            
            // Render hand/item overlay in separate 3D dimension (always on top)
            // Only show in first-person mode - render whichever is visible
            if (!inventoryOpen && !isDead && showItemInHand && perspectiveMode === 0) {
                const shouldRenderHand = fpHandMesh && fpHandMesh.visible;
                const shouldRenderItem = heldItemMesh && (!fpHandMesh || !fpHandMesh.visible);
                
                if (shouldRenderHand || shouldRenderItem) {
                    renderer.autoClear = false; // Don't clear color buffer
                    renderer.clearDepth(); // Clear depth buffer - puts hand in separate 3D layer
                    renderer.render(handScene, handCamera);
                    renderer.autoClear = true; // Re-enable for next frame
                }
            }
        }
        
        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            handCamera.aspect = window.innerWidth / window.innerHeight;
            handCamera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Reset fake cursor on resize
            fakeCursorX = window.innerWidth / 2;
            fakeCursorY = window.innerHeight / 2;
        });
        
        // ==================== MAIN MENU MOUSE TRACKING ====================
        let mainMenuTracking = true;
        let mainMenuButtons = [];
        let mainMenuMouseX = window.innerWidth / 2;
        let mainMenuMouseY = window.innerHeight / 2;
        let mainMenuTitle = null;
        
        function initMainMenuTracking() {
            // Get all main menu buttons EXCEPT fixed-position back buttons
            mainMenuButtons = Array.from(document.querySelectorAll('.main-menu-btn:not(.fixed-back-btn)'));
            mainMenuTitle = document.querySelector('#main-menu h1');
            
            // Track mouse globally - even outside window
            document.addEventListener('mousemove', handleMainMenuTracking);
            window.addEventListener('mouseout', handleMainMenuMouseLeave);
            window.addEventListener('mouseleave', handleMainMenuMouseLeave);
            
            // Start animation loop
            animateMainMenuButtons();
        }
        
        function handleMainMenuTracking(e) {
            mainMenuMouseX = e.clientX;
            mainMenuMouseY = e.clientY;
        }
        
        function handleMainMenuMouseLeave(e) {
            // Keep the last known position when mouse leaves
            if (e.clientX !== undefined) {
                mainMenuMouseX = e.clientX;
                mainMenuMouseY = e.clientY;
            }
        }
        
        function animateMainMenuButtons() {
            if (!mainMenuTracking) {
                requestAnimationFrame(animateMainMenuButtons);
                return;
            }
            
            // Only apply if main menu is visible
            const mainMenu = document.getElementById('main-menu');
            const mainControls = document.getElementById('main-controls');
            
            if (mainMenu && mainMenu.style.display !== 'none' && mainControls && mainControls.style.display !== 'none') {
                // Animate title
                if (mainMenuTitle) {
                    const titleRect = mainMenuTitle.getBoundingClientRect();
                    const titleCenterX = titleRect.left + titleRect.width / 2;
                    const titleCenterY = titleRect.top + titleRect.height / 2;
                    
                    const titleDeltaX = mainMenuMouseX - titleCenterX;
                    const titleDeltaY = mainMenuMouseY - titleCenterY;
                    
                    const titleRotateY = (titleDeltaX / window.innerWidth) * 5;
                    const titleRotateX = -(titleDeltaY / window.innerHeight) * 5;
                    
                    mainMenuTitle.style.transform = `
                        perspective(1200px)
                        rotateX(${titleRotateX}deg)
                        rotateY(${titleRotateY}deg)
                        translateZ(10px)
                    `;
                    
                    const titleDistance = Math.sqrt(titleDeltaX * titleDeltaX + titleDeltaY * titleDeltaY);
                    const maxDist = Math.sqrt(window.innerWidth * window.innerWidth + window.innerHeight * window.innerHeight);
                    const titleGlow = 1 - (titleDistance / maxDist);
                    mainMenuTitle.style.textShadow = `
                        4px 4px 0px rgba(0, 0, 0, 0.5),
                        0 0 ${20 + titleGlow * 40}px rgba(121, 192, 90, ${titleGlow * 0.6})
                    `;
                }
                
                // Animate buttons
                mainMenuButtons.forEach((button, index) => {
                    if (!button.getBoundingClientRect) return;
                    
                    const rect = button.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    
                    const deltaX = mainMenuMouseX - centerX;
                    const deltaY = mainMenuMouseY - centerY;
                    
                    // Calculate distance for proximity effect
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    const maxDistance = 400; // Proximity threshold
                    const proximityFactor = Math.max(0, 1 - (distance / maxDistance));
                    
                    // More dramatic rotation when mouse is closer
                    const maxRotation = 12 + (proximityFactor * 8);
                    const maxTranslate = 8 + (proximityFactor * 12);
                    const rotateY = (deltaX / window.innerWidth) * maxRotation * (1 + proximityFactor);
                    const rotateX = -(deltaY / window.innerHeight) * maxRotation * (1 + proximityFactor);
                    const translateX = (deltaX / window.innerWidth) * maxTranslate;
                    const translateY = (deltaY / window.innerHeight) * maxTranslate;
                    const translateZ = 5 + (proximityFactor * 15);
                    
                    // Apply dramatic 3D effect
                    button.style.transform = `
                        perspective(800px)
                        rotateX(${rotateX}deg)
                        rotateY(${rotateY}deg)
                        translateX(${translateX}px)
                        translateY(${translateY}px)
                        translateZ(${translateZ}px)
                        scale(${1 + proximityFactor * 0.05})
                    `;
                    
                    // Dynamic glow and shadow
                    const normalizedDist = distance / Math.sqrt(window.innerWidth * window.innerWidth + window.innerHeight * window.innerHeight);
                    const glowIntensity = 1 - normalizedDist;
                    const shadowX = rotateY * 3;
                    const shadowY = -rotateX * 3;
                    
                    button.style.boxShadow = `
                        inset 0 -4px 0 0 rgba(0, 0, 0, 0.4),
                        inset 0 4px 0 0 rgba(255, 255, 255, ${0.25 + glowIntensity * 0.2}),
                        ${shadowX}px ${shadowY}px ${20 + proximityFactor * 30}px rgba(0, 0, 0, ${0.3 + proximityFactor * 0.2}),
                        0 0 ${15 + glowIntensity * 35}px rgba(121, 192, 90, ${glowIntensity * 0.5 + proximityFactor * 0.3})
                    `;
                });
            }
            
            requestAnimationFrame(animateMainMenuButtons);
        }
        
        // Initialize main menu tracking when page loads
        window.addEventListener('load', () => {
            setTimeout(initMainMenuTracking, 100);
            
            // Trigger main menu fade-in animation on page load
            const mainMenu = document.getElementById('main-menu');
            if (mainMenu && mainMenu.style.display !== 'none') {
                setTimeout(() => {
                    mainMenu.classList.add('menu-fade-in');
                    // Also trigger animation for main-controls view
                    const mainControls = document.getElementById('main-controls');
                    if (mainControls) {
                        mainControls.classList.add('menu-animate');
                    }
                }, 50);
            }
        });
        
        // ==================== STARFIELD BACKGROUND ====================
        const starfieldCanvas = document.getElementById('starfield-bg');
        const starCtx = starfieldCanvas.getContext('2d');
        let starMouseX = window.innerWidth / 2;
        let starMouseY = window.innerHeight / 2;
        let targetStarMouseX = starMouseX;
        let targetStarMouseY = starMouseY;
        
        // Star and shooting star arrays
        const stars = [];
        const shootingStars = [];
        const NUM_STARS = 300;
        
        // Star class for parallax effect
        class Star {
            constructor() {
                this.reset();
            }
            
            reset() {
                this.x = Math.random() * starfieldCanvas.width;
                this.y = Math.random() * starfieldCanvas.height;
                this.z = Math.random() * 3; // Depth layer (0-3 for parallax)
                this.size = Math.floor((1 + this.z) * 1) + 1; // Blocky sizes: 1, 2, 3, 4 pixels
                this.baseX = this.x;
                this.baseY = this.y;
                this.twinkleSpeed = Math.random() * 0.02 + 0.01;
                this.twinkleOffset = Math.random() * Math.PI * 2;
                // Color variations - white or light blue only (no green)
                const colorChoice = Math.random();
                if (colorChoice < 0.7) {
                    this.color = `rgba(255, 255, 255, ${0.4 + Math.random() * 0.6})`;
                } else {
                    this.color = `rgba(200, 220, 255, ${0.4 + Math.random() * 0.6})`;
                }
            }
            
            update(mouseX, mouseY) {
                // Parallax effect based on mouse position
                const parallaxStrength = (this.z + 1) * 20;
                const centerX = starfieldCanvas.width / 2;
                const centerY = starfieldCanvas.height / 2;
                
                const offsetX = (mouseX - centerX) / centerX;
                const offsetY = (mouseY - centerY) / centerY;
                
                this.x = this.baseX - offsetX * parallaxStrength;
                this.y = this.baseY - offsetY * parallaxStrength;
                
                // Wrap around screen
                if (this.x < -10) this.baseX += starfieldCanvas.width + 20;
                if (this.x > starfieldCanvas.width + 10) this.baseX -= starfieldCanvas.width + 20;
                if (this.y < -10) this.baseY += starfieldCanvas.height + 20;
                if (this.y > starfieldCanvas.height + 10) this.baseY -= starfieldCanvas.height + 20;
            }
            
            draw(ctx, time) {
                // Twinkling effect
                const twinkle = Math.sin(time * this.twinkleSpeed + this.twinkleOffset) * 0.3 + 0.7;
                const alpha = parseFloat(this.color.match(/[\d.]+\)$/)[0]);
                const baseColor = this.color.substring(0, this.color.lastIndexOf(','));
                
                // Draw blocky star (rectangle instead of circle)
                ctx.fillStyle = `${baseColor}, ${alpha * twinkle})`;
                const roundedX = Math.floor(this.x);
                const roundedY = Math.floor(this.y);
                ctx.fillRect(roundedX, roundedY, this.size, this.size);
                
                // Add blocky glow for larger stars
                if (this.size >= 3 && twinkle > 0.8) {
                    ctx.fillStyle = `${baseColor}, ${alpha * twinkle * 0.3})`;
                    ctx.fillRect(roundedX - 1, roundedY - 1, this.size + 2, this.size + 2);
                    
                    ctx.fillStyle = `${baseColor}, ${alpha * twinkle * 0.15})`;
                    ctx.fillRect(roundedX - 2, roundedY - 2, this.size + 4, this.size + 4);
                }
            }
        }
        
        // Shooting star class
        class ShootingStar {
            constructor() {
                this.reset();
            }
            
            reset() {
                // Start from random position on top or sides
                const side = Math.random();
                if (side < 0.5) {
                    this.x = Math.random() * starfieldCanvas.width;
                    this.y = -10;
                } else {
                    this.x = starfieldCanvas.width + 10;
                    this.y = Math.random() * starfieldCanvas.height * 0.5;
                }
                
                // Direction (always moving down-right or down-left)
                this.angle = Math.PI / 4 + (Math.random() - 0.5) * 0.5;
                this.speed = 3 + Math.random() * 4;
                this.length = 40 + Math.random() * 60;
                this.thickness = 1 + Math.random() * 1.5;
                this.life = 1;
                this.fadeSpeed = 0.01 + Math.random() * 0.02;
                
                // Greenish shooting star
                this.color = Math.random() < 0.3 ? 
                    'rgba(121, 192, 90' : 
                    'rgba(255, 255, 255';
            }
            
            update() {
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
                this.life -= this.fadeSpeed;
                
                return this.life > 0 && 
                       this.x < starfieldCanvas.width + 100 && 
                       this.y < starfieldCanvas.height + 100;
            }
            
            draw(ctx) {
                const tailX = this.x - Math.cos(this.angle) * this.length;
                const tailY = this.y - Math.sin(this.angle) * this.length;
                
                // Create gradient for tail
                const gradient = ctx.createLinearGradient(this.x, this.y, tailX, tailY);
                gradient.addColorStop(0, `${this.color}, ${this.life * 0.9})`);
                gradient.addColorStop(0.5, `${this.color}, ${this.life * 0.5})`);
                gradient.addColorStop(1, `${this.color}, 0)`);
                
                ctx.strokeStyle = gradient;
                ctx.lineWidth = this.thickness;
                ctx.lineCap = 'round';
                
                ctx.beginPath();
                ctx.moveTo(tailX, tailY);
                ctx.lineTo(this.x, this.y);
                ctx.stroke();
                
                // Bright head
                ctx.fillStyle = `${this.color}, ${this.life})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.thickness * 1.5, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Initialize starfield canvas
        function initStarfieldCanvas() {
            starfieldCanvas.width = window.innerWidth;
            starfieldCanvas.height = window.innerHeight;
            
            // Create stars
            stars.length = 0;
            for (let i = 0; i < NUM_STARS; i++) {
                stars.push(new Star());
            }
        }
        
        // Track mouse for starfield parallax
        document.addEventListener('mousemove', (e) => {
            targetStarMouseX = e.clientX;
            targetStarMouseY = e.clientY;
        });
        
        window.addEventListener('mouseout', (e) => {
            if (e.clientX !== undefined) {
                targetStarMouseX = e.clientX;
                targetStarMouseY = e.clientY;
            }
        });
        
        // Smooth interpolation for starfield
        function updateStarfieldMouse() {
            starMouseX += (targetStarMouseX - starMouseX) * 0.05;
            starMouseY += (targetStarMouseY - starMouseY) * 0.05;
        }
        
        // Spawn shooting stars randomly
        function maybeSpawnShootingStar() {
            if (Math.random() < 0.01 && shootingStars.length < 3) {
                shootingStars.push(new ShootingStar());
            }
        }
        
        // Draw starfield
        function drawStarfield() {
            const width = starfieldCanvas.width;
            const height = starfieldCanvas.height;
            const time = Date.now() * 0.001;
            
            // Clear canvas
            starCtx.clearRect(0, 0, width, height);
            
            // Update and draw stars
            stars.forEach(star => {
                star.update(starMouseX, starMouseY);
                star.draw(starCtx, time);
            });
            
            // Update and draw shooting stars
            maybeSpawnShootingStar();
            
            for (let i = shootingStars.length - 1; i >= 0; i--) {
                const shootingStar = shootingStars[i];
                if (!shootingStar.update()) {
                    shootingStars.splice(i, 1);
                } else {
                    shootingStar.draw(starCtx);
                }
            }
        }
        
        // Animation loop for starfield
        function animateStarfield() {
            const mainMenu = document.getElementById('main-menu');
            
            // Show starfield whenever main menu is visible (keep enabled in menus)
            if (mainMenu && mainMenu.style.display !== 'none') {
                starfieldCanvas.classList.add('active');
                updateStarfieldMouse();
                drawStarfield();
            } else {
                starfieldCanvas.classList.remove('active');
            }
            
            requestAnimationFrame(animateStarfield);
        }
        
        // ==================== GRID BACKGROUND REMOVED ====================
        // Replaced with cleaner blocky Minecraft aesthetic
        
        // Handle window resize for starfield
        window.addEventListener('resize', () => {
            initStarfieldCanvas();
        });
        
        // Initialize starfield and start background music
        window.addEventListener('load', () => {
            initStarfieldCanvas();
            animateStarfield();
            // Start background music when page loads (in main menu)
            setTimeout(() => {
                // Set initial game state
                setGameState(GAME_STATE.MAIN_MENU);
                startBackgroundMusic();
            }, 500); // Small delay to ensure audio context is ready
        });
        
        
    </script>
</body>
</html>
