<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Minecraft HTML Edition</title>
    <style>
        /* General Setup & Fonts */
        body { margin: 0; overflow: hidden; font-family: 'Pixelify Sans', monospace; background: #000; }
        @import url('https://fonts.googleapis.com/css2?family=Pixelify+Sans:wght@400..700&family=Press+Start+2P&display=swap');
        canvas { display: block; cursor: pointer; }
        
        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes slideUp {
            from { transform: translateY(100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        @keyframes glow {
            0%, 100% { box-shadow: 0 0 5px var(--selection-glow), inset 0 0 5px rgba(0, 191, 255, 0.3); }
            50% { box-shadow: 0 0 15px var(--selection-glow), inset 0 0 10px rgba(0, 191, 255, 0.5); }
        }
        
        @keyframes pixelate {
            0% { filter: blur(2px); opacity: 0; }
            100% { filter: blur(0); opacity: 1; }
        }
        
        /* Minecraft-Style Colors */
        :root {
            --primary-bg: rgba(0, 0, 0, 1); 
            --menu-bg-accent: rgba(55, 55, 55, 1);
            --menu-bg-pattern: linear-gradient(45deg, rgba(60, 60, 60, 0.5) 25%, transparent 25%, transparent 75%, rgba(60, 60, 60, 0.5) 75%, rgba(60, 60, 60, 0.5)),
                               linear-gradient(45deg, rgba(60, 60, 60, 0.5) 25%, transparent 25%, transparent 75%, rgba(60, 60, 60, 0.5) 75%, rgba(60, 60, 60, 0.5));
            --primary-text: #fff;
            --main-action: #5cb85c; 
            --main-action-hover: #4cae4c;
            --secondary-action: #888; 
            --secondary-action-hover: #777;
            --warning-color: #d9534f;
            --inventory-border: #555; 
            --item-slot-bg: #373737; 
            --hotbar-slot-bg: #282828; 
            --hotbar-border: #555; 
            --selection-glow: #fff; 
            --selection-red: #d9534f;
            --button-shadow: 0 4px 0 0 rgba(0, 0, 0, 0.4);
            --button-active-shadow: 0 2px 0 0 rgba(0, 0, 0, 0.4);
        }

        /* Information Overlays (FPS, Coords) */
        #ui, #fps { 
            position: absolute; color: var(--primary-text); 
            background: rgba(0, 0, 0, 0.6); 
            padding: 8px 12px; 
            border-radius: 6px; 
            pointer-events: none; 
            z-index: 5; 
            font-size: 13px;
        }
        #ui { top: 10px; left: 10px; white-space: pre; }
        #fps { top: 10px; right: 10px; }
        
        /* Health Hearts (Above Hotbar - Left Side) */
        #health-container {
            position: absolute;
            bottom: 88px;
            left: 50%;
            transform: translateX(-232px);
            display: none;
            z-index: 5;
        }
        
        .heart {
            display: inline-block;
            width: 18px;
            height: 18px;
            margin: 0 1px;
            position: relative;
            image-rendering: pixelated;
        }
        
        /* Pixel art heart using box-shadow */
        .heart::before {
            content: '';
            position: absolute;
            width: 2px;
            height: 2px;
            background: currentColor;
            box-shadow: 
                /* Row 1 */
                0px 0px 0 0px currentColor,
                4px 0px 0 0px currentColor,
                10px 0px 0 0px currentColor,
                14px 0px 0 0px currentColor,
                /* Row 2 */
                -2px 2px 0 0px currentColor,
                0px 2px 0 0px currentColor,
                2px 2px 0 0px currentColor,
                4px 2px 0 0px currentColor,
                6px 2px 0 0px currentColor,
                8px 2px 0 0px currentColor,
                10px 2px 0 0px currentColor,
                12px 2px 0 0px currentColor,
                14px 2px 0 0px currentColor,
                16px 2px 0 0px currentColor,
                /* Row 3 */
                -2px 4px 0 0px currentColor,
                0px 4px 0 0px currentColor,
                2px 4px 0 0px currentColor,
                4px 4px 0 0px currentColor,
                6px 4px 0 0px currentColor,
                8px 4px 0 0px currentColor,
                10px 4px 0 0px currentColor,
                12px 4px 0 0px currentColor,
                14px 4px 0 0px currentColor,
                16px 4px 0 0px currentColor,
                /* Row 4 */
                -2px 6px 0 0px currentColor,
                0px 6px 0 0px currentColor,
                2px 6px 0 0px currentColor,
                4px 6px 0 0px currentColor,
                6px 6px 0 0px currentColor,
                8px 6px 0 0px currentColor,
                10px 6px 0 0px currentColor,
                12px 6px 0 0px currentColor,
                14px 6px 0 0px currentColor,
                16px 6px 0 0px currentColor,
                /* Row 5 */
                0px 8px 0 0px currentColor,
                2px 8px 0 0px currentColor,
                4px 8px 0 0px currentColor,
                6px 8px 0 0px currentColor,
                8px 8px 0 0px currentColor,
                10px 8px 0 0px currentColor,
                12px 8px 0 0px currentColor,
                14px 8px 0 0px currentColor,
                /* Row 6 */
                2px 10px 0 0px currentColor,
                4px 10px 0 0px currentColor,
                6px 10px 0 0px currentColor,
                8px 10px 0 0px currentColor,
                10px 10px 0 0px currentColor,
                12px 10px 0 0px currentColor,
                /* Row 7 */
                4px 12px 0 0px currentColor,
                6px 12px 0 0px currentColor,
                8px 12px 0 0px currentColor,
                10px 12px 0 0px currentColor,
                /* Row 8 */
                6px 14px 0 0px currentColor,
                8px 14px 0 0px currentColor;
        }
        
        .heart.full { color: #ff0000; }
        .heart.half { color: #ff6666; }
        .heart.empty { color: #444; }
        
        @keyframes heart-beat {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.15); }
        }
        
        .heart.low {
            animation: heart-beat 0.5s ease-in-out infinite;
        }
        
        /* Oxygen Bubbles (Above Hotbar - Right Side) */
        #oxygen-container {
            position: absolute;
            bottom: 88px;
            left: 50%;
            transform: translateX(32px);
            display: none;
            z-index: 5;
            text-align: left;
        }
        
        .bubble {
            display: inline-block;
            width: 18px;
            height: 18px;
            margin: 0 1px;
            position: relative;
            image-rendering: pixelated;
        }
        
        /* Pixel art bubble using box-shadow */
        .bubble::before {
            content: '';
            position: absolute;
            width: 2px;
            height: 2px;
            background: currentColor;
            box-shadow: 
                /* Row 1 - top */
                4px 0px 0 0px currentColor,
                6px 0px 0 0px currentColor,
                8px 0px 0 0px currentColor,
                10px 0px 0 0px currentColor,
                /* Row 2 */
                2px 2px 0 0px currentColor,
                4px 2px 0 0px currentColor,
                10px 2px 0 0px currentColor,
                12px 2px 0 0px currentColor,
                /* Row 3 */
                0px 4px 0 0px currentColor,
                2px 4px 0 0px currentColor,
                12px 4px 0 0px currentColor,
                14px 4px 0 0px currentColor,
                /* Row 4 */
                0px 6px 0 0px currentColor,
                2px 6px 0 0px currentColor,
                12px 6px 0 0px currentColor,
                14px 6px 0 0px currentColor,
                /* Row 5 */
                0px 8px 0 0px currentColor,
                2px 8px 0 0px currentColor,
                12px 8px 0 0px currentColor,
                14px 8px 0 0px currentColor,
                /* Row 6 */
                0px 10px 0 0px currentColor,
                2px 10px 0 0px currentColor,
                12px 10px 0 0px currentColor,
                14px 10px 0 0px currentColor,
                /* Row 7 */
                2px 12px 0 0px currentColor,
                4px 12px 0 0px currentColor,
                10px 12px 0 0px currentColor,
                12px 12px 0 0px currentColor,
                /* Row 8 - bottom */
                4px 14px 0 0px currentColor,
                6px 14px 0 0px currentColor,
                8px 14px 0 0px currentColor,
                10px 14px 0 0px currentColor;
        }
        
        /* Add highlight for bubble */
        .bubble::after {
            content: '';
            position: absolute;
            width: 2px;
            height: 2px;
            background: rgba(255, 255, 255, 0.8);
            box-shadow: 
                4px 4px 0 0px rgba(255, 255, 255, 0.8),
                6px 4px 0 0px rgba(255, 255, 255, 0.8),
                4px 6px 0 0px rgba(255, 255, 255, 0.6);
        }
        
        .bubble { color: #3a9fef; }
        .bubble.popped { color: #333; opacity: 0.5; }
        
        @keyframes bubble-pop {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.5; }
            100% { transform: scale(0); opacity: 0; }
        }
        
        /* Death Screen */
        #death-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(180, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1500;
        }
        
        #death-screen h1 {
            font-size: 72px;
            color: #fff;
            text-shadow: 4px 4px 0 rgba(0, 0, 0, 0.8);
            margin-bottom: 30px;
            animation: fadeIn 1s ease;
        }
        
        #death-screen p {
            font-size: 24px;
            color: #ffaaaa;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.8);
            margin-bottom: 40px;
        }
        
        #death-respawn-btn {
            padding: 20px 40px;
            font-size: 24px;
            background: var(--main-action);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            box-shadow: var(--button-shadow);
            font-family: 'Pixelify Sans', monospace;
            font-weight: 600;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.8);
            transition: all 0.1s ease;
        }
        
        #death-respawn-btn:hover {
            background: var(--main-action-hover);
            transform: translateY(-2px);
        }
        
        #death-respawn-btn:active {
            transform: translateY(2px);
        }

        /* Crosshair */
        #crosshair { 
            position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%,-50%); 
            pointer-events: none; 
            width: 20px; height: 20px; 
            z-index: 5;
            mix-blend-mode: difference;
        }
        #crosshair::before { content: ''; position: absolute; background: white; width: 20px; height: 2px; left: 0; top: 9px; }
        #crosshair::after { content: ''; position: absolute; background: white; width: 2px; height: 20px; left: 9px; top: 0; }
        
        /* MODIFIED: Fake Cursor for Inventory - Now looks like the crosshair and is centered */
        #fake-cursor {
            position: absolute;
            width: 20px; 
            height: 20px; 
            z-index: 2000; 
            pointer-events: none; 
            display: none; 
            /* NEW: Center the cursor on the mouse coordinates */
            transform: translate(-50%, -50%); 
        }
        #fake-cursor::before { 
            content: ''; 
            position: absolute; 
            background: white; 
            width: 20px; 
            height: 2px; 
            left: 0; 
            top: 9px; 
        }
        #fake-cursor::after { 
            content: ''; 
            position: absolute; 
            background: white; 
            width: 2px; 
            height: 20px; 
            left: 9px; 
            top: 0; 
        }

        /* Toolbar (HUD) - 8 Slots with Connected Minecraft Style */
        #toolbar { 
            position: absolute; bottom: 20px; left: 50%; 
            transform: translateX(-50%); 
            display: flex; gap: 0px; 
            z-index: 5;
            background: var(--hotbar-slot-bg);
            border: 3px solid var(--hotbar-border);
            border-radius: 4px;
            padding: 2px;
            box-shadow: inset -2px -2px 0 0 rgba(0, 0, 0, 0.5), inset 2px 2px 0 0 rgba(255, 255, 255, 0.1);
        }
        #toolbar button { 
            width: 55px; height: 55px; 
            border: 2px solid rgba(85, 85, 85, 0.3); 
            border-radius: 2px; 
            cursor: pointer; 
            font-size: 10px; 
            color: var(--primary-text); 
            background: var(--hotbar-slot-bg); 
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column; 
            justify-content: center; 
            align-items: center;
            position: relative;
            box-shadow: inset -1px -1px 0 0 rgba(0, 0, 0, 0.3), inset 1px 1px 0 0 rgba(255, 255, 255, 0.1);
            image-rendering: pixelated;
        }
        
        /* Remove gap between buttons */
        #toolbar button:not(:last-child) {
            border-right: 1px solid rgba(85, 85, 85, 0.5);
        }
        
        /* Hotbar Selection Style (Minecraft-like) */
        #toolbar button.selected { 
            border-color: var(--selection-glow);
            background: rgba(255, 255, 255, 0.2);
            animation: glow 1.5s ease-in-out infinite;
            transform: translateY(-2px);
            z-index: 1;
        }
        #toolbar button:hover:not(.selected) { 
            border-color: #999;
            transform: translateY(-1px);
            background: rgba(255, 255, 255, 0.1);
        }
        
        #toolbar button:active {
            transform: translateY(0);
        }

        /* Text Content in Hotbar Buttons */
        #toolbar button .slot-item {
            font-size: 11px; 
            font-weight: bold; 
            text-shadow: 1px 1px 2px #000; 
            line-height: 1.1;
        }
        #toolbar button .slot-count {
            position: absolute;
            bottom: 2px;
            right: 4px; 
            font-size: 10px;
            font-weight: bold;
            color: #fff;
            background: rgba(0, 0, 0, 0.5);
            padding: 1px 4px;
            border-radius: 4px;
            min-width: 10px;
            text-align: center;
        }
        
        /* Menu Container Styles with Minecraft Background */
        #main-menu, #pause-menu { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0, 0, 0, 1);
            background-image: var(--menu-bg-pattern);
            background-size: 20px 20px;
            background-position: 0 0, 10px 10px;
            display: flex; flex-direction: column; 
            align-items: center; justify-content: center; 
            color: var(--primary-text); 
            z-index: 1000;
        }
        
        /* MODIFIED: Inventory Screen (Single Unified Window) */
        #inventory-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0, 0, 0, 0.75);
            background-image: var(--menu-bg-pattern);
            background-size: 20px 20px;
            background-position: 0 0, 10px 10px;
            display: none;
            align-items: center; 
            justify-content: center; 
            color: var(--primary-text); 
            z-index: 1000;
        }

        /* Inventory Container (Unified Single Window) */
        .inventory-container {
            padding: 20px; 
            background: var(--menu-bg-accent);
            border-radius: 8px; 
            box-shadow: 0 8px 0 0 rgba(0, 0, 0, 0.5), 0 0 30px rgba(0, 0, 0, 0.9);
            border: 3px solid #555;
            max-width: 500px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .inventory-container h2 { 
            text-align: center; 
            margin: 0; 
            font-size: 24px;
            text-shadow: 3px 3px 0 rgba(0, 0, 0, 0.8);
            letter-spacing: 1px;
        }
        
        /* Main Inventory Grid (8x3) */
        #main-inventory-grid {
            display: grid;
            grid-template-columns: repeat(8, 50px); 
            gap: 4px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid var(--inventory-border);
            border-radius: 6px; 
            pointer-events: all; 
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.4);
            justify-content: center;
        }

        /* HUD Inventory Grid (8 Slots, Perfectly Aligned) */
        #hud-inventory-grid {
            display: grid;
            grid-template-columns: repeat(8, 50px); 
            gap: 4px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border: 3px solid var(--selection-glow); 
            border-radius: 6px; 
            pointer-events: all;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.3), inset 0 2px 8px rgba(0, 0, 0, 0.4);
            justify-content: center;
        }
        
        /* Section Labels */
        .inventory-section-label {
            font-size: 12px;
            font-weight: bold;
            color: #999;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-align: center;
            margin: 5px 0 -5px 0;
        }

        /* NEW: Game Mode Toggle Button (Minecraft Style) */
        #gameModeToggleBtn {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            font-family: 'Pixelify Sans', monospace;
            background: var(--main-action);
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.1s ease;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.8);
            box-shadow: var(--button-shadow);
            font-weight: 600;
        }
        #gameModeToggleBtn:hover { 
            background: var(--main-action-hover); 
            transform: translateY(-2px);
            box-shadow: 0 6px 0 0 rgba(0, 0, 0, 0.4);
        }
        #gameModeToggleBtn:active {
            transform: translateY(2px);
            box-shadow: var(--button-active-shadow);
        }
        
        /* NEW: Creative Panel (Integrated within inventory) */
        #creative-panel {
            display: none;
            flex-direction: row;
            gap: 15px;
            align-items: flex-start;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            border: 2px solid var(--inventory-border);
        }

        /* Show panel when inventory is open in creative mode */
        #inventory-screen.creative-mode #creative-panel {
            display: flex;
        }

        /* Creative Block Picker (Integrated) */
        #creative-block-picker {
            display: grid;
            grid-template-columns: repeat(7, 50px);
            gap: 4px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            border: 2px solid #555;
            max-height: 220px;
            overflow-y: auto;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.4);
        }
        
        #creative-block-picker .inventory-slot {
            width: 50px;
            height: 50px;
        }
        
        /* Creative Picker Wrapper */
        #creative-picker-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        /* Scrollbar Styling */
        #creative-block-picker::-webkit-scrollbar {
            width: 6px;
        }
        #creative-block-picker::-webkit-scrollbar-track {
            background: #222;
            border-radius: 3px;
        }
        #creative-block-picker::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 3px;
        }
        #creative-block-picker::-webkit-scrollbar-thumb:hover {
            background: #777;
        }
        
        /* Delete Slot Wrapper */
        #delete-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        
        /* Delete Slot (Compact, Integrated) */
        #delete-slot {
            width: 50px;
            height: 50px;
            background: var(--item-slot-bg);
            border: 3px solid var(--warning-color);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 0 0 rgba(0, 0, 0, 0.5), inset -2px -2px 0 0 rgba(0, 0, 0, 0.6);
            transition: all 0.15s ease;
            position: relative;
        }
        
        /* Pixelated X */
        #delete-slot::before,
        #delete-slot::after {
            content: '';
            position: absolute;
            background: var(--warning-color);
            box-shadow: 0 0 8px var(--warning-color);
        }
        
        #delete-slot::before {
            width: 5px;
            height: 35px;
            transform: rotate(45deg);
        }
        
        #delete-slot::after {
            width: 5px;
            height: 35px;
            transform: rotate(-45deg);
        }
        
        #delete-slot:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 0 0 rgba(0, 0, 0, 0.5), 0 0 15px var(--warning-color);
            background: rgba(217, 83, 79, 0.2);
        }
        
        #delete-slot:active {
            transform: scale(1.05) translateY(2px);
            box-shadow: 0 2px 0 0 rgba(0, 0, 0, 0.5);
        }

        /* Default Slot Styling (Consistent Size) */
        .inventory-slot {
            width: 50px;
            height: 50px;
            border: 2px solid var(--inventory-border);
            background: var(--item-slot-bg);
            border-radius: 4px; 
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #ccc;
            transition: all 0.12s ease;
            position: relative; 
            cursor: pointer;
            box-shadow: inset -2px -2px 0 0 rgba(0, 0, 0, 0.6), inset 2px 2px 0 0 rgba(255, 255, 255, 0.1);
            image-rendering: pixelated;
        }
        
        .inventory-slot:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: scale(1.05);
            border-color: #888;
        }
        
        /* Block picker slots */
        #creative-block-picker .inventory-slot {
            border-color: var(--hotbar-border);
        }
        /* No hover effect, as fake cursor provides feedback */
        /* #creative-block-picker .inventory-slot:hover { ... } */


        /* HUD Slot Styling */
        .inventory-slot.hud-slot {
            background: var(--hotbar-slot-bg); 
            border: 3px solid var(--hotbar-border);
            width: 50px;
            height: 50px;
        }
        
        /* Selection Highlight */
        .slot-selected {
            border-color: var(--selection-glow) !important; 
            background-color: rgba(255, 255, 255, 0.25);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.8), inset 0 0 6px rgba(255, 255, 255, 0.3);
        }

        /* REMOVED: Red selector no longer needed, item follows cursor */
        /* .slot-selected-red { ... } */
        
        /* Text Content in Inventory Slots */
        .inventory-slot .slot-item { 
            font-size: 10px; 
            font-weight: bold; 
            color: white; 
            text-shadow: 2px 2px 3px #000; 
            text-align: center;
            line-height: 1.2;
        }
        .inventory-slot .slot-count { 
            position: absolute;
            bottom: 3px;
            right: 3px;
            font-size: 11px; 
            font-weight: bold;
            color: #fff; 
            background: rgba(0, 0, 0, 0.6);
            padding: 1px 4px;
            border-radius: 3px;
            min-width: 14px;
            text-align: center;
            text-shadow: 1px 1px 2px #000;
        }

        /* MODIFIED: Item held by the fake mouse (Minecraft Style) */
        #picked-up-item {
            display: none;
            width: 45px;
            height: 45px;
            border: 2px solid var(--selection-red);
            background: var(--item-slot-bg);
            border-radius: 3px; 
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #ccc;
            position: absolute; 
            z-index: 2100;
            pointer-events: none;
            box-shadow: 0 0 12px var(--selection-red), 0 4px 0 0 rgba(0, 0, 0, 0.5);
            transform: translate(-50%, -50%);
        }
        
        /* Menu Control/Button Styles with Minecraft Look */
        .menu-view { 
            display: flex; flex-direction: column; align-items: center; 
            padding: 40px 50px; 
            background: var(--menu-bg-accent); 
            border-radius: 8px; 
            box-shadow: 0 8px 0 0 rgba(0, 0, 0, 0.5), 0 0 30px rgba(0, 0, 0, 0.8);
            border: 2px solid #555;
        }
        .menu-view h1, .menu-view h2 {
            text-shadow: 3px 3px 0 rgba(0, 0, 0, 0.8);
            letter-spacing: 2px;
        }
        .menu-control { margin: 10px 0; font-size: 16px; display: flex; align-items: center; justify-content: space-between; width: 350px; padding: 5px; }
        .menu-control label { text-align: right; padding-right: 15px; text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.5); }
        .menu-control input { 
            padding: 10px; font-size: 16px; 
            border: 2px solid #555; 
            background: #222; 
            color: var(--primary-text); 
            width: 200px; text-align: center; 
            border-radius: 4px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
        }
        .main-menu-btn { 
            padding: 15px 30px; 
            font-size: 16px; 
            border: none; 
            border-radius: 4px; 
            color: var(--primary-text); 
            cursor: pointer; 
            margin: 10px 0; 
            width: 300px; 
            transition: all 0.1s ease;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.8);
            box-shadow: var(--button-shadow);
            position: relative;
            font-family: 'Pixelify Sans', monospace;
            font-weight: 600;
        }
        .main-menu-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 0 0 rgba(0, 0, 0, 0.4);
        }
        .main-menu-btn:active {
            transform: translateY(2px);
            box-shadow: var(--button-active-shadow);
        }
        #main-controls button:first-child { background: var(--main-action); }
        #main-controls button:first-child:hover { background: var(--main-action-hover); }
        .main-menu-btn { background: var(--secondary-action); }
        .main-menu-btn:hover { background: var(--secondary-action-hover); }
        
        /* MODIFIED: Pause Menu Styling (Minecraft Style) */
        #pause-menu { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0, 0, 0, 1);
            background-image: var(--menu-bg-pattern);
            background-size: 20px 20px;
            background-position: 0 0, 10px 10px;
            display: none; 
            flex-direction: column; 
            align-items: center; justify-content: center; 
            color: var(--primary-text); 
            z-index: 1000;
            font-size: 18px;
        }
        
        /* MODIFIED: Menu View for Pause Menu */
        #pause-menu .menu-view {
            padding: 30px 40px; 
            background: var(--menu-bg-accent);
            border-radius: 8px; 
            box-shadow: 0 8px 0 0 rgba(0, 0, 0, 0.5), 0 0 30px rgba(0, 0, 0, 0.9);
            border: 2px solid #555;
            width: 400px;
            text-align: center;
        }

        #pause-menu h2 { 
            font-size: 28px; 
            margin-bottom: 25px; 
            color: var(--warning-color);
            text-shadow: 3px 3px 0 rgba(0, 0, 0, 0.8);
            letter-spacing: 2px;
        }

        #pause-menu p { 
            max-width: 400px; 
            text-align: center; 
            margin-top: 10px; 
            font-size: 16px;
            color: #ccc;
            text-shadow: 1px 1px 0 rgba(0, 0, 0, 0.5);
        }

        #pause-menu .menu-control { 
            margin: 15px 0; 
            width: 100%;
        }

        #progress-warning { 
            color: var(--primary-text);
            background: var(--warning-color); 
            padding: 8px 15px;
            border-radius: 4px;
            font-weight: bold; 
            margin-top: 20px; 
            margin-bottom: 25px;
            box-shadow: 0 4px 0 0 rgba(0, 0, 0, 0.4);
        }
        
        
        /* MODIFIED: Simplified Bottom Right Version Text */
        #version-text { 
            position: absolute; 
            bottom: 5px; 
            right: 5px; 
            color: rgba(255, 255, 255, 0.5); 
            font-size: 10px; 
            pointer-events: none; 
            z-index: 5; 
            text-align: right; 
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <canvas id="c"></canvas>
    
    <div id="main-menu">
        <div id="main-controls" class="menu-view">
            <h1>MINECRAFT HTML EDITION</h1>
            <button id="showCreationBtn" class="main-menu-btn">CREATE WORLD</button>
            <button id="showSavedWorldsBtn" class="main-menu-btn">SAVED WORLDS</button>
            <button id="showSettingsBtn" class="main-menu-btn">SETTINGS</button>
            <button id="showCreditsBtn" class="main-menu-btn">CREDITS</button>
        </div>
        <div id="creation-view" class="menu-view" style="display: none;">
            <h2>CREATE NEW WORLD</h2>
            <div class="menu-control">
                <label for="seedInput">World Seed:</label>
                <input type="number" id="seedInput" placeholder="Leave empty for random">
            </div>
            <div class="menu-control" style="flex-direction: column; align-items: flex-start; width: 350px;">
                <label for="worldSizeSlider" style="padding-right: 0; text-align: left; margin-bottom: 5px;">World Size: <span id="worldSizeValue">40</span> Chunks</label>
                <input type="range" id="worldSizeSlider" min="20" max="100" value="40" step="10" style="width: 100%; height: 30px; cursor: pointer; background: #333; border: none; padding: 0;">
            </div>
            <p style="font-size: 14px; color: #ccc; margin-top: 5px; margin-bottom: 20px;">Larger worlds may impact performance.</p>
            <div class="menu-control">
                <label for="flatWorldCheckbox" style="cursor: pointer; display: flex; align-items: center; gap: 10px;">
                    <input type="checkbox" id="flatWorldCheckbox" style="width: 20px; height: 20px; cursor: pointer;">
                    <span>Flat World</span>
                </label>
            </div>
            <button id="createWorldBtn" class="main-menu-btn" style="background: var(--main-action);">START GAME</button>
            <button id="backFromCreationBtn" class="main-menu-btn">BACK</button>
        </div>
        <div id="settings-view" class="menu-view" style="display: none;">
            <h2>SETTINGS</h2>
            
            <div class="menu-control" style="flex-direction: column; align-items: flex-start; width: 350px;">
                <label for="renderDistanceSlider" style="padding-right: 0; text-align: left; margin-bottom: 5px;">View Distance: <span id="renderDistanceValue">25</span> Blocks</label>
                <input type="range" id="renderDistanceSlider" min="10" max="50" value="25" step="5" style="width: 100%; height: 30px; cursor: pointer; background: #333; border: none; padding: 0;">
            </div>
            <p style="font-size: 14px; color: #ccc; margin-top: 5px; margin-bottom: 20px;">How far you can see blocks in the distance. Higher values impact performance.</p>
            
            <div class="menu-control" style="flex-direction: column; align-items: flex-start; width: 350px;">
                <label for="sensitivitySlider" style="padding-right: 0; text-align: left; margin-bottom: 5px;">Mouse Sensitivity: <span id="sensitivityValue">100</span>%</label>
                <input type="range" id="sensitivitySlider" min="25" max="200" value="100" step="5" style="width: 100%; height: 30px; cursor: pointer; background: #333; border: none; padding: 0;">
            </div>
            <p style="font-size: 14px; color: #ccc; margin-top: 5px; margin-bottom: 20px;">Adjust how fast the camera rotates when moving the mouse.</p>
            
            <div class="menu-control" style="flex-direction: column; align-items: flex-start; width: 350px;">
                <label for="fovSlider" style="padding-right: 0; text-align: left; margin-bottom: 5px;">Field of View: <span id="fovValue">75</span>Â°</label>
                <input type="range" id="fovSlider" min="50" max="110" value="75" step="5" style="width: 100%; height: 30px; cursor: pointer; background: #333; border: none; padding: 0;">
            </div>
            <p style="font-size: 14px; color: #ccc; margin-top: 5px; margin-bottom: 20px;">Adjust the camera field of view. Higher values show more of the world.</p>
            
            <button id="backFromSettingsBtn" class="main-menu-btn">BACK</button>
        </div>
        <div id="saved-worlds-view" class="menu-view" style="display: none;">
            <h2>SAVED WORLDS</h2>
            <div id="saved-worlds-list" style="max-height: 400px; overflow-y: auto; width: 100%; margin-bottom: 20px;">
                <!-- Saved worlds will be listed here -->
            </div>
            <button id="backFromSavedWorldsBtn" class="main-menu-btn">BACK</button>
        </div>
        <div id="credits-view" class="menu-view" style="display: none;">
            <h2>CREDITS</h2>
            <p style="font-weight: bold; font-size: 18px; margin-bottom: 5px;">Concept & Direction:</p>
            <p style="margin-top: 0; color: #aaa;">Matko802</p>
            <p style="font-weight: bold; font-size: 18px; margin-bottom: 5px;">Code Implementation:</p>
            <p style="margin-top: 0; color: #aaa;">Gemini (Google),Lovable</p>
            <p style="font-weight: bold; font-size: 18px; margin-bottom: 5px;">Inspired By:</p>
            <p style="margin-top: 0; color: #aaa;">Minecraft (Original Game by Mojang AB)</p>
            <button id="backFromCreditsBtn" class="main-menu-btn">BACK</button>
        </div>
    </div>
    
    <div id="inventory-screen">
        <div class="inventory-container">
            <h2>INVENTORY</h2>
            
            <div class="inventory-section-label">Storage</div>
            <div id="main-inventory-grid"></div>
            
            <div class="inventory-section-label">Hotbar</div>
            <div id="hud-inventory-grid"></div>
            
            <div id="creative-panel">
                <div id="creative-picker-wrapper">
                    <div class="inventory-section-label">Blocks</div>
                    <div id="creative-block-picker"></div>
                </div>
                <div id="delete-wrapper">
                    <div class="inventory-section-label" style="color: var(--warning-color);">Delete</div>
                    <div id="delete-slot"></div>
                </div>
            </div>
            
            <button id="gameModeToggleBtn">Switch to Survival</button>
        </div>
        <div id="picked-up-item"></div> 
    </div>

    
    <div id="fake-cursor"></div> <div id="ui"></div>
    <div id="fps"></div>
    <div id="crosshair"></div>
    <div id="health-container"></div>
    <div id="oxygen-container"></div>
    <div id="toolbar"></div>
    
    <div id="death-screen">
        <h1>YOU DIED</h1>
        <p>Score: <span id="death-score">0</span></p>
        <button id="death-respawn-btn">RESPAWN</button>
    </div>
    
    <div id="pause-menu">
        <div class="menu-view">
            <h2>GAME STOPPED</h2>
            <div class="menu-control" style="width: 300px;">
                <label for="settingsSeedInput">Current Seed:</label>
                <input type="number" id="settingsSeedInput" readonly>
            </div>
            <p id="current-world-name" style="font-size: 14px; color: #aaa; margin-top: 10px;"></p>
            
            <button id="main-menu-btn-pause" class="main-menu-btn" style="background: var(--main-action); width: 300px; margin-top: 20px;">
                CONTINUE GAME (ESC)
            </button>
            <button id="respawn-btn" class="main-menu-btn" style="background: #FF9800; width: 300px; margin-top: 10px;">
                RESPAWN
            </button>
            <button id="save-world-btn" class="main-menu-btn" style="background: #2196F3; width: 300px; margin-top: 10px;">
                SAVE WORLD
            </button>
            <button id="pause-settings-btn" class="main-menu-btn" style="background: var(--secondary-action); width: 300px; margin-top: 10px;">
                SETTINGS
            </button>
            <button id="exit-to-menu-btn" class="main-menu-btn" style="background: var(--warning-color); width: 300px; margin-top: 10px;">
                EXIT TO MAIN MENU
            </button>
        </div>
    </div>

    <div id="version-text">Alpha v1.6.0</div>

    <script>
        // ==================== SETTINGS VARIABLES (MUST BE DECLARED FIRST) ====================
        var renderDistance = 25;
        var mouseSensitivity = 1.0;
        var fieldOfView = 75;
        
        // Flag to track if we opened settings from pause menu
        var openedSettingsFromPause = false;
        
        // ==================== LOCALSTORAGE SAVE/LOAD SYSTEM ====================
        
        // Save settings to localStorage
        function saveSettings() {
            const settings = {
                renderDistance: renderDistance,
                mouseSensitivity: mouseSensitivity,
                fieldOfView: fieldOfView
            };
            localStorage.setItem('minecraftSettings', JSON.stringify(settings));
        }
        
        // Load settings from localStorage
        function loadSettings() {
            const savedSettings = localStorage.getItem('minecraftSettings');
            if (savedSettings) {
                try {
                    const settings = JSON.parse(savedSettings);
                    renderDistance = settings.renderDistance || 25;
                    mouseSensitivity = settings.mouseSensitivity || 1.0;
                    fieldOfView = settings.fieldOfView || 75;
                    
                    // Update camera FOV
                    if (camera) {
                        camera.fov = fieldOfView;
                        camera.updateProjectionMatrix();
                    }
                } catch (e) {
                    console.error('Failed to load settings:', e);
                }
            }
        }
        
        // Save world data to localStorage
        function saveWorld(worldName) {
            if (!worldName) {
                worldName = 'World_' + WORLD_SEED + '_' + Date.now();
            }
            
            // Convert world object to serializable format
            const worldData = {};
            for (let k in world) {
                worldData[k] = world[k].userData.blockType;
            }
            
            const saveData = {
                name: worldName,
                seed: WORLD_SEED,
                worldSize: ws,
                isFlatWorld: isFlatWorld,
                worldData: worldData,
                playerPosition: { px, py, pz, rx, ry },
                inventory: inventoryData,
                isCreativeMode: isCreativeMode,
                dayTime: dayTime,
                savedAt: new Date().toISOString()
            };
            
            // Get existing saves
            const saves = JSON.parse(localStorage.getItem('minecraftSaves') || '{}');
            saves[worldName] = saveData;
            localStorage.setItem('minecraftSaves', JSON.stringify(saves));
            
            console.log('World saved:', worldName);
            return worldName;
        }
        
        // Load world data from localStorage
        function loadWorld(worldName) {
            const saves = JSON.parse(localStorage.getItem('minecraftSaves') || '{}');
            const saveData = saves[worldName];
            
            if (!saveData) {
                console.error('World not found:', worldName);
                return false;
            }
            
            // Clear existing world
            for(var k in world) { 
                scene.remove(world[k]); 
            }
            world = {};
            
            // Restore world settings
            WORLD_SEED = saveData.seed;
            ws = saveData.worldSize;
            isFlatWorld = saveData.isFlatWorld || false;
            isCreativeMode = saveData.isCreativeMode || false;
            dayTime = saveData.dayTime || 0;
            
            // Restore world blocks
            for (let k in saveData.worldData) {
                const [x, y, z] = k.split(',').map(Number);
                add(x, y, z, saveData.worldData[k]);
            }
            
            // Restore player position
            if (saveData.playerPosition) {
                px = saveData.playerPosition.px;
                py = saveData.playerPosition.py;
                pz = saveData.playerPosition.pz;
                rx = saveData.playerPosition.rx;
                ry = saveData.playerPosition.ry;
                camera.position.set(px, py, pz);
                camera.rotation.set(rx, ry, 0, 'YXZ');
            }
            
            // Restore inventory
            if (saveData.inventory) {
                inventoryData = saveData.inventory;
            }
            
            // Update UI
            updateGameModeButtonText();
            inventoryScreen.classList.toggle('creative-mode', isCreativeMode);
            updateInventoryUI();
            updateToolbarSelection();
            
            // Initialize game start time
            window.gameStartTime = Date.now();
            
            console.log('World loaded:', worldName);
            return true;
        }
        
        // Delete world from localStorage
        function deleteWorld(worldName) {
            const saves = JSON.parse(localStorage.getItem('minecraftSaves') || '{}');
            delete saves[worldName];
            localStorage.setItem('minecraftSaves', JSON.stringify(saves));
            console.log('World deleted:', worldName);
        }
        
        // Get list of saved worlds
        function getSavedWorlds() {
            const saves = JSON.parse(localStorage.getItem('minecraftSaves') || '{}');
            return Object.keys(saves).map(name => ({
                name: name,
                ...saves[name]
            }));
        }
        
        // Display saved worlds list
        function displaySavedWorlds() {
            const savedWorldsList = document.getElementById('saved-worlds-list');
            const worlds = getSavedWorlds();
            
            if (worlds.length === 0) {
                savedWorldsList.innerHTML = '<p style="color: #aaa; text-align: center; padding: 20px;">No saved worlds yet. Create a world to get started!</p>';
                return;
            }
            
            savedWorldsList.innerHTML = '';
            
            worlds.forEach(world => {
                const worldItem = document.createElement('div');
                worldItem.style.cssText = `
                    background: var(--menu-bg-accent);
                    padding: 15px;
                    margin-bottom: 10px;
                    border-radius: 8px;
                    border: 2px solid var(--inventory-border);
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                `;
                
                const worldInfo = document.createElement('div');
                const savedDate = new Date(world.savedAt);
                worldInfo.innerHTML = `
                    <div style="font-weight: bold; font-size: 16px; margin-bottom: 5px;">${world.name}</div>
                    <div style="font-size: 13px; color: #aaa;">
                        Seed: ${world.seed} | Size: ${world.worldSize} | Mode: ${world.isCreativeMode ? 'Creative' : 'Survival'}
                    </div>
                    <div style="font-size: 12px; color: #888; margin-top: 3px;">
                        Saved: ${savedDate.toLocaleDateString()} ${savedDate.toLocaleTimeString()}
                    </div>
                `;
                
                const buttonContainer = document.createElement('div');
                buttonContainer.style.cssText = 'display: flex; gap: 10px;';
                
                const loadBtn = document.createElement('button');
                loadBtn.textContent = 'LOAD';
                loadBtn.className = 'main-menu-btn';
                loadBtn.style.cssText = 'background: var(--main-action); padding: 10px 20px; font-size: 14px;';
                loadBtn.onclick = () => {
                    if (loadWorld(world.name)) {
                        generateInventorySlots();
                        updateToolbarSelection();
                        startAutoSave(world.name);
                        document.getElementById('main-menu').style.display = 'none';
                        
                        // Request pointer lock and show crosshair
                        requestLock(renderer.domElement);
                        document.getElementById('crosshair').style.display = 'block';
                        
                        locked = false;
                        paused = false;
                        if (!window.gameLoopStarted) {
                            loop();
                            window.gameLoopStarted = true;
                        }
                    }
                };
                
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'DELETE';
                deleteBtn.className = 'main-menu-btn';
                deleteBtn.style.cssText = 'background: var(--warning-color); padding: 10px 20px; font-size: 14px;';
                deleteBtn.onclick = () => {
                    if (confirm(`Are you sure you want to delete "${world.name}"?`)) {
                        deleteWorld(world.name);
                        displaySavedWorlds();
                    }
                };
                
                buttonContainer.appendChild(loadBtn);
                buttonContainer.appendChild(deleteBtn);
                
                worldItem.appendChild(worldInfo);
                worldItem.appendChild(buttonContainer);
                savedWorldsList.appendChild(worldItem);
            });
        }
        
        // Auto-save current world every 30 seconds
        let autoSaveInterval = null;
        let currentWorldName = null;
        
        function startAutoSave(worldName) {
            currentWorldName = worldName;
            if (autoSaveInterval) clearInterval(autoSaveInterval);
            
            autoSaveInterval = setInterval(() => {
                if (!paused && currentWorldName) {
                    saveWorld(currentWorldName);
                    console.log('Auto-saved world');
                }
            }, 30000); // Every 30 seconds
        }
        
        function stopAutoSave() {
            if (autoSaveInterval) {
                clearInterval(autoSaveInterval);
                autoSaveInterval = null;
            }
        }
        
        // ==================== END LOCALSTORAGE SYSTEM ====================

        // NEW: Cross-browser Pointer Lock Request function
        function requestLock(element) {
            (element.requestPointerLock ||
             element.mozRequestPointerLock ||
             element.webkitRequestPointerLock).call(element);
        }
        
        // --- GAME STATE ---
        let isCreativeMode = false; // MODIFIED: Survival is now default
        let isFlatWorld = false; // NEW: Flat world option

        // --- DAY/NIGHT CYCLE VARIABLES ---
        let dayTime = 0; // Time in seconds (0 to dayLength)
        const dayLength = 480; // 8 minutes for a full day cycle
        
        // --- INVENTORY CONSTANTS & DATA ---
        const MAIN_INV_WIDTH = 8;
        const MAIN_INV_HEIGHT = 3; // Rows 0, 1, 2
        const HUD_WIDTH = 8; 
        const HUD_Y = MAIN_INV_HEIGHT; // Row 3 is the HUD row
        
        const MAIN_SLOTS = MAIN_INV_WIDTH * MAIN_INV_HEIGHT; // 24
        const TOTAL_SLOTS = MAIN_SLOTS + HUD_WIDTH; // 32 slots total
        const MAX_STACK = 64;
        
        // MODIFIED: Initial Inventory Data is now empty
        let inventoryData = Array(TOTAL_SLOTS).fill(null);

        // Inventory state variables
        let cursorX = 0; 
        let cursorY = 0; 
        let pickedUpItem = null; // This is the movable part (data only)
        
        // NEW: Fake Cursor variables
        let fakeCursorX = window.innerWidth / 2;
        let fakeCursorY = window.innerHeight / 2;
        let fakeCursorElement = null; // Will be assigned after DOM loads
        
        // Element references
        const mainInventoryGrid = document.getElementById('main-inventory-grid');
        const hudInventoryGrid = document.getElementById('hud-inventory-grid');
        let pickedUpItemElement = null; // MODIFIED: Assigned later
        const gameModeToggleBtn = document.getElementById('gameModeToggleBtn');
        const creativeBlockPicker = document.getElementById('creative-block-picker');
        
        // --- SEED HANDLING VAR ---
        var WORLD_SEED; 

        var toolbar = document.getElementById('toolbar');
        
        // MODIFIED: Added 'LEAVES', 'GLASS', 'DOOR', and 'TORCH'
        var blockNames = ['GRASS', 'DIRT', 'STONE', 'WOOD', 'SAND', 'BEDROCK', 'LEAVES', 'GLASS', 'DOOR', 'TORCH', 'WATER', 'LAVA']; 
        var numBlocks = blockNames.length;
        var btns = [];
        
        // --- BLOCK TYPE CONSTANTS ---
        const SAND_TYPE = 4;
        const BEDROCK_TYPE = 5;
        const WOOD_TYPE = 3; 
        const LEAVES_TYPE = 6;
        const GLASS_TYPE = 7;
        const DOOR_TYPE = 8;
        const TORCH_TYPE = 9;
        const WATER_TYPE = 10;
        const LAVA_TYPE = 11;
        // Check every 100ms for gravity effect
        const SAND_FALL_CHECK_INTERVAL = 0.1; 
        let sandFallTimer = 0;
        // -------------------------------

        // --- NEW GRASS SPREAD CONSTANTS ---
        const GRASS_TYPE = 0;   // Grass is block type 0
        const DIRT_TYPE = 1;    // Dirt is block type 1
        const GRASS_SPREAD_CHECK_INTERVAL = 1.0; // Check for growth every 1 second
        let grassSpreadTimer = 0;
        // Max time in seconds (1 to 5 minutes -> aiming for 5 minutes max average, 300 seconds)
        // Chance is 1 / 300 checks in the current setup (1 check per second)
        const GRASS_SPREAD_CHANCE_MAX_SECONDS = 3; 
        // ----------------------------------
        
        // --- UTILITY FUNCTIONS ---
        function getBlockDisplay(type) {
            return blockNames[type] ? { name: blockNames[type], color: '#fff' } : { name: '?', color: 'red' };
        }
        
        // Maps X, Y (0-7, 0-2) to the main inventory array index (0-23)
        function getMainSlotIndex(x, y) {
            return y * MAIN_INV_WIDTH + x;
        }

        // Maps HUD selection (0-7) to the inventoryData array index (24-31)
        function getHUDIndex(hudSlot) {
            return MAIN_SLOTS + hudSlot;
        }

        // Gets the universal index (0-31) based on cursor position
        function getSlotIndexFromCursor() {
            if (cursorY < MAIN_INV_HEIGHT) {
                return getMainSlotIndex(cursorX, cursorY);
            } else {
                return getHUDIndex(cursorX);
            }
        }
        
        // MODIFIED: Block collection now prioritizes HUD slots (24-31) over Main Inventory slots (0-23).
        function addToInventory(type, count = 1) {
            // In creative mode, we don't need to add destroyed blocks
            if (isCreativeMode) return; 
            
            let remaining = count;
            
            // Helper function to iterate over a range of slots
            const trySlots = (start, end, action) => {
                for (let i = start; i < end; i++) {
                    if (remaining === 0) return;
                    action(i);
                }
            };
            
            // 1. Try to stack with existing items
            
            // 1a. Prioritize HUD slots (24 to 31)
            trySlots(MAIN_SLOTS, TOTAL_SLOTS, (i) => {
                const item = inventoryData[i];
                if (item && item.type === type && item.count < MAX_STACK) {
                    const space = MAX_STACK - item.count;
                    const transfer = Math.min(remaining, space);
                    item.count += transfer;
                    remaining -= transfer;
                }
            });
            
            // 1b. Then Main inventory slots (0 to 23)
            trySlots(0, MAIN_SLOTS, (i) => {
                const item = inventoryData[i];
                if (item && item.type === type && item.count < MAX_STACK) {
                    const space = MAX_STACK - item.count;
                    const transfer = Math.min(remaining, space);
                    item.count += transfer;
                    remaining -= transfer;
                }
            });
            
            // 2. Place remaining items in empty slots
            if (remaining > 0) {
                
                // 2a. Prioritize empty HUD slots (24 to 31)
                trySlots(MAIN_SLOTS, TOTAL_SLOTS, (i) => {
                    if (!inventoryData[i]) {
                        const transfer = Math.min(remaining, MAX_STACK);
                        inventoryData[i] = { type: type, count: transfer };
                        remaining -= transfer;
                    }
                });

                // 2b. Then empty Main inventory slots (0 to 23)
                trySlots(0, MAIN_SLOTS, (i) => {
                    if (!inventoryData[i]) {
                        const transfer = Math.min(remaining, MAX_STACK);
                        inventoryData[i] = { type: type, count: transfer };
                        remaining -= transfer;
                    }
                });
            }
            
            updateInventoryUI();
            updateToolbarSelection(); 
        }
        
        // Find block in inventory and return slot info
        function findBlockInInventory(blockType) {
            // First check hotbar (24-31)
            for (let i = MAIN_SLOTS; i < TOTAL_SLOTS; i++) {
                const item = inventoryData[i];
                if (item && item.type === blockType) {
                    return { found: true, slotIndex: i, isHotbar: true, hotbarSlot: i - MAIN_SLOTS };
                }
            }
            
            // Then check main inventory (0-23)
            for (let i = 0; i < MAIN_SLOTS; i++) {
                const item = inventoryData[i];
                if (item && item.type === blockType) {
                    return { found: true, slotIndex: i, isHotbar: false };
                }
            }
            
            return { found: false };
        }
        
        // Middle-click block picker
        function handleMiddleClickBlockPick(blockType) {
            const result = findBlockInInventory(blockType);
            
            if (result.found) {
                if (result.isHotbar) {
                    // Block is in hotbar, just switch to it
                    sel = result.hotbarSlot;
                    updateToolbarSelection();
                } else {
                    // Block is in main inventory, move to current hotbar slot
                    const currentHotbarIndex = getHUDIndex(sel);
                    const item = inventoryData[result.slotIndex];
                    
                    if (isCreativeMode) {
                        // In creative, just place it in hotbar (max stack)
                        inventoryData[currentHotbarIndex] = { type: blockType, count: 64 };
                    } else {
                        // In survival, swap or move the item
                        inventoryData[currentHotbarIndex] = item;
                        inventoryData[result.slotIndex] = null;
                    }
                    
                    updateInventoryUI();
                    updateToolbarSelection();
                }
            } else {
                // Block not found in inventory
                if (isCreativeMode) {
                    // In creative, add it to current hotbar slot
                    const currentHotbarIndex = getHUDIndex(sel);
                    inventoryData[currentHotbarIndex] = { type: blockType, count: 64 };
                    updateInventoryUI();
                    updateToolbarSelection();
                }
                // In survival, do nothing if block not found
            }
        }
        
        /**
         * Generates a simple tree structure.
         */
        function generateTree(startX, startY, startZ) {
            // Simple tree parameters
            const trunkHeight = Math.floor(Math.random() * 3) + 4; // 4 to 6 tall trunk
            
            // 1. Create Trunk (WOOD_TYPE = 3)
            for (let y = 0; y < trunkHeight; y++) {
                add(startX, startY + y, startZ, WOOD_TYPE);
            }
            
            // 2. Create Leaves Canopy (LEAVES_TYPE = 6)
            const leavesBaseY = startY + trunkHeight - 2; // Start leaves 2 blocks down from the top of the trunk
            
            // Layer 1 and 2 (bottom layers, 5x5-ish)
            for (let ly = 0; ly < 2; ly++) {
                for (let lx = -2; lx <= 2; lx++) {
                    for (let lz = -2; lz <= 2; lz++) {
                        // Skip corners for a diamond/rounded shape
                        if ((Math.abs(lx) === 2 && Math.abs(lz) === 2)) continue; 
                        
                        add(startX + lx, leavesBaseY + ly, startZ + lz, LEAVES_TYPE);
                    }
                }
            }

            // Layer 3 and 4 (top layers, 3x3)
            for (let ly = 2; ly < 4; ly++) {
                for (let lx = -1; lx <= 1; lx++) {
                    for (let lz = -1; lz <= 1; lz++) {
                        add(startX + lx, leavesBaseY + ly, startZ + lz, LEAVES_TYPE);
                    }
                }
            }
        }


        // --- INVENTORY UI & NAVIGATION ---
        
        function moveCursor(dx, dy) {
            // Navigable area is 8x4 (3 main rows + 1 HUD row)
            const MAX_Y = MAIN_INV_HEIGHT; // 3
            
            cursorX = Math.max(0, Math.min(MAIN_INV_WIDTH - 1, cursorX + dx));
            cursorY = Math.max(0, Math.min(MAX_Y, cursorY + dy)); 

            updateInventoryUI();
        }

        function updateToolbarSelection() {
            // Loop for the 8 HUD buttons
            btns.forEach((b, index) => {
                const hudIndex = getHUDIndex(index);
                const item = inventoryData[hudIndex];

                // 1. Update Visuals (sel is 0-7)
                b.classList.toggle('selected', index === sel);
                
                // 2. Update Content
                if (item) {
                    const display = getBlockDisplay(item.type);
                    const countDisplay = isCreativeMode ? 'â' : item.count; // Mode-dependent count
                    b.innerHTML = `
                        <span class="slot-item" style="color:${display.color}">${display.name}</span>
                        <span class="slot-count">${countDisplay}</span>
                    `;
                } else {
                     b.innerHTML = `<span style="font-size: 14px; opacity: 0.5;">${index + 1}</span>`;
                }
            });

            // 3. Update the global block placement variable (Active Block Type)
            const activeItem = inventoryData[getHUDIndex(sel)];
            window.activeBlockType = activeItem ? activeItem.type : null;
        }

        function updateInventoryUI() {
            const mainSlots = mainInventoryGrid.querySelectorAll('.inventory-slot');
            const hudSlots = hudInventoryGrid.querySelectorAll('.inventory-slot');
            const currentCursorSlotIndex = getSlotIndexFromCursor(); // Get the 0-31 index of the slot under the cursor
            
            // 1. Update all slot contents and clear selection/red classes
            const allSlots = [...mainSlots, ...hudSlots];
            allSlots.forEach((slot, index) => {
                let item = inventoryData[index]; // Item data from inventory array
                
                slot.innerHTML = '';
                slot.classList.remove('slot-selected');
                
                if (item) {
                    const display = getBlockDisplay(item.type);
                    const countDisplay = isCreativeMode ? 'â' : item.count; // Mode-dependent count
                    slot.innerHTML = `
                        <span class="slot-item" style="color:${display.color}">${display.name}</span>
                        <span class="slot-count">${countDisplay}</span>
                    `;
                }
            });

            // 2. NEW: Update the picked-up item element
            if (pickedUpItem) {
                const display = getBlockDisplay(pickedUpItem.type);
                const countDisplay = isCreativeMode ? 'â' : pickedUpItem.count;
                pickedUpItemElement.innerHTML = `
                    <span class="slot-item" style="color:${display.color}">${display.name}</span>
                    <span class="slot-count">${countDisplay}</span>
                `;
                pickedUpItemElement.style.display = 'flex';
            } else {
                pickedUpItemElement.style.display = 'none';
                pickedUpItemElement.innerHTML = '';
            }
        }
        
        // NEW: Generate the creative block picker
        function generateBlockPicker() {
            creativeBlockPicker.innerHTML = '';
            blockNames.forEach((name, type) => {
                const slot = document.createElement('div');
                slot.classList.add('inventory-slot');
                slot.dataset.type = type;

                const display = getBlockDisplay(type);
                slot.innerHTML = `
                    <span class="slot-item" style="color:${display.color}">${display.name}</span>
                    <span class="slot-count">â</span>
                `;
                
                creativeBlockPicker.appendChild(slot);
            });
        }
        
        function generateInventorySlots() {
            mainInventoryGrid.innerHTML = '';
            hudInventoryGrid.innerHTML = '';
            
            let slotIndexCounter = 0;

            // Generate Main Inventory Slots (8x3)
            for (let y = 0; y < MAIN_INV_HEIGHT; y++) {
                for (let x = 0; x < MAIN_INV_WIDTH; x++) {
                    const slot = document.createElement('div');
                    slot.classList.add('inventory-slot');
                    
                    slot.dataset.x = x;
                    slot.dataset.y = y;
                    slot.dataset.index = slotIndexCounter;
                    
                    mainInventoryGrid.appendChild(slot);
                    slotIndexCounter++;
                }
            }
            
            // Generate HUD Inventory Slots (8 slots)
            for (let i = 0; i < HUD_WIDTH; i++) {
                const slot = document.createElement('div');
                slot.classList.add('inventory-slot', 'hud-slot');
                
                slot.dataset.x = i; 
                slot.dataset.y = HUD_Y; 
                slot.dataset.index = slotIndexCounter; 

                hudInventoryGrid.appendChild(slot);
                slotIndexCounter++;
            }

            updateInventoryUI();
            generateBlockPicker(); // Also generate the creative picker
        }

        
        function swapItems(slotIndex) {
             let slotItem = inventoryData[slotIndex];
             
             // --- REFACTORED: Creative and Survival inventory moving is identical ---
             // This logic *moves* items, it does not copy.
             if (pickedUpItem) {
                // SECOND CLICK/SPACE: Placing/Stacking
                if (slotItem && pickedUpItem.type === slotItem.type && slotItem.count < MAX_STACK && !isCreativeMode) { // Stack only in survival
                    // Stack items
                    const space = MAX_STACK - slotItem.count;
                    const transfer = Math.min(pickedUpItem.count, space);
                    slotItem.count += transfer;
                    pickedUpItem.count -= transfer;

                    if (pickedUpItem.count === 0) {
                        pickedUpItem = null;
                    }
                } else {
                    // Standard Swap
                    const tempItem = pickedUpItem;
                    pickedUpItem = slotItem;
                    inventoryData[slotIndex] = tempItem;
                }

             } else {
                 // FIRST CLICK/SPACE: Picking up
                 if (slotItem) {
                     pickedUpItem = slotItem;
                     inventoryData[slotIndex] = null; // Item is now only in the pickedUpItem container
                 }
             }
             
             updateInventoryUI();
             updateToolbarSelection(); 
        }

        // --- NEW: Right-click handling function ---
        function handleInventoryRightClick(slotIndex) {
            if (isCreativeMode) {
                // Creative right-click: Same as left-click (pick up stack)
                swapItems(slotIndex);
            } else {
                // --- Survival Right-Click Logic (Split/Place One) ---
                let slotItem = inventoryData[slotIndex];
                
                if (pickedUpItem) {
                    // Placing one item down
                    if (!slotItem) {
                        // Place one in empty slot
                        inventoryData[slotIndex] = { type: pickedUpItem.type, count: 1 };
                        pickedUpItem.count--;
                    } else if (slotItem.type === pickedUpItem.type && slotItem.count < MAX_STACK) {
                        // Stack one
                        slotItem.count++;
                        pickedUpItem.count--;
                    }
                    if (pickedUpItem.count === 0) pickedUpItem = null;
                    
                } else if (slotItem) {
                    // Picking up half stack
                    const half = Math.ceil(slotItem.count / 2);
                    pickedUpItem = { type: slotItem.type, count: half };
                    slotItem.count -= half;
                    if (slotItem.count === 0) inventoryData[slotIndex] = null;
                }
                updateInventoryUI();
                updateToolbarSelection();
            }
        }
        
        // --- REFACTORED: Mouse Up listener ---
        document.addEventListener('mouseup', function(e) {
            if (!inventoryOpen || !pickedUpItem) return;

            // Get element under fake cursor
            fakeCursorElement.style.display = 'none';
            let elementUnderCursor = document.elementFromPoint(fakeCursorX, fakeCursorY);
            fakeCursorElement.style.display = 'block';
            
            // Check if mouse is outside all valid drop zones
            const targetInv = elementUnderCursor ? elementUnderCursor.closest('.inventory-container') : null;
            const targetPicker = elementUnderCursor ? elementUnderCursor.closest('#creative-block-picker') : null;
            const targetDelete = elementUnderCursor ? elementUnderCursor.closest('#delete-slot') : null;
            
            if (!targetInv && !targetPicker && !targetDelete) { // MODIFIED
                // Dropped item outside inventory
                if (!isCreativeMode) {
                    // In survival, add it back
                    addToInventory(pickedUpItem.type, pickedUpItem.count);
                }
                // In creative or survival, the item is dropped from cursor
                pickedUpItem = null; 
                updateInventoryUI();
                updateToolbarSelection();
            }
        });


        // --- Three.js & World Logic ---
        
        // Generate the 8 HUD buttons
        for (var bi = 0; bi < HUD_WIDTH; bi++) {
            var btn = document.createElement('button');
            btn.id = 'btn' + bi;
            btn.dataset.hudSlot = bi;
            toolbar.appendChild(btn);
            btns.push(btn);
        }

        var c = document.getElementById('c');
        var scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 50, 200);

        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        // Load settings from localStorage on page load
        loadSettings();
        
        var renderer = new THREE.WebGLRenderer({ canvas: c, antialias: false }); // Disabled antialiasing for blocky look
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.BasicShadowMap; // Blocky shadows like Minecraft
        document.body.appendChild(renderer.domElement);
        
        // NEW: Assign fakeCursorElement now that DOM is ready
        fakeCursorElement = document.getElementById('fake-cursor');
        pickedUpItemElement = document.getElementById('picked-up-item'); // MODIFIED: Assigned here

        // --- Lights and Materials (Optimized for performance) ---
        var aLight = new THREE.AmbientLight(0xffffff, 0.5); // Slightly brighter ambient
        scene.add(aLight);
        var dLight = new THREE.DirectionalLight(0xffffff, 0.6); // Brighter directional
        dLight.position.set(50, 100, 50);
        dLight.castShadow = true;
        // Optimized shadow settings - only directional light casts shadows for performance
        dLight.shadow.mapSize.width = 1024; // Improved shadow quality
        dLight.shadow.mapSize.height = 1024;
        dLight.shadow.camera.near = 0.5;
        dLight.shadow.camera.far = 500;
        dLight.shadow.camera.left = -50;
        dLight.shadow.camera.right = 50;
        dLight.shadow.camera.top = 50;
        dLight.shadow.camera.bottom = -50;
        scene.add(dLight);
        
        // --- SUN AND MOON CUBES ---
        const celestialDistance = 150; // Distance from center
        const sunGeometry = new THREE.BoxGeometry(8, 8, 8);
        const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 }); // Yellow
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        scene.add(sun);
        
        const moonGeometry = new THREE.BoxGeometry(6, 6, 6);
        const moonMaterial = new THREE.MeshBasicMaterial({ color: 0xcccccc }); // Light gray
        const moon = new THREE.Mesh(moonGeometry, moonMaterial);
        scene.add(moon);
        
        // --- ENHANCED SOUND SYSTEM WITH BLOCK-SPECIFIC SOUNDS ---
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // Sound profiles for each block type
        const blockSounds = {
            0: { // GRASS
                break: { duration: 0.15, freq: 800, volume: 0.25, noise: 'brown' },
                place: { duration: 0.12, freq: 600, volume: 0.2, noise: 'brown' },
                step: { duration: 0.08, freq: 400, volume: 0.12, noise: 'brown', highFreq: 1200 }
            },
            1: { // DIRT
                break: { duration: 0.15, freq: 700, volume: 0.25, noise: 'brown' },
                place: { duration: 0.12, freq: 550, volume: 0.2, noise: 'brown' },
                step: { duration: 0.08, freq: 380, volume: 0.12, noise: 'brown', highFreq: 1100 }
            },
            2: { // STONE
                break: { duration: 0.2, freq: 600, volume: 0.3, noise: 'white' },
                place: { duration: 0.15, freq: 450, volume: 0.25, noise: 'white' },
                step: { duration: 0.06, freq: 200, volume: 0.15, noise: 'white', highFreq: 2000 }
            },
            3: { // WOOD
                break: { duration: 0.18, freq: 500, volume: 0.28, noise: 'brown' },
                place: { duration: 0.14, freq: 400, volume: 0.22, noise: 'brown' },
                step: { duration: 0.09, freq: 350, volume: 0.13, noise: 'brown', highFreq: 900 }
            },
            4: { // SAND
                break: { duration: 0.12, freq: 900, volume: 0.22, noise: 'white' },
                place: { duration: 0.1, freq: 700, volume: 0.18, noise: 'white' },
                step: { duration: 0.07, freq: 500, volume: 0.1, noise: 'white', highFreq: 1500 }
            },
            5: { // BEDROCK
                break: { duration: 0.25, freq: 400, volume: 0.35, noise: 'white' },
                place: { duration: 0.2, freq: 300, volume: 0.3, noise: 'white' },
                step: { duration: 0.05, freq: 150, volume: 0.16, noise: 'white', highFreq: 2200 }
            },
            6: { // LEAVES
                break: { duration: 0.1, freq: 1200, volume: 0.2, noise: 'white' },
                place: { duration: 0.08, freq: 1000, volume: 0.15, noise: 'white' },
                step: { duration: 0.09, freq: 800, volume: 0.08, noise: 'white', highFreq: 1800 }
            },
            7: { // GLASS
                break: { duration: 0.15, freq: 2000, volume: 0.3, noise: 'white' },
                place: { duration: 0.12, freq: 1500, volume: 0.25, noise: 'white' },
                step: { duration: 0.06, freq: 1000, volume: 0.1, noise: 'white', highFreq: 2500 }
            },
            8: { // DOOR (use wood sounds)
                break: { duration: 0.18, freq: 500, volume: 0.28, noise: 'brown' },
                place: { duration: 0.14, freq: 400, volume: 0.22, noise: 'brown' },
                step: { duration: 0.09, freq: 350, volume: 0.13, noise: 'brown', highFreq: 900 }
            },
            9: { // TORCH (light crackling sound)
                break: { duration: 0.1, freq: 1500, volume: 0.2, noise: 'white' },
                place: { duration: 0.08, freq: 1200, volume: 0.18, noise: 'white' },
                step: { duration: 0.05, freq: 800, volume: 0.08, noise: 'white', highFreq: 1600 }
            },
            10: { // WATER (splash/flowing sound)
                break: { duration: 0.15, freq: 600, volume: 0.25, noise: 'white' },
                place: { duration: 0.12, freq: 500, volume: 0.2, noise: 'white' },
                step: { duration: 0.08, freq: 400, volume: 0.12, noise: 'white', highFreq: 1000 }
            },
            11: { // LAVA (bubbling/crackling sound)
                break: { duration: 0.2, freq: 300, volume: 0.3, noise: 'brown' },
                place: { duration: 0.15, freq: 250, volume: 0.25, noise: 'brown' },
                step: { duration: 0.1, freq: 200, volume: 0.15, noise: 'brown', highFreq: 600 }
            }
        };
        
        // Create realistic noise-based sounds like Minecraft
        function createNoiseBuffer(duration, type = 'white') {
            const sampleRate = audioContext.sampleRate;
            const length = sampleRate * duration;
            const buffer = audioContext.createBuffer(1, length, sampleRate);
            const data = buffer.getChannelData(0);
            
            if (type === 'white') {
                // White noise for realistic stone/sand/leaves sounds
                for (let i = 0; i < length; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
            } else if (type === 'brown') {
                // Brown noise for deeper, earthier sounds (dirt, grass, wood)
                let lastOut = 0;
                for (let i = 0; i < length; i++) {
                    const white = Math.random() * 2 - 1;
                    data[i] = (lastOut + (0.02 * white)) / 1.02;
                    lastOut = data[i];
                    data[i] *= 3.5;
                }
            }
            return buffer;
        }
        
        function playRealisticSound(duration, filterFreq, volume = 0.2, noiseType = 'white') {
            const source = audioContext.createBufferSource();
            source.buffer = createNoiseBuffer(duration, noiseType);
            
            // Apply low-pass filter for more natural sound
            const filter = audioContext.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(filterFreq, audioContext.currentTime);
            
            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            
            source.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            source.start(audioContext.currentTime);
        }
        
        function playBreakSound(blockType = 0) {
            const sound = blockSounds[blockType] || blockSounds[0];
            const s = sound.break;
            
            // Main break sound
            playRealisticSound(s.duration, s.freq + Math.random() * 400, s.volume, s.noise);
            
            // Secondary crack sound for emphasis
            setTimeout(() => {
                playRealisticSound(s.duration * 0.5, s.freq * 0.7 + Math.random() * 300, s.volume * 0.6, s.noise);
            }, 30);
        }
        
        function playPlaceSound(blockType = 0) {
            const sound = blockSounds[blockType] || blockSounds[0];
            const s = sound.place;
            
            // Main place sound
            playRealisticSound(s.duration, s.freq + Math.random() * 200, s.volume, s.noise);
            
            // Secondary settling sound
            setTimeout(() => {
                playRealisticSound(s.duration * 0.5, s.freq * 0.7 + Math.random() * 150, s.volume * 0.6, s.noise);
            }, 40);
        }
        
        function playStepSound(blockType = 0) {
            const sound = blockSounds[blockType] || blockSounds[0];
            const s = sound.step;
            const variation = Math.random() * 200;
            
            // Main footstep sound
            playRealisticSound(s.duration, s.freq + variation, s.volume, s.noise);
            
            // High-frequency texture (grass rustling, stone scraping, etc.)
            if (s.highFreq) {
                setTimeout(() => {
                    playRealisticSound(s.duration * 0.5, s.highFreq + variation, s.volume * 0.6, 'white');
                }, 15);
            }
        }
        
        function playJumpSound(blockType = 0) {
            const sound = blockSounds[blockType] || blockSounds[0];
            const s = sound.step;
            
            // Jump uses a slightly modified step sound
            playRealisticSound(s.duration * 1.2, s.freq * 1.2 + Math.random() * 300, s.volume * 1.2, s.noise);
        }
        
        // Helper function to get block type player is standing on
        function getBlockUnderPlayer() {
            const feetY = py - EYE_HEIGHT;
            const blockX = Math.round(px / bs);
            const blockY = Math.round(feetY / bs) - 1; // Block directly under feet
            const blockZ = Math.round(pz / bs);
            
            const blockKey = key(blockX, blockY, blockZ);
            const block = world[blockKey];
            
            return block ? block.userData.blockType : 0; // Default to grass sound
        }
        
        // Walking sound state
        let stepTimer = 0;
        const stepInterval = 0.4; // Time between steps in seconds
        let wasMoving = false;

        // --- PIXEL TEXTURE GENERATION ---
        function createPixelTexture(baseColor, pattern) {
            const canvas = document.createElement('canvas');
            canvas.width = 16;
            canvas.height = 16;
            const ctx = canvas.getContext('2d');
            
            // Fill base color
            ctx.fillStyle = baseColor;
            ctx.fillRect(0, 0, 16, 16);
            
            // Apply pattern
            pattern.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, p.w || 1, p.h || 1);
            });
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            texture.needsUpdate = true;
            return texture;
        }
        
        // Dirt Texture Pattern (brown with darker spots)
        const dirtPattern = [
            { x: 2, y: 1, color: '#5a3419' }, { x: 5, y: 2, color: '#5a3419' }, { x: 9, y: 3, color: '#5a3419' },
            { x: 12, y: 5, color: '#7a5030' }, { x: 3, y: 7, color: '#5a3419' }, { x: 8, y: 8, color: '#7a5030' },
            { x: 14, y: 9, color: '#5a3419' }, { x: 1, y: 11, color: '#7a5030' }, { x: 6, y: 12, color: '#5a3419' },
            { x: 11, y: 13, color: '#7a5030' }, { x: 4, y: 14, color: '#5a3419' }
        ];
        
        // Grass Top Texture Pattern (green with varied shades)
        const grassPattern = [
            { x: 1, y: 0, color: '#4a7a2e' }, { x: 4, y: 1, color: '#6a9c4e' }, { x: 7, y: 1, color: '#4a7a2e' },
            { x: 10, y: 2, color: '#6a9c4e' }, { x: 2, y: 3, color: '#4a7a2e' }, { x: 13, y: 4, color: '#6a9c4e' },
            { x: 5, y: 5, color: '#4a7a2e' }, { x: 8, y: 6, color: '#6a9c4e' }, { x: 11, y: 7, color: '#4a7a2e' },
            { x: 3, y: 9, color: '#6a9c4e' }, { x: 14, y: 10, color: '#4a7a2e' }, { x: 6, y: 11, color: '#6a9c4e' },
            { x: 9, y: 12, color: '#4a7a2e' }, { x: 1, y: 14, color: '#6a9c4e' }
        ];
        
        // Stone Texture Pattern (gray with darker cracks)
        const stonePattern = [
            { x: 3, y: 2, w: 2, color: '#606060' }, { x: 8, y: 1, color: '#909090' }, { x: 12, y: 3, color: '#606060' },
            { x: 1, y: 5, color: '#909090' }, { x: 6, y: 6, w: 2, color: '#606060' }, { x: 14, y: 7, color: '#909090' },
            { x: 4, y: 9, color: '#606060' }, { x: 10, y: 10, w: 2, color: '#909090' }, { x: 2, y: 12, color: '#606060' },
            { x: 13, y: 13, color: '#909090' }, { x: 7, y: 14, color: '#606060' }
        ];
        
        // Wood Texture Pattern (brown with vertical grain lines)
        const woodPattern = [
            { x: 3, y: 0, h: 16, color: '#734a1a' }, { x: 8, y: 0, h: 16, color: '#9b6a3b' },
            { x: 12, y: 0, h: 16, color: '#734a1a' }, { x: 6, y: 4, w: 2, h: 1, color: '#6b421a' },
            { x: 10, y: 8, w: 2, h: 1, color: '#6b421a' }, { x: 5, y: 12, w: 2, h: 1, color: '#6b421a' }
        ];
        
        // Create textured materials
        var mats = [];
        var dirtTexture = createPixelTexture('#6b4423', dirtPattern);
        var grassTexture = createPixelTexture('#5a8c3e', grassPattern);
        var stoneTexture = createPixelTexture('#7a7a7a', stonePattern);
        var woodTexture = createPixelTexture('#8b5a2b', woodPattern);
        var sandTexture = createPixelTexture('#ddc28f', [
            { x: 2, y: 2, color: '#eed29f' }, { x: 6, y: 3, color: '#ccb07f' }, { x: 10, y: 5, color: '#eed29f' },
            { x: 13, y: 7, color: '#ccb07f' }, { x: 4, y: 9, color: '#eed29f' }, { x: 8, y: 11, color: '#ccb07f' }
        ]);
        var bedrockTexture = createPixelTexture('#222222', [
            { x: 1, y: 1, color: '#333333' }, { x: 5, y: 2, color: '#111111' }, { x: 9, y: 4, color: '#333333' },
            { x: 12, y: 6, color: '#111111' }, { x: 3, y: 8, color: '#333333' }, { x: 14, y: 11, color: '#111111' }
        ]);
        
        // Leaves Texture Pattern (green with darker spots)
        var leavesTexture = createPixelTexture('#38761d', [
            { x: 1, y: 1, color: '#2a5a15' }, { x: 4, y: 2, color: '#468c25' }, { x: 7, y: 1, color: '#2a5a15' },
            { x: 10, y: 3, color: '#468c25' }, { x: 2, y: 5, color: '#2a5a15' }, { x: 13, y: 4, color: '#468c25' },
            { x: 5, y: 7, color: '#2a5a15' }, { x: 9, y: 8, color: '#468c25' }, { x: 12, y: 9, color: '#2a5a15' },
            { x: 3, y: 11, color: '#468c25' }, { x: 14, y: 12, color: '#2a5a15' }, { x: 6, y: 13, color: '#468c25' },
            { x: 8, y: 14, color: '#2a5a15' }, { x: 11, y: 15, color: '#468c25' }
        ]);
        
        var matDirt = new THREE.MeshLambertMaterial({ map: dirtTexture });
        var matGrassTop = new THREE.MeshLambertMaterial({ map: grassTexture });
        var matStone = new THREE.MeshLambertMaterial({ map: stoneTexture });
        var matWood = new THREE.MeshLambertMaterial({ map: woodTexture });
        var matSand = new THREE.MeshLambertMaterial({ map: sandTexture });
        var matBedrock = new THREE.MeshLambertMaterial({ map: bedrockTexture }); 
        
        // NEW LEAVES MATERIAL with texture and transparency
        var matLeaves = new THREE.MeshLambertMaterial({ map: leavesTexture, transparent: true, opacity: 0.85 });
        
        // Glass Texture Pattern (light blue/white with frame only - more transparent)
        var glassTexture = createPixelTexture('rgba(200, 230, 255, 0.2)', [
            // White frame around edges only
            { x: 0, y: 0, w: 16, h: 1, color: '#ffffff' },  // Top
            { x: 0, y: 15, w: 16, h: 1, color: '#ffffff' }, // Bottom
            { x: 0, y: 0, w: 1, h: 16, color: '#ffffff' },  // Left
            { x: 15, y: 0, w: 1, h: 16, color: '#ffffff' }  // Right
            // Cross pattern removed for better transparency
        ]);
        var matGlass = new THREE.MeshLambertMaterial({ 
            map: glassTexture, 
            transparent: true, 
            opacity: 0.4,
            side: THREE.DoubleSide
        });
        
        // Door Texture Pattern (wooden door with planks)
        var doorTexture = createPixelTexture('#8b5a2b', [
            { x: 0, y: 0, w: 16, h: 1, color: '#6b4a1b' },  // Top edge
            { x: 0, y: 15, w: 16, h: 1, color: '#6b4a1b' }, // Bottom edge
            { x: 0, y: 0, w: 1, h: 16, color: '#6b4a1b' },  // Left edge
            { x: 15, y: 0, w: 1, h: 16, color: '#6b4a1b' }, // Right edge
            // Horizontal planks
            { x: 2, y: 2, w: 12, h: 1, color: '#734a1a' },
            { x: 2, y: 5, w: 12, h: 1, color: '#734a1a' },
            { x: 2, y: 8, w: 12, h: 1, color: '#734a1a' },
            { x: 2, y: 11, w: 12, h: 1, color: '#734a1a' },
            { x: 2, y: 14, w: 12, h: 1, color: '#734a1a' },
            // Door handle
            { x: 12, y: 7, w: 2, h: 2, color: '#444444' }
        ]);
        var matDoor = new THREE.MeshLambertMaterial({ map: doorTexture });
        
        // Torch Texture Pattern (proper Minecraft torch look)
        var torchTexture = createPixelTexture('#000000', [
            // Dark wooden stick (bottom 7 pixels)
            { x: 7, y: 0, w: 2, h: 7, color: '#5c3c1f' },
            { x: 6, y: 1, w: 1, h: 5, color: '#4a2f19' },
            { x: 9, y: 1, w: 1, h: 5, color: '#6b4423' },
            // Flame base (pixels 8-10)
            { x: 6, y: 7, w: 4, h: 1, color: '#ff8800' },
            { x: 5, y: 8, w: 6, h: 1, color: '#ffaa00' },
            { x: 6, y: 9, w: 4, h: 1, color: '#ffdd00' },
            // Bright flame tip (pixels 11-12)
            { x: 6, y: 10, w: 4, h: 2, color: '#ffffaa' },
            { x: 7, y: 12, w: 2, h: 2, color: '#ffff88' }
        ]);
        var matTorch = new THREE.MeshLambertMaterial({ 
            map: torchTexture,
            emissive: 0xffaa00,
            emissiveIntensity: 0.5
        });
        
        // Water Texture Pattern (blue/cyan with subtle waves)
        var waterTexture = createPixelTexture('#3a5fcd', [
            { x: 1, y: 1, color: '#4a6fdd' }, { x: 4, y: 2, color: '#5a7fed' }, { x: 7, y: 1, color: '#4a6fdd' },
            { x: 10, y: 3, color: '#6a8ffd' }, { x: 2, y: 5, color: '#4a6fdd' }, { x: 13, y: 4, color: '#5a7fed' },
            { x: 5, y: 7, color: '#6a8ffd' }, { x: 9, y: 8, color: '#4a6fdd' }, { x: 12, y: 9, color: '#5a7fed' },
            { x: 3, y: 11, color: '#6a8ffd' }, { x: 14, y: 12, color: '#4a6fdd' }, { x: 6, y: 13, color: '#5a7fed' }
        ]);
        var matWater = new THREE.MeshLambertMaterial({ 
            map: waterTexture,
            transparent: true,
            opacity: 0.6,
            side: THREE.DoubleSide
        });
        
        // Lava Texture Pattern (orange/red with bright spots)
        var lavaTexture = createPixelTexture('#cc4400', [
            { x: 1, y: 1, color: '#ff6600' }, { x: 4, y: 2, color: '#ff8800' }, { x: 7, y: 1, color: '#dd5500' },
            { x: 10, y: 3, color: '#ffaa00' }, { x: 2, y: 5, color: '#dd5500' }, { x: 13, y: 4, color: '#ff6600' },
            { x: 5, y: 7, color: '#ff8800' }, { x: 9, y: 8, color: '#dd5500' }, { x: 12, y: 9, color: '#ffaa00' },
            { x: 3, y: 11, color: '#ff6600' }, { x: 14, y: 12, color: '#dd5500' }, { x: 6, y: 13, color: '#ff8800' },
            // Bright lava spots
            { x: 8, y: 5, color: '#ffdd00' }, { x: 11, y: 10, color: '#ffdd00' }, { x: 4, y: 14, color: '#ffdd00' }
        ]);
        var matLava = new THREE.MeshLambertMaterial({ 
            map: lavaTexture,
            emissive: 0xff6600,
            emissiveIntensity: 0.7
        });

        mats[0] = [matDirt, matDirt, matGrassTop, matDirt, matDirt, matDirt];
        mats[1] = matDirt;
        mats[2] = matStone;
        mats[3] = matWood;
        mats[4] = matSand;
        mats[5] = matBedrock;
        mats[6] = matLeaves;
        mats[7] = matGlass;
        mats[8] = matDoor;
        mats[9] = matTorch;
        mats[10] = matWater;
        mats[11] = matLava;

        // --- World Data and Basic Functions ---
        var world = {}; 
        var bs = 2; // Block Size
        var ws = 40; // World Size (in chunks)
        // renderDistance, mouseSensitivity, fieldOfView are declared at top of script
        var sel = 0; // HUD selection index (0-7)

        function key(x, y, z) { return Math.round(x) + "," + Math.round(y) + "," + Math.round(z); }

        // Optimization: Reuse geometries and materials
        var blockGeometry = new THREE.BoxGeometry(bs, bs, bs);
        var doorGeometry = new THREE.BoxGeometry(bs * 0.25, bs * 2, bs); // Thin door, 2 blocks tall
        var torchGeometry = new THREE.BoxGeometry(bs * 0.125, bs * 0.625, bs * 0.125); // Minecraft-like torch: 2x10x2 pixels
        
        // --- BLOCK OUTLINE ---
        const outlineGeometry = new THREE.EdgesGeometry(new THREE.BoxGeometry(bs + 0.02, bs + 0.02, bs + 0.02));
        const outlineMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
        const blockOutline = new THREE.LineSegments(outlineGeometry, outlineMaterial);
        blockOutline.visible = false;
        scene.add(blockOutline);
        
        // --- PARTICLE SYSTEM ---
        const particles = [];
        const particleGeometry = new THREE.PlaneGeometry(0.3, 0.3);
        
        function createBreakParticles(x, y, z, blockType) {
            const particleMaterial = mats[blockType];
            const mat = Array.isArray(particleMaterial) ? particleMaterial[0] : particleMaterial;
            
            for (let i = 0; i < 8; i++) {
                const particle = new THREE.Mesh(particleGeometry, mat.clone());
                particle.position.set(
                    x * bs + (Math.random() - 0.5) * bs,
                    y * bs + (Math.random() - 0.5) * bs,
                    z * bs + (Math.random() - 0.5) * bs
                );
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 5,
                    Math.random() * 8 + 2,
                    (Math.random() - 0.5) * 5
                );
                particle.lifetime = 1.0;
                scene.add(particle);
                particles.push(particle);
            }
        }
        
        function add(x, y, z, t) {
            var k = key(x, y, z);
            if (world[k]) return;
            
            var m = mats[t];
            var mesh;
            
            // Special handling for doors - single mesh spanning 2 blocks
            if (t === DOOR_TYPE) {
                // Check if there's space for 2 blocks tall
                var kAbove = key(x, y + 1, z);
                if (world[kAbove]) return; // Can't place if space above is occupied
                
                // Create single mesh positioned between y and y+1
                mesh = new THREE.Mesh(doorGeometry, m);
                mesh.position.set(x * bs, y * bs + bs / 2, z * bs); // Center between y and y+1
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.userData.blockType = t;
                mesh.userData.isDoor = true;
                mesh.userData.doorOpen = false;
                mesh.userData.doorBottomY = y; // Store bottom position
                scene.add(mesh);
                
                // Store in both block positions but pointing to same mesh
                world[k] = mesh;
                world[kAbove] = mesh;
                
                // Play place sound if not silent
                if (!mesh.userData.silentPlace) {
                    playPlaceSound(t);
                }
            } else if (t === TORCH_TYPE) {
                // Torch positioned at same height as normal blocks
                mesh = new THREE.Mesh(torchGeometry, m);
                mesh.position.set(x * bs, y * bs, z * bs);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.userData.blockType = t;
                mesh.userData.isTorch = true; // Flag for no collision
                scene.add(mesh);
                world[k] = mesh;
                
                // Add bright point light at torch position (optimized - no shadows for performance)
                var torchLight = new THREE.PointLight(0xffaa00, 2.0, 20); // Increased intensity and range
                torchLight.position.set(x * bs, y * bs + bs * 0.3, z * bs);
                torchLight.castShadow = false; // Disabled for performance - allows multiple torches
                scene.add(torchLight);
                mesh.userData.light = torchLight;
                
                // Play place sound if not silent
                if (!mesh.userData.silentPlace) {
                    playPlaceSound(t);
                }
            } else {
                // Regular block
                mesh = new THREE.Mesh(blockGeometry, Array.isArray(m) ? m : [m, m, m, m, m, m]); 
                mesh.position.set(x * bs, y * bs, z * bs);
            }
            
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            world[k] = mesh; 
            mesh.userData.blockType = t; 
            
            // Play place sound only when player places (not during world generation or grass spreading)
            if (locked && !paused && !mesh.userData.silentPlace) {
                playPlaceSound(t);
            }
        }

        function remove(x, y, z) {
            var k = key(x, y, z);
            if (world[k]) {
                const blockType = world[k].userData.blockType; 
                const mesh = world[k];
                
                // --- Bedrock Indestructibility Check ---
                // MODIFIED: Only indestructible in Survival mode
                if (blockType === BEDROCK_TYPE && !isCreativeMode) {
                     console.log("Bedrock cannot be destroyed in Survival Mode.");
                     return; 
                }
                // -------------------------------------------

                // Special handling for doors - remove both blocks
                if (blockType === DOOR_TYPE) {
                    const doorBottomY = mesh.userData.doorBottomY;
                    const kBottom = key(x, doorBottomY, z);
                    const kTop = key(x, doorBottomY + 1, z);
                    
                    // Create break particles at door position
                    createBreakParticles(x, doorBottomY, z, blockType);
                    playBreakSound(blockType);
                    
                    // Remove from scene and world
                    scene.remove(mesh);
                    delete world[kBottom];
                    delete world[kTop];
                    
                    // Add to inventory
                    addToInventory(DOOR_TYPE, 1);
                    return;
                }
                
                // Special handling for torch - remove light
                if (blockType === TORCH_TYPE && mesh.userData.light) {
                    scene.remove(mesh.userData.light);
                }

                // Create break particles
                createBreakParticles(x, y, z, blockType);
                
                // Play breaking sound with block type
                playBreakSound(blockType);

                scene.remove(mesh);
                delete world[k];
                
                // MODIFIED: Grass (type 0) drops Dirt (type 1)
                const dropType = (blockType === GRASS_TYPE) ? DIRT_TYPE : blockType; 

                // Add to inventory (will be ignored in creative, work in survival)
                addToInventory(dropType, 1);
            }
        }
        
        // Toggle door open/closed state
        function toggleDoor(x, y, z) {
            var k = key(x, y, z);
            var mesh = world[k];
            
            if (!mesh || mesh.userData.blockType !== DOOR_TYPE) return;
            
            // Toggle door state
            const currentlyOpen = mesh.userData.doorOpen;
            mesh.userData.doorOpen = !currentlyOpen;
            
            // Get door bottom Y position
            const doorBottomY = mesh.userData.doorBottomY;
            
            const offset = 0.25; // Quarter block offset
            
            if (!currentlyOpen) {
                // Opening: rotate and move to the side
                mesh.rotation.y = Math.PI / 2;
                mesh.position.z += offset;
            } else {
                // Closing: rotate back and return to center
                mesh.rotation.y = 0;
                mesh.position.z -= offset;
            }
            
            // Play door sound
            playPlaceSound(WOOD_TYPE); // Use wood sound for door
        }

        // Helper function for collision check
        function isBlockPresent(x, y, z) {
            var tx = Math.round(x / bs);
            var ty = Math.round(y / bs); 
            var tz = Math.round(z / bs);
            var block = world[key(tx, ty, tz)];
            
            if (!block) return false;
            
            // Return false for torches (no collision)
            if (block.userData.isTorch) {
                return false;
            }
            
            // Return false for water and lava (no collision - can swim through)
            const blockType = block.userData.blockType;
            if (blockType === WATER_TYPE || blockType === LAVA_TYPE) {
                return false;
            }
            
            // Return false for open doors (no collision)
            if (block.userData.blockType === DOOR_TYPE && block.userData.doorOpen) {
                return false;
            }
            
            return true;
        }
        
        function generateWorld() {
             // Optimization: More efficient cleanup - don't dispose shared geometry
             for(var k in world) { 
                scene.remove(world[k]); 
             }
            world = {};
            
            if (isFlatWorld) {
                // --- FLAT WORLD GENERATION ---
                for (var x = -ws / 2; x < ws / 2; x++) {
                    for (var z = -ws / 2; z < ws / 2; z++) {
                        add(x, 0, z, BEDROCK_TYPE); // Bedrock at Y=0
                        add(x, 1, z, 2); // Stone at Y=1
                        add(x, 2, z, DIRT_TYPE); // Dirt at Y=2
                        add(x, 3, z, GRASS_TYPE); // Grass at Y=3
                    }
                }
                return; // Exit early for flat world
            }
            
            // Optimization: Pre-calculate noise values
            var noiseMap = {};
            for (var x = -ws / 2; x < ws / 2; x++) {
                for (var z = -ws / 2; z < ws / 2; z++) {
                    var seededX = x + WORLD_SEED / 100;
                    var seededZ = z + WORLD_SEED / 100;
                    
                    // Enhanced terrain generation with biomes
                    var baseHeight = Math.floor(
                        Math.sin(seededX * 0.1) * Math.cos(seededZ * 0.1) * 2 + 
                        Math.sin(seededX * 0.3) * 1.5 + 
                        Math.cos(seededZ * 0.2) * 1.5 + 
                        4
                    );
                    
                    // Biome determination (using noise for variation)
                    var biomeNoise = Math.sin(seededX * 0.05) * Math.cos(seededZ * 0.05);
                    var moistureNoise = Math.sin(seededX * 0.08) * Math.sin(seededZ * 0.08);
                    
                    // Store height and biome data
                    noiseMap[x + ',' + z] = {
                        height: baseHeight,
                        biome: biomeNoise,
                        moisture: moistureNoise
                    };
                }
            }
            
            // Generate terrain using pre-calculated noise
            for (var x = -ws / 2; x < ws / 2; x++) {
                for (var z = -ws / 2; z < ws / 2; z++) {
                    var data = noiseMap[x + ',' + z];
                    var h = data.height;
                    var biome = data.biome;
                    var moisture = data.moisture;
                    
                    // 1. ADD BEDROCK at Y=0 (type 5)
                    add(x, 0, z, BEDROCK_TYPE); 

                    // 2. Generate terrain from Y=1 up to h+1 with biome-specific blocks
                    for (var y = 1; y < h + 1; y++) { 
                        var bt = 2; // Default is Stone
                        
                        // Determine surface block based on biome
                        if (y === h) { 
                            // Desert/Beach biome (sand) - dry and low areas
                            if (biome > 0.3 && moisture < -0.2) {
                                bt = 4; // Sand
                            }
                            // Water-adjacent areas (beaches)
                            else if (h <= 3) {
                                bt = 4; // Sand at water level
                            }
                            // Normal grass
                            else {
                                bt = 0; // Grass
                            }
                        } 
                        // Subsurface layers
                        else if (y >= h - 2) {
                            // Sand continues deeper in desert biomes
                            if (biome > 0.3 && moisture < -0.2) {
                                bt = 4; // Sand
                            } else {
                                bt = 1; // Dirt
                            }
                        }
                        // Deep layers are stone
                        
                        add(x, y, z, bt); 
                    }

                    // 3. Tree Generation (only on grass, not sand)
                    var topBlockType = (biome > 0.3 && moisture < -0.2) || h <= 3 ? 4 : 0;
                    if (topBlockType === 0 && h >= 5 && Math.random() < 0.02) { 
                        generateTree(x, h + 1, z);
                    }
                }
            }
            
            // 4. REALISTIC WATER & LAVA GENERATION (Seas and Puddles only - NO water on grass)
            
            // Define water level (sea level)
            var SEA_LEVEL = 4;
            
            // First pass: Create oceans and seas by filling low-lying areas
            for (var x = -ws / 2; x < ws / 2; x++) {
                for (var z = -ws / 2; z < ws / 2; z++) {
                    var data = noiseMap[x + ',' + z];
                    var h = data.height;
                    var biome = data.biome;
                    var moisture = data.moisture;
                    
                    // Create ocean/sea if terrain is below sea level
                    if (h < SEA_LEVEL) {
                        // Fill with water above terrain up to sea level
                        for (var y = h + 1; y <= SEA_LEVEL; y++) {
                            add(x, y, z, WATER_TYPE);
                        }
                    }
                }
            }
            
            // Second pass: Create underground water puddles ONLY
            for (var x = -ws / 2; x < ws / 2; x++) {
                for (var z = -ws / 2; z < ws / 2; z++) {
                    var data = noiseMap[x + ',' + z];
                    var h = data.height;
                    var biome = data.biome;
                    
                    // Skip if already underwater (in ocean)
                    if (h < SEA_LEVEL) continue;
                    
                    var isSandBiome = (biome > 0.3 && data.moisture < -0.2);
                    
                    // Small water puddles underground in wet areas (NOT on surface)
                    if (!isSandBiome && data.moisture > 0.2 && h >= 4 && Math.random() < 0.002) {
                        var puddleDepth = Math.floor(Math.random() * 2) + 2; // 2-3 blocks underground
                        var puddleKey = key(x, h - puddleDepth, z);
                        // Only place puddle if there's a solid block there to replace
                        if (world[puddleKey]) {
                            remove(x, h - puddleDepth, z);
                            add(x, h - puddleDepth, z, WATER_TYPE);
                        }
                    }
                    
                    // Lava pools in desert biomes (underground)
                    if (isSandBiome && Math.random() < 0.001 && h >= 3) {
                        var lavaDepth = Math.floor(Math.random() * 2) + 2;
                        var lavaKey = key(x, h - lavaDepth, z);
                        if (world[lavaKey]) {
                            remove(x, h - lavaDepth, z);
                            add(x, h - lavaDepth, z, LAVA_TYPE);
                        }
                    }
                    
                    // Rare underground lava pockets (deep)
                    if (Math.random() < 0.0005 && h >= 5) {
                        var deepLavaDepth = Math.floor(Math.random() * 3) + 3;
                        var deepLavaKey = key(x, h - deepLavaDepth, z);
                        if (world[deepLavaKey]) {
                            remove(x, h - deepLavaDepth, z);
                            add(x, h - deepLavaDepth, z, LAVA_TYPE);
                        }
                    }
                }
            }
        }

        // --- Player/Movement variables ---
        var px = 0; var py = 20; var pz = 0; 
        var vx = 0; var vy = 0; var vz = 0; 
        var rx = 0; var ry = 0; 
        var ground = false;
        var keys = {};
        var locked = false;
        var paused = false; 
        var inventoryOpen = false; 
        
        // --- FLYING VARS ---
        let isFlying = false; 
        let lastSpacePress = 0;
        let spaceHeld = false; // NEW: Track if space is held
        const DOUBLE_PRESS_TIME = 300; // ms
        // -------------------------
        
        // --- OXYGEN/BREATHING VARS ---
        let maxOxygen = 10; // Maximum oxygen (10 bubbles)
        let currentOxygen = maxOxygen; // Current oxygen level
        let isUnderwater = false; // Track if player is underwater
        const oxygenDepletionRate = 1; // Oxygen lost per second underwater (1 bubble per second)
        const oxygenRegenRate = 5; // Oxygen gained per second when not underwater (fast regen)
        const drownDamageRate = 2; // Damage per second when out of oxygen
        let drownDamageTimer = 0; // Timer for drowning damage
        const drownDamageInterval = 1.0; // Take damage every 1 second when drowning
        // -------------------------
        
        // --- HEALTH SYSTEM VARS ---
        let maxHealth = 20; // Maximum health (10 hearts = 20 half-hearts)
        let currentHealth = maxHealth; // Current health level
        let isDead = false; // Track if player is dead
        // -------------------------
        
        // --- Player Size Constants (1.7 blocks tall like Minecraft) ---
        var PLAYER_TOTAL_HEIGHT = bs * 1.7; // Total player height (1.7 blocks)
        var EYE_HEIGHT = bs * 1.54; // Camera eye height from feet (1.54 blocks from feet)
        var PLAYER_HEIGHT = PLAYER_TOTAL_HEIGHT; // For collision detection
        var PLAYER_RADIUS = bs * 0.3; // Player is 0.6 blocks wide (matches Minecraft)
        var HEAD_CLEARANCE = bs * 0.16; // Small clearance above eyes to detect ceiling

        var pauseMenu = document.getElementById('pause-menu'); 
        var inventoryScreen = document.getElementById('inventory-screen'); 
        var uiElement = document.getElementById('ui'); 
        var settingsSeedInput = document.getElementById('settingsSeedInput'); 
        var settingsSeedInputStart = document.getElementById('settingsSeedInputStart'); 

        // --- NEW COOLDOWN VARIABLES ---
        const COOLDOWN_TIME_MS = 2000; // 2 seconds
        let isCooldownActive = false;
        const continueGameButton = document.getElementById('main-menu-btn-pause');
        
        // Respawn button cooldown variables
        let isRespawnCooldownActive = false;
        const respawnButton = document.getElementById('respawn-btn');
        
        // Track if buttons have been clicked to skip countdown
        let pauseMenuButtonsClicked = false;
        // --- END NEW COOLDOWN VARIABLES ---


        function resetPlayer() {
            px = 0; py = 20; pz = 0; vx = 0; vy = 0; vz = 0; rx = 0; ry = 0; 
            // Player height is constant at 2 blocks
            PLAYER_HEIGHT = PLAYER_TOTAL_HEIGHT; 
            camera.position.set(px, py, pz);
            camera.rotation.set(rx, ry, 0, 'YXZ');
            ground = false;
            
            // Reset oxygen to full
            currentOxygen = maxOxygen;
            isUnderwater = false;
            drownDamageTimer = 0;
            
            // Reset health to full
            currentHealth = maxHealth;
            isDead = false;
            
            // Clear inventory in survival mode
            if (!isCreativeMode) {
                inventoryData = Array(TOTAL_SLOTS).fill(null);
                updateInventoryUI();
                updateToolbarSelection();
            }
            
            // Reset game modes
            // isCreativeMode is preserved across respawns (Fix for user request)
            isFlying = false;
            
            // Hide death screen
            document.getElementById('death-screen').style.display = 'none';
        }
        resetPlayer(); 

        
        // --- Health & Oxygen UI Update Functions ---
        function updateHealthUI() {
            const healthContainer = document.getElementById('health-container');
            if (!isCreativeMode) {
                healthContainer.style.display = 'block';
                healthContainer.innerHTML = '';
                
                const numHearts = 10; // Total 10 hearts (20 health points)
                for (let i = 0; i < numHearts; i++) {
                    const heart = document.createElement('span');
                    heart.className = 'heart';
                    
                    const heartValue = (i + 1) * 2; // Each heart represents 2 health
                    
                    if (currentHealth >= heartValue) {
                        // Full heart
                        heart.classList.add('full');
                    } else if (currentHealth >= heartValue - 1) {
                        // Half heart
                        heart.classList.add('half');
                    } else {
                        // Empty heart
                        heart.classList.add('empty');
                    }
                    
                    // Add low health animation
                    if (currentHealth <= 6) {
                        heart.classList.add('low');
                    }
                    
                    healthContainer.appendChild(heart);
                }
            } else {
                healthContainer.style.display = 'none';
            }
        }
        
        function updateOxygenUI() {
            const oxygenContainer = document.getElementById('oxygen-container');
            if (!isCreativeMode && (isUnderwater || currentOxygen < maxOxygen)) {
                oxygenContainer.style.display = 'block';
                oxygenContainer.innerHTML = '';
                
                const numBubbles = 10; // Total 10 bubbles
                for (let i = 0; i < numBubbles; i++) {
                    const bubble = document.createElement('span');
                    bubble.className = 'bubble';
                    
                    if (currentOxygen < (i + 1)) {
                        // Popped bubble
                        bubble.classList.add('popped');
                    }
                    
                    oxygenContainer.appendChild(bubble);
                }
            } else {
                oxygenContainer.style.display = 'none';
            }
        }
        
        function takeDamage(amount) {
            if (isCreativeMode || isDead) return;
            
            currentHealth = Math.max(0, currentHealth - amount);
            updateHealthUI();
            
            if (currentHealth <= 0) {
                playerDeath();
            }
        }
        
        function playerDeath() {
            isDead = true;
            paused = true;
            
            // Exit pointer lock
            if (document.exitPointerLock) {
                document.exitPointerLock();
            }
            locked = false;
            
            // Hide crosshair, show death screen
            document.getElementById('crosshair').style.display = 'none';
            document.getElementById('death-screen').style.display = 'flex';
            
            // Calculate score
            const score = Math.floor((Date.now() - (window.gameStartTime || Date.now())) / 1000);
            document.getElementById('death-score').textContent = score + ' seconds survived';
            
            // Stop player movement
            vx = 0;
            vy = 0;
            vz = 0;
        }


        
        // --- Game Mode Toggle Functions ---
        function updateGameModeButtonText() {
            gameModeToggleBtn.textContent = isCreativeMode ? 'Switch to Survival' : 'Switch to Creative';
        }

        function toggleGameMode() {
            isCreativeMode = !isCreativeMode;
            
            if (isCreativeMode) {
                isFlying = false; // Disable flying when switching (will be re-enabled on double-space if desired)
            } else {
                isFlying = false; // MUST disable flying when switching to survival
            }
            
            updateGameModeButtonText();
            inventoryScreen.classList.toggle('creative-mode', isCreativeMode);
            
            // Refresh inventories to show/hide 'â'
            updateInventoryUI();
            updateToolbarSelection();
        }

        // --- Inventory Toggle Function ---
        function toggleInventory() {
            if (!locked) return; 
            inventoryOpen = !inventoryOpen;
            paused = inventoryOpen; 

            if (inventoryOpen) {
                inventoryScreen.style.display = 'flex';
                // Set class based on current game mode
                inventoryScreen.classList.toggle('creative-mode', isCreativeMode);
                updateGameModeButtonText(); // Update button text
                
                document.getElementById('crosshair').style.display = 'none'; 
                
                // NEW: Show and reset fake cursor (will be centered by CSS transform)
                fakeCursorElement.style.display = 'block';
                fakeCursorX = window.innerWidth / 2;
                fakeCursorY = window.innerHeight / 2;
                fakeCursorElement.style.left = fakeCursorX + 'px';
                fakeCursorElement.style.top = fakeCursorY + 'px';
                
                updateInventoryUI(); 
            } else {
                inventoryScreen.style.display = 'none';
                document.getElementById('crosshair').style.display = 'block'; 
                
                // NEW: Hide fake cursor
                fakeCursorElement.style.display = 'none';
                
                // When closing inventory, drop the item being held to prevent loss
                if (pickedUpItem) {
                    if (!isCreativeMode) {
                        // Add back to inventory in survival
                        addToInventory(pickedUpItem.type, pickedUpItem.count);
                    }
                    // In creative, item just disappears
                    pickedUpItem = null;
                }
                // NEW: Update UI to hide pickedUpItemElement when closing
                updateInventoryUI();
            }
            updateToolbarSelection();
        }
        
        // --- MODIFIED: Toggle Pause Function to handle cooldown ---
        function togglePause() {
            // Only allow unpausing if cooldown is not active
            if (!paused && isCooldownActive) return; 

            paused = !paused;
            if (!paused) {
                // Resume game: Request pointer lock
                requestLock(renderer.domElement);
                pauseMenu.style.display = 'none';
                document.getElementById('crosshair').style.display = 'block'; 
                
                // Reset button text
                continueGameButton.textContent = 'CONTINUE GAME (ESC)'; 
            } else {
                // Pause game: Exit pointer lock
                document.exitPointerLock();
                showPauseMenu();
            }
        }
        
        function showPauseMenu() {
            paused = true;
            inventoryOpen = false; 
            inventoryScreen.style.display = 'none'; 
            pauseMenu.style.display = 'flex';
            document.getElementById('crosshair').style.display = 'none'; 
            
            // NEW: Hide fake cursor if it was open
            if (fakeCursorElement) fakeCursorElement.style.display = 'none';
            // NEW: Hide floating item if it was visible
            if (pickedUpItemElement) pickedUpItemElement.style.display = 'none';


            settingsSeedInput.value = WORLD_SEED;
            
            // Display current world name
            const worldNameDisplay = document.getElementById('current-world-name');
            if (worldNameDisplay && currentWorldName) {
                worldNameDisplay.textContent = 'World: ' + currentWorldName;
            }
            
            // COUNTDOWN FOR BUTTONS WHEN PAUSE MENU OPENS (every time)
            const pauseMenuCountdown = 2000; // 2000 milliseconds (2 seconds)
            let remainingTime = pauseMenuCountdown;
            
            // Disable buttons and show countdown
            continueGameButton.disabled = true;
            respawnButton.disabled = true;
            continueGameButton.textContent = `CONTINUE GAME (${(remainingTime / 1000).toFixed(2)}s)`;
            respawnButton.textContent = `RESPAWN (${(remainingTime / 1000).toFixed(2)}s)`;
            
            // Update countdown every 100ms for smooth animation
            const pauseCountdownInterval = setInterval(() => {
                remainingTime -= 100;
                
                if (remainingTime <= 0) {
                    clearInterval(pauseCountdownInterval);
                    // Enable buttons and reset text
                    continueGameButton.disabled = false;
                    respawnButton.disabled = false;
                    continueGameButton.textContent = 'CONTINUE GAME (ESC)';
                    respawnButton.textContent = 'RESPAWN';
                } else {
                    // Update button text with remaining time in seconds with 2 decimal places
                    continueGameButton.textContent = `CONTINUE GAME (${(remainingTime / 1000).toFixed(2)}s)`;
                    respawnButton.textContent = `RESPAWN (${(remainingTime / 1000).toFixed(2)}s)`;
                }
            }, 100);
            // END COUNTDOWN
        }
        
        // --- Event Listeners ---
        document.addEventListener('keydown', function(e) { 
            keys[e.code] = true; 
            
            // --- FLYING TOGGLE (Double Space) ---
            if (e.code === 'Space' && locked && !inventoryOpen && !paused) {
                // Double-tap to fly ONLY works in creative mode
                if (!isCreativeMode) return; 
                
                // NEW: Bug fix for hold-to-fly-toggle
                if (spaceHeld) return; // Don't process if key is already held
                spaceHeld = true; // Set hold flag
                // --- End bug fix

                const now = performance.now();
                if (now - lastSpacePress < DOUBLE_PRESS_TIME) {
                    // Double press detected
                    isFlying = !isFlying;
                    vy = 0; // Stop vertical motion when toggling
                    e.preventDefault(); // Prevent jump on toggle
                }
                lastSpacePress = now;
            }
            // --- END FLYING TOGGLE ---

            // --- INVENTORY NAVIGATION (8x4 grid) ---
            if (inventoryOpen) {
                // --- NEW: Keyboard controls disabled in inventory ---
            }

            if (e.code === 'Escape') {
                if (inventoryOpen) { 
                    // 1. Close inventory UI/state (sets inventoryOpen=false, paused=false)
                    toggleInventory(); 
                    
                    // 2. Now that the inventory is closed, immediately open the pause menu
                    if (locked) {
                        showPauseMenu();
                    }

                } 
                // Only allow pausing with ESC, not unpausing (button only for continue)
                else if (locked && !paused) { togglePause(); }
            }
            
            if (e.code === 'KeyE' && locked) {
                if (!pauseMenu.style.display || pauseMenu.style.display === 'none') { toggleInventory(); }
            }
            
            // HUD selection 1-8 keys (only when NOT in inventory)
            if (!inventoryOpen && e.code.startsWith('Digit') && e.keyCode >= 49 && e.keyCode <= 56) { 
                sel = e.keyCode - 49; 
                updateToolbarSelection();
            }

        });

        document.addEventListener('keyup', function(e) { 
            keys[e.code] = false; 
            // NEW: Bug fix for fly toggle
            if (e.code === 'Space') {
                spaceHeld = false;
            }
        });
        
        // --- NEW: Cross-browser Pointer Lock Change Handler ---
        function onPointerLockChange() { 
            locked = document.pointerLockElement === renderer.domElement ||
                     document.mozPointerLockElement === renderer.domElement || // Firefox prefix
                     document.webkitPointerLockElement === renderer.domElement; // Webkit prefix (Chrome)
                     
            // Check if lock is lost
            if (!locked) {
                // If inventory was open, we need to explicitly close it first, then transition to pause menu.
                if (inventoryOpen) {
                    // Manually perform the 'close inventory' steps from toggleInventory()
                    inventoryOpen = false; // State change
                    
                    inventoryScreen.style.display = 'none';
                    document.getElementById('crosshair').style.display = 'block'; 
                    
                    // Hide fake cursor/picked up item
                    if (fakeCursorElement) fakeCursorElement.style.display = 'none';
                    if (pickedUpItemElement) pickedUpItemElement.style.display = 'none';

                    // When closing inventory, drop the item being held to prevent loss
                    if (pickedUpItem) {
                        if (!isCreativeMode) {
                            // Add back to inventory in survival
                            addToInventory(pickedUpItem.type, pickedUpItem.count);
                        }
                        pickedUpItem = null;
                    }
                    updateInventoryUI();
                    
                    // Now, transition to the "Game Stopped" screen
                    showPauseMenu();

                } else if (!paused) { 
                    // If not in inventory and not already in pause menu, simply show pause menu (e.g., alt-tab from gameplay)
                    showPauseMenu();
                }
            }
        }
        
        document.addEventListener('pointerlockchange', onPointerLockChange, false);
        document.addEventListener('mozpointerlockchange', onPointerLockChange, false);
        document.addEventListener('webkitpointerlockchange', onPointerLockChange, false);
        // --- END NEW ---

        // MODIFIED: Continue Game button with cooldown (same as respawn button)
        continueGameButton.addEventListener('click', function() {
            // Immediately execute the continue game action
            togglePause();
        });
        // NEW: Save World button
        document.getElementById('save-world-btn').addEventListener('click', function() {
            if (currentWorldName) {
                saveWorld(currentWorldName);
                alert('World saved successfully!');
            }
        });
        
        // NEW: Settings button from pause menu
        document.getElementById('pause-settings-btn').addEventListener('click', function() {
            // Set flag to remember we came from pause menu
            openedSettingsFromPause = true;
            
            // Hide pause menu
            pauseMenu.style.display = 'none';
            
            // Show main menu with settings view
            document.getElementById('main-menu').style.display = 'flex';
            
            // Initialize sliders with current values
            const slider = document.getElementById('renderDistanceSlider');
            const valueSpan = document.getElementById('renderDistanceValue');
            if (slider && valueSpan) {
                slider.value = renderDistance;
                valueSpan.textContent = renderDistance;
            }
            
            const sensSlider = document.getElementById('sensitivitySlider');
            const sensValueSpan = document.getElementById('sensitivityValue');
            if (sensSlider && sensValueSpan) {
                sensSlider.value = mouseSensitivity * 100;
                sensValueSpan.textContent = Math.round(mouseSensitivity * 100);
            }
            
            const fovSlider = document.getElementById('fovSlider');
            const fovValueSpan = document.getElementById('fovValue');
            if (fovSlider && fovValueSpan) {
                fovSlider.value = fieldOfView;
                fovValueSpan.textContent = fieldOfView;
            }
            
            showView('settings-view');
        });
        
        // Respawn button
        respawnButton.addEventListener('click', function() {
            // Immediately execute the respawn action
            resetPlayer();
            togglePause();
        });
        
        // Death screen respawn button
        document.getElementById('death-respawn-btn').addEventListener('click', function() {
            resetPlayer();
            // Request pointer lock again and show crosshair
            requestLock(renderer.domElement);
            document.getElementById('crosshair').style.display = 'block';
            paused = false;
        });
        
        // NEW: Exit to Menu button with save prompt
        document.getElementById('exit-to-menu-btn').addEventListener('click', function() { 
            if (currentWorldName) {
                const shouldSave = confirm('Do you want to save your world before exiting?');
                if (shouldSave) {
                    saveWorld(currentWorldName);
                }
            }
            stopAutoSave();
            window.location.reload(); 
        });

        // --- Menu View Switching Logic (Unchanged) ---
        function showView(viewId) {
            document.querySelectorAll('#main-menu .menu-view').forEach(view => { view.style.display = 'none'; });
            document.getElementById(viewId).style.display = 'flex';
        }
        document.getElementById('showCreationBtn').addEventListener('click', function() { showView('creation-view'); });
        document.getElementById('showSavedWorldsBtn').addEventListener('click', function() { 
            displaySavedWorlds(); 
            showView('saved-worlds-view'); 
        });
        document.getElementById('showSettingsBtn').addEventListener('click', function() {
            // NEW: Initialize Render Distance Slider (view distance, not world size)
            const slider = document.getElementById('renderDistanceSlider');
            const valueSpan = document.getElementById('renderDistanceValue');
            if (slider && valueSpan) {
                slider.value = renderDistance;
                valueSpan.textContent = renderDistance;
            }
            
            // Initialize Sensitivity Slider
            const sensSlider = document.getElementById('sensitivitySlider');
            const sensValueSpan = document.getElementById('sensitivityValue');
            if (sensSlider && sensValueSpan) {
                sensSlider.value = mouseSensitivity * 100;
                sensValueSpan.textContent = Math.round(mouseSensitivity * 100);
            }
            
            // Initialize FOV Slider
            const fovSlider = document.getElementById('fovSlider');
            const fovValueSpan = document.getElementById('fovValue');
            if (fovSlider && fovValueSpan) {
                fovSlider.value = fieldOfView;
                fovValueSpan.textContent = fieldOfView;
            }
            // END NEW

            showView('settings-view');
        });
        document.getElementById('showCreditsBtn').addEventListener('click', function() { showView('credits-view'); });
        document.getElementById('backFromCreationBtn').addEventListener('click', function() { showView('main-controls'); });
        document.getElementById('backFromSettingsBtn').addEventListener('click', function() { 
            // Check if we came from pause menu
            if (openedSettingsFromPause) {
                // Reset flag
                openedSettingsFromPause = false;
                
                // Hide main menu
                document.getElementById('main-menu').style.display = 'none';
                
                // Show pause menu again
                pauseMenu.style.display = 'flex';
            } else {
                // Regular flow: go back to main controls
                showView('main-controls');
            }
        });
        document.getElementById('backFromSavedWorldsBtn').addEventListener('click', function() { showView('main-controls'); });
        document.getElementById('backFromCreditsBtn').addEventListener('click', function() { showView('main-controls'); });
        
        // NEW: World Size Slider (in creation menu)
        const worldSizeSlider = document.getElementById('worldSizeSlider');
        const worldSizeValueSpan = document.getElementById('worldSizeValue');

        if (worldSizeSlider && worldSizeValueSpan) {
            worldSizeSlider.addEventListener('input', function() {
                ws = parseInt(this.value);
                worldSizeValueSpan.textContent = ws;
            });
            // Initial sync
            worldSizeSlider.value = ws;
            worldSizeValueSpan.textContent = ws;
        }

        // NEW: View Distance Slider (in settings menu) - separate from world size
        const renderDistanceSlider = document.getElementById('renderDistanceSlider');
        const renderDistanceValueSpan = document.getElementById('renderDistanceValue');

        if (renderDistanceSlider && renderDistanceValueSpan) {
            renderDistanceSlider.addEventListener('input', function() {
                renderDistance = parseInt(this.value);
                renderDistanceValueSpan.textContent = renderDistance;
                saveSettings(); // Save to localStorage
            });
            // Initial sync
            renderDistanceSlider.value = renderDistance;
            renderDistanceValueSpan.textContent = renderDistance;
        }
        
        // NEW: Mouse Sensitivity Slider
        const sensitivitySlider = document.getElementById('sensitivitySlider');
        const sensitivityValueSpan = document.getElementById('sensitivityValue');

        if (sensitivitySlider && sensitivityValueSpan) {
            sensitivitySlider.addEventListener('input', function() {
                mouseSensitivity = parseInt(this.value) / 100;
                sensitivityValueSpan.textContent = this.value;
                saveSettings(); // Save to localStorage
            });
            // Initial sync
            sensitivitySlider.value = mouseSensitivity * 100;
            sensitivityValueSpan.textContent = Math.round(mouseSensitivity * 100);
        }
        
        // NEW: FOV Slider
        const fovSlider = document.getElementById('fovSlider');
        const fovValueSpan = document.getElementById('fovValue');

        if (fovSlider && fovValueSpan) {
            fovSlider.addEventListener('input', function() {
                fieldOfView = parseInt(this.value);
                fovValueSpan.textContent = fieldOfView;
                camera.fov = fieldOfView;
                camera.updateProjectionMatrix();
                saveSettings(); // Save to localStorage
            });
            // Initial sync
            fovSlider.value = fieldOfView;
            fovValueSpan.textContent = fieldOfView;
        }
        // END NEW
        
        // NEW: Game Mode Toggle Listener
        gameModeToggleBtn.addEventListener('click', toggleGameMode);


        // --- Game Start Logic (CREATE WORLD) ---
        document.getElementById('createWorldBtn').addEventListener('click', function() {
            const seedInput = document.getElementById('seedInput').value;
            const flatWorldCheckbox = document.getElementById('flatWorldCheckbox');
            
            WORLD_SEED = seedInput ? parseInt(seedInput) : Math.floor(Math.random() * 1000000); 
            isFlatWorld = flatWorldCheckbox.checked; // NEW: Set flat world option
            
            // Prompt for world name
            let worldName = prompt('Enter a name for your world:', 'My World ' + WORLD_SEED);
            if (!worldName) {
                worldName = 'World_' + WORLD_SEED;
            }
            
            resetPlayer();
            generateWorld();
            generateInventorySlots(); // This now also generates the block picker
            updateToolbarSelection(); 
            updateGameModeButtonText(); // Set initial button text
            
            // Initialize game start time
            window.gameStartTime = Date.now();
            
            // Save the new world
            saveWorld(worldName);
            startAutoSave(worldName);

            document.getElementById('main-menu').style.display = 'none';
            // MODIFIED: Use cross-browser requestLock function
            requestLock(renderer.domElement); 
            document.getElementById('crosshair').style.display = 'block'; 
            
            if (!window.gameLoopStarted) {
                loop();
                window.gameLoopStarted = true;
            }
        });
        
        // --- Input and Raycasting ---
        
        // --- REFACTORED: Global Mouse Move Listener ---
        document.addEventListener('mousemove', function(e) {
            if (!locked) return; // If lock is lost, do nothing

            if (paused && inventoryOpen) {
                // --- FAKE CURSOR MOVEMENT ---
                // Update fake cursor position
                fakeCursorX += e.movementX;
                fakeCursorY += e.movementY;

                // Clamp to screen bounds
                fakeCursorX = Math.max(0, Math.min(window.innerWidth -1, fakeCursorX));
                fakeCursorY = Math.max(0, Math.min(window.innerHeight -1, fakeCursorY));

                // Apply style (CSS transform centers the element)
                fakeCursorElement.style.left = fakeCursorX + 'px';
                fakeCursorElement.style.top = fakeCursorY + 'px';
                
                // MODIFIED: Make picked-up item follow cursor (CSS transform centers the item)
                if (pickedUpItem) {
                    pickedUpItemElement.style.left = fakeCursorX + 'px'; 
                    pickedUpItemElement.style.top = fakeCursorY + 'px'; 
                }

            } else if (!paused) {
                // --- CAMERA ROTATION (with sensitivity) ---
                ry -= e.movementX * 0.002 * mouseSensitivity;
                rx -= e.movementY * 0.002 * mouseSensitivity;
                rx = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rx));
            }
        });


        renderer.domElement.addEventListener('wheel', function(e) {
            if (!locked || paused) return;
            e.preventDefault();
            
            const HUD_SIZE = HUD_WIDTH; 

            if (e.deltaY > 0) { sel = (sel + 1) % HUD_SIZE; } 
            else if (e.deltaY < 0) { sel = (sel - 1 + HUD_SIZE) % HUD_SIZE; }
            
            updateToolbarSelection();
        });

        var ray = new THREE.Raycaster();
        ray.far = 15;
        
        // --- REFACTORED: Global Mousedown Listener ---
        renderer.domElement.addEventListener('mousedown', function(e) {
            
            if (inventoryOpen) {
                // --- FAKE CURSOR CLICK LOGIC ---
                // We are in the inventory. Do not fire a raycaster.
                
                // 1. Get the element under the *fake cursor*
                fakeCursorElement.style.display = 'none'; // Hide cursor to perform hit test
                let elementUnderCursor = document.elementFromPoint(fakeCursorX, fakeCursorY);
                fakeCursorElement.style.display = 'block'; // Show it again

                if (!elementUnderCursor) return;

                const slotElement = elementUnderCursor.closest('.inventory-slot');
                
                if (slotElement) {
                    // We clicked a slot in *either* inventory or block picker
                    if (slotElement.closest('#creative-block-picker')) {
                        // --- Clicked on Block Picker ---
                        if (!isCreativeMode) return;
                        const type = parseInt(slotElement.dataset.type);
                        
                        // Left or Right click in picker grabs a stack
                        pickedUpItem = { type: type, count: 64 };
                        updateInventoryUI();

                    } else if (slotElement.closest('.inventory-container')) {
                        // --- Clicked on Main Inventory ---
                        
                        // Move keyboard cursor to match (for visual feedback)
                        cursorX = parseInt(slotElement.dataset.x);
                        cursorY = parseInt(slotElement.dataset.y);
                        const slotIndex = parseInt(slotElement.dataset.index);

                        if (e.button === 0) { // Left-Click
                            swapItems(slotIndex);
                        } else if (e.button === 2) { // Right-Click
                            e.preventDefault();
                            handleInventoryRightClick(slotIndex); // Use new function
                        }
                    }
                } else if (elementUnderCursor.id === 'gameModeToggleBtn') {
                    // Clicked the toggle button
                    toggleGameMode();
                } else if (elementUnderCursor.closest('#delete-slot')) {
                    // --- NEW: Clicked on Delete Slot ---
                    if (pickedUpItem) {
                        pickedUpItem = null;
                        updateInventoryUI(); // Update UI to remove item from keyboard slot
                    }
                }

                return; // IMPORTANT: Stop processing, don't break/place blocks
            }

            // --- Original Raycasting Logic (if inventory is not open) ---
            if (!locked || paused || isDead) return;

            ray.setFromCamera(new THREE.Vector2(0, 0), camera);
            
            var objs = Object.values(world); 
            var hits = ray.intersectObjects(objs);
            
            if (hits.length > 0) {
                var hit = hits[0];
                var pos = hit.object.position;
                var bx = Math.round(pos.x / bs);
                var by = Math.round(pos.y / bs);
                var bz = Math.round(pos.z / bs);
                
                // Check if clicked block is a door
                const clickedBlock = world[key(bx, by, bz)];
                const isDoor = clickedBlock && clickedBlock.userData.blockType === DOOR_TYPE;

                if (e.button === 0) { // Left-Click (Break Block)
                    remove(bx, by, bz); 
                    
                } else if (e.button === 1) { // Middle-Click (Block Picker)
                    e.preventDefault();
                    
                    // Get the block type being looked at
                    if (clickedBlock && clickedBlock.userData.blockType !== undefined) {
                        const blockType = clickedBlock.userData.blockType;
                        handleMiddleClickBlockPick(blockType);
                    }
                    
                } else if (e.button === 2) { // Right-Click
                    
                    // If clicking on a door, toggle it instead of placing a block
                    if (isDoor) {
                        toggleDoor(bx, by, bz);
                        return; // Don't place blocks when clicking on door
                    }
                    
                    // Otherwise, place block as normal
                    const hudIndex = getHUDIndex(sel);
                    const item = inventoryData[hudIndex];
                    
                    if (item && item.count > 0 && window.activeBlockType !== null) {
                        var n = hit.face.normal;
                        var plx = bx + Math.round(n.x);
                        var ply = by + Math.round(n.y);
                        var plz = bz + Math.round(n.z);
                        
                        var pbx = Math.round(px / bs);
                        var pby = Math.round(py / bs);
                        var pbz = Math.round(pz / bs);
                        
                        var ok = true;
                        if (plx === pbx && ply === pby && plz === pbz) ok = false;
                        if (plx === pbx && ply === pby - 1 && plz === pbz) ok = false; 
                        
                        // Check if block position is already occupied
                        if (isBlockPresent(plx * bs, ply * bs, plz * bs)) ok = false;
                        
                        // For doors, also check if space above is free
                        if (item.type === DOOR_TYPE) {
                            if (isBlockPresent(plx * bs, (ply + 1) * bs, plz * bs)) ok = false;
                        }

                        if (ok) {
                            add(plx, ply, plz, item.type); 
                            
                            // --- SURVIVAL MODE: Consume Block ---
                            if (!isCreativeMode) {
                                item.count--; 
                                if (item.count <= 0) { inventoryData[hudIndex] = null; } 
                            }

                            updateInventoryUI();
                            updateToolbarSelection();
                        }
                    }
                }
            }
        });

        renderer.domElement.addEventListener('contextmenu', function(e) { e.preventDefault(); }); 

        btns.forEach(function(btn, index) {
            btn.addEventListener('click', function() {
                sel = index; 
                updateToolbarSelection();
            });
        });
        
        updateToolbarSelection(); 

        
        function check(x, y, z, r) {
            // OPTIMIZED: Efficient hitbox collision detection with sweep test
            // Only check immediately adjacent blocks
            var cx = Math.round(x / bs);
            var cy = Math.round(y / bs);
            var cz = Math.round(z / bs);
            
            // Reduced test area - only check blocks that could actually collide
            var tests = [
                [0, 0, 0],                         // Current position
                [0, -1, 0], [0, 1, 0],            // Vertical
                [-1, 0, 0], [1, 0, 0],             // X-axis
                [0, 0, -1], [0, 0, 1]              // Z-axis
            ]; 
            
            for (var i = 0; i < tests.length; i++) {
                var tx = cx + tests[i][0];
                var ty = cy + tests[i][1];
                var tz = cz + tests[i][2];
                
                var blockKey = key(tx, ty, tz);
                if (world[blockKey]) {
                    var block = world[blockKey];
                    
                    // Skip collision for torches
                    if (block.userData.isTorch) {
                        continue;
                    }
                    
                    // Skip collision for water and lava (allow swimming through)
                    if (block.userData.blockType === WATER_TYPE || block.userData.blockType === LAVA_TYPE) {
                        continue;
                    }
                    
                    // Skip collision for open doors
                    if (block.userData.blockType === DOOR_TYPE && block.userData.doorOpen) {
                        continue;
                    }
                    
                    // For closed doors, check both blocks (2 blocks tall)
                    if (block.userData.blockType === DOOR_TYPE) {
                        var doorBottomY = block.userData.doorBottomY;
                        var doorTopY = doorBottomY + 1;
                        
                        // Check collision for both door blocks
                        if (ty === doorBottomY || ty === doorTopY) {
                            var bpx = tx * bs;
                            var bpy = ty * bs;
                            var bpz = tz * bs;
                            
                            var halfBlock = bs / 2;
                            var margin = 0.02;
                            
                            if (x + r > bpx - halfBlock + margin && 
                                x - r < bpx + halfBlock - margin &&
                                z + r > bpz - halfBlock + margin && 
                                z - r < bpz + halfBlock - margin &&
                                y + margin > bpy - halfBlock && 
                                y - PLAYER_HEIGHT < bpy + halfBlock - margin) {
                                return block;
                            }
                        }
                        continue;
                    }
                    
                    var bpx = tx * bs;
                    var bpy = ty * bs;
                    var bpz = tz * bs;
                    
                    // OPTIMIZED: Slightly tighter boundaries with margin to prevent sticking
                    var halfBlock = bs / 2;
                    var margin = 0.02; // Small margin to prevent edge cases
                    
                    // AABB collision with margin
                    if (x + r > bpx - halfBlock + margin && 
                        x - r < bpx + halfBlock - margin &&
                        z + r > bpz - halfBlock + margin && 
                        z - r < bpz + halfBlock - margin &&
                        y + margin > bpy - halfBlock && 
                        y - PLAYER_HEIGHT < bpy + halfBlock - margin) {
                        return world[blockKey]; 
                    }
                }
            }
            return null;
        }

        var last = performance.now();
        var fc = 0; var ft = 0;
        var fpsElement = document.getElementById('fps');
        
        var BASE_SPD = 12; var JUMP_FORCE = 10; var GRAVITY = 25; var FRICTION = 0.0; 
        var dt = 0; // Make dt global for sand physics

        function loop() {
            requestAnimationFrame(loop);
            
            var now = performance.now();
            
            if (!paused) { 
                dt = Math.min((now - last) / 1000, 0.1); 
                last = now;

                fc++; ft += dt;
                if (ft >= 1) { fpsElement.textContent = fc + ' FPS'; fc = 0; ft = 0; }
                
                const roundedX = px.toFixed(2);
                const roundedY = py.toFixed(2);
                const roundedZ = pz.toFixed(2);
                
                // Check if player's head is underwater
                const headY = py + (PLAYER_TOTAL_HEIGHT - EYE_HEIGHT);
                const headBlockX = Math.round(px / bs);
                const headBlockY = Math.round(headY / bs);
                const headBlockZ = Math.round(pz / bs);
                const headBlock = world[key(headBlockX, headBlockY, headBlockZ)];
                isUnderwater = headBlock && headBlock.userData.blockType === WATER_TYPE;
                
                // Oxygen and Health system (only in survival mode)
                if (!isCreativeMode && !isDead) {
                    if (isUnderwater) {
                        // Deplete oxygen when underwater
                        currentOxygen -= oxygenDepletionRate * dt;
                        currentOxygen = Math.max(0, currentOxygen);
                        
                        // Update oxygen UI
                        updateOxygenUI();
                        
                        // Drowning damage when oxygen runs out
                        if (currentOxygen <= 0) {
                            drownDamageTimer += dt;
                            if (drownDamageTimer >= drownDamageInterval) {
                                takeDamage(drownDamageRate);
                                drownDamageTimer = 0;
                            }
                        }
                    } else {
                        // Regenerate oxygen when not underwater
                        if (currentOxygen < maxOxygen) {
                            currentOxygen += oxygenRegenRate * dt;
                            currentOxygen = Math.min(maxOxygen, currentOxygen);
                            updateOxygenUI();
                        } else {
                            updateOxygenUI(); // Will hide when full
                        }
                        
                        drownDamageTimer = 0;
                    }
                    
                    // Update health UI
                    updateHealthUI();
                } else if (isCreativeMode) {
                    // Creative mode - keep oxygen and health full, hide UI
                    currentOxygen = maxOxygen;
                    currentHealth = maxHealth;
                    document.getElementById('oxygen-container').style.display = 'none';
                    document.getElementById('health-container').style.display = 'none';
                }
                
                // MODIFIED: Update UI text for game mode
                uiElement.innerHTML = `Game Mode: ${isCreativeMode ? 'Creative' : 'Survival'}\nFly Mode: ${isFlying ? 'ON' : 'OFF'}\nSeed: ${WORLD_SEED}\nWorld Size: ${ws}\nX: ${roundedX}\nY: ${roundedY}\nZ: ${roundedZ}`;

                // --- DAY/NIGHT CYCLE UPDATE ---
                dayTime += dt;
                if (dayTime >= dayLength) {
                    dayTime -= dayLength; // Loop the cycle
                }
                
                // Calculate cycle progress (0 to 1)
                const cycleProgress = dayTime / dayLength;
                const angle = cycleProgress * Math.PI * 2; // Full rotation
                
                // Position sun and moon opposite to each other
                sun.position.set(
                    Math.sin(angle) * celestialDistance,
                    Math.cos(angle) * celestialDistance,
                    0
                );
                moon.position.set(
                    -Math.sin(angle) * celestialDistance,
                    -Math.cos(angle) * celestialDistance,
                    0
                );
                
                // Update sun to always face camera (billboard effect)
                sun.lookAt(camera.position);
                moon.lookAt(camera.position);
                
                // Calculate light intensity based on sun height
                // Day is when sun is above horizon (cos(angle) > 0)
                const sunHeight = Math.cos(angle);
                const isDay = sunHeight > 0;
                
                // Smooth transition for lighting (REDUCED BRIGHTNESS)
                let lightIntensity;
                if (sunHeight > 0.1) {
                    // Full day - reduced from 0.6-1.0 to 0.4-0.7
                    lightIntensity = 0.4 + sunHeight * 0.3;
                } else if (sunHeight > -0.1) {
                    // Twilight transition
                    lightIntensity = 0.2 + (sunHeight + 0.1) * 1.0;
                } else {
                    // Night
                    lightIntensity = 0.15;
                }
                
                // Update ambient light (reduced brightness)
                aLight.intensity = lightIntensity;
                dLight.intensity = lightIntensity * 0.8;
                
                // Calculate sky color based on time of day
                let skyColor;
                if (sunHeight > 0.2) {
                    // Day - bright blue
                    skyColor = new THREE.Color(0x87CEEB);
                } else if (sunHeight > 0) {
                    // Dawn/Dusk - orange/pink
                    const t = sunHeight / 0.2;
                    skyColor = new THREE.Color().lerpColors(
                        new THREE.Color(0xFF6B35), // Orange
                        new THREE.Color(0x87CEEB), // Blue
                        t
                    );
                } else if (sunHeight > -0.2) {
                    // Twilight - dark blue
                    const t = (sunHeight + 0.2) / 0.2;
                    skyColor = new THREE.Color().lerpColors(
                        new THREE.Color(0x1a1a2e), // Dark blue
                        new THREE.Color(0xFF6B35), // Orange
                        t
                    );
                } else {
                    // Night - very dark blue
                    skyColor = new THREE.Color(0x1a1a2e);
                }
                
                scene.background = skyColor;
                scene.fog.color = skyColor;
                
                // --- UPDATE PARTICLES ---
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.lifetime -= dt;
                    
                    if (p.lifetime <= 0) {
                        scene.remove(p);
                        particles.splice(i, 1);
                    } else {
                        p.velocity.y -= GRAVITY * dt;
                        p.position.x += p.velocity.x * dt;
                        p.position.y += p.velocity.y * dt;
                        p.position.z += p.velocity.z * dt;
                        p.material.opacity = p.lifetime;
                        // Billboard effect - make particles face camera
                        p.lookAt(camera.position);
                    }
                }
                
                // --- UPDATE BLOCK OUTLINE ---
                ray.setFromCamera(new THREE.Vector2(0, 0), camera);
                var objs = Object.values(world);
                var hits = ray.intersectObjects(objs);
                
                if (hits.length > 0 && !inventoryOpen) {
                    var hit = hits[0];
                    var distance = hit.distance;
                    
                    // Only show outline if within reach (5 blocks)
                    if (distance < 5 * bs) {
                        blockOutline.position.copy(hit.object.position);
                        blockOutline.visible = true;
                    } else {
                        blockOutline.visible = false;
                    }
                } else {
                    blockOutline.visible = false;
                }

                // ENHANCED OPTIMIZATION: Frustum culling + occlusion culling
                var playerBlockX = Math.round(px / bs);
                var playerBlockY = Math.round(py / bs);
                var playerBlockZ = Math.round(pz / bs);
                // renderDistance is now a global variable set by the settings slider
                
                // Helper function to check if a block is surrounded (not visible)
                function isBlockSurrounded(x, y, z) {
                    const directions = [
                        [1, 0, 0], [-1, 0, 0],  // x axis
                        [0, 1, 0], [0, -1, 0],  // y axis
                        [0, 0, 1], [0, 0, -1]   // z axis
                    ];
                    
                    for (let dir of directions) {
                        const neighborKey = key(x + dir[0], y + dir[1], z + dir[2]);
                        if (!world[neighborKey]) {
                            return false; // Has at least one exposed face
                        }
                    }
                    return true; // Completely surrounded
                }
                
                for(var k in world) {
                    var mesh = world[k];
                    var bx = Math.round(mesh.position.x / bs);
                    var by = Math.round(mesh.position.y / bs);
                    var bz = Math.round(mesh.position.z / bs);
                    
                    // Distance-based culling
                    var distance = Math.sqrt(
                        Math.pow(bx - playerBlockX, 2) + 
                        Math.pow(bz - playerBlockZ, 2)
                    );
                    
                    // Hide if too far OR completely surrounded by other blocks
                    if (distance > renderDistance) {
                        mesh.visible = false;
                    } else if (distance > 3) {
                        // Only check occlusion for blocks not immediately near player
                        mesh.visible = !isBlockSurrounded(bx, by, bz);
                    } else {
                        // Always show blocks very close to player
                        mesh.visible = true;
                    }
                }



                if (locked && !inventoryOpen && !isDead) { 
                    var fx = Math.sin(ry); 
                    var fz = Math.cos(ry); 
                    var rx2 = Math.sin(ry + Math.PI / 2); 
                    var rz = Math.cos(ry + Math.PI / 2); 
                    
                    var inputX = 0; var inputZ = 0;
                    var currentSpeed = BASE_SPD; 

                    if (keys.KeyW) { inputX -= fx; inputZ -= fz; } 
                    if (keys.KeyS) { inputX += fx; inputZ += fz; } 
                    if (keys.KeyA) { inputX -= rx2; inputZ -= rz; } 
                    if (keys.KeyD) { inputX += rx2; inputZ += rz; } 
                    
                    if (isFlying) { 
                        // --- FLYING LOGIC ---
                        ground = false;
                        vx = 0; vy = 0; vz = 0;
                        
                        let flySpeed = currentSpeed * dt;
                        
                        var mag = Math.sqrt(inputX * inputX + inputZ * inputZ);
                        if (mag > 0) {
                            inputX /= mag; inputZ /= mag;
                            vx = inputX * flySpeed;
                            vz = inputZ * flySpeed;
                        }
                        
                        if (keys.Space) { vy = flySpeed; }
                        if (keys.ShiftLeft || keys.ShiftRight) { vy = -flySpeed; }
                        
                        var nx = px + vx;
                        var ny = py + vy;
                        var nz = pz + vz;
                        
                        // Use same hitbox as walking - check at eye level (current position)
                        var playerRadius = PLAYER_RADIUS;
                        
                        // Check X axis collision at current height
                        var hitX = check(nx, py, pz, playerRadius);
                        if (hitX) { 
                            nx = px;
                            vx = 0;
                        }
                        
                        // Check Y axis collision (vertical) at current height
                        var hitY = check(px, ny, pz, playerRadius);
                        if (hitY) {
                            ny = py;
                            vy = 0;
                        }
                        
                        // Check Z axis collision at current height
                        var hitZ = check(nx, py, nz, playerRadius);
                        if (hitZ) {
                            nz = pz;
                            vz = 0;
                        }
                        
                        px = nx; 
                        py = ny; 
                        pz = nz;
                        
                    } else {
                        // --- WALKING/FALLING LOGIC (Original Physics) ---
                        
                        // Check if player is in water or lava
                        const playerBlockX = Math.round(px / bs);
                        const playerBlockY = Math.round(py / bs);
                        const playerBlockZ = Math.round(pz / bs);
                        const playerBlock = world[key(playerBlockX, playerBlockY, playerBlockZ)];
                        const inFluid = playerBlock && (playerBlock.userData.blockType === WATER_TYPE || playerBlock.userData.blockType === LAVA_TYPE);
                        const inWater = playerBlock && playerBlock.userData.blockType === WATER_TYPE;
                        const inLava = playerBlock && playerBlock.userData.blockType === LAVA_TYPE;
                        
                        var mag = Math.sqrt(inputX * inputX + inputZ * inputZ);

                        if (mag > 0) {
                            inputX /= mag; inputZ /= mag;
                            // Slower movement in fluids
                            const fluidMultiplier = inFluid ? 0.6 : 1.0;
                            vx = inputX * currentSpeed * dt * fluidMultiplier;
                            vz = inputZ * currentSpeed * dt * fluidMultiplier;
                        } else {
                            vx *= FRICTION; vz *= FRICTION; 
                        }
                        
                        // Modified gravity for fluids - Minecraft-style water physics
                        if (inFluid) {
                            // Minecraft-style buoyancy - natural floating
                            if (inWater) {
                                // Very slow sinking when idle (almost floating)
                                vy -= GRAVITY * dt * 0.15; // 15% gravity in water - feels like floating
                                
                                // Add slight upward buoyancy force for natural floating
                                vy += GRAVITY * dt * 0.08; // Upward buoyancy
                                
                                // Swimming controls - Minecraft style
                                if (keys.Space) {
                                    vy = JUMP_FORCE * 0.6; // Swim up faster
                                }
                                if (keys.ShiftLeft || keys.ShiftRight) {
                                    vy = -JUMP_FORCE * 0.4; // Swim down
                                }
                                
                                // Strong drag in water for realistic feel
                                vy *= 0.85;
                                vx *= 0.92;
                                vz *= 0.92;
                            } else if (inLava) {
                                // Lava has more resistance
                                vy -= GRAVITY * dt * 0.25;
                                vy += GRAVITY * dt * 0.05; // Less buoyant than water
                                
                                if (keys.Space) {
                                    vy = JUMP_FORCE * 0.4;
                                }
                                if (keys.ShiftLeft || keys.ShiftRight) {
                                    vy = -JUMP_FORCE * 0.2;
                                }
                                
                                vy *= 0.80;
                                vx *= 0.88;
                                vz *= 0.88;
                            }
                        } else {
                            // Normal gravity
                            vy -= GRAVITY * dt;
                            
                            if (keys.Space && ground) { 
                                vy = JUMP_FORCE; 
                                ground = false; 
                                const blockUnderPlayer = getBlockUnderPlayer();
                                playJumpSound(blockUnderPlayer); // Play jump sound based on block type
                            }
                        }
                        
                        var nx = px + vx; 
                        var nz = pz + vz; 
                        var playerRadius = PLAYER_RADIUS;

                        var nextY = py + vy * dt;
                        var nextFeetY = nextY - EYE_HEIGHT;
                        var nextHeadY = nextY + (PLAYER_TOTAL_HEIGHT - EYE_HEIGHT);
                        
                        // OPTIMIZED: Smooth ceiling collision with better collision response
                        if (vy > 0) {
                            var ceilingCheckY = nextHeadY;
                            var ceilingHit = check(px, ceilingCheckY, pz, playerRadius);
                            if (ceilingHit) {
                                var blockBottomY = ceilingHit.position.y - bs / 2;
                                var distanceToBlock = blockBottomY - nextHeadY;
                                
                                // Progressive deceleration as approaching ceiling
                                if (distanceToBlock < 0.2) {
                                    // Very close - stop and position precisely
                                    vy = 0;
                                    nextY = blockBottomY - (PLAYER_TOTAL_HEIGHT - EYE_HEIGHT) - 0.01;
                                    nextHeadY = nextY + (PLAYER_TOTAL_HEIGHT - EYE_HEIGHT);
                                    nextFeetY = nextY - EYE_HEIGHT;
                                } else if (distanceToBlock < 0.4) {
                                    // Approaching - slow down
                                    vy = vy * 0.5;
                                }
                            }
                        }
                        
                        // OPTIMIZED: Floor collision with better ground detection
                        var verticalHit = check(px, nextFeetY, pz, playerRadius); 
                        
                        if (verticalHit && vy <= 0) {
                            var blockTopY = verticalHit.position.y + bs / 2; 
                            var distanceToGround = nextFeetY - blockTopY;
                            
                            // Smooth landing with precise positioning
                            if (distanceToGround < 0.15) {
                                ground = true;
                                vy = 0;
                                nextY = blockTopY + EYE_HEIGHT;
                                nextFeetY = blockTopY;
                            } else {
                                ground = false;
                            }
                        } else { 
                            ground = false; 
                        }
                        
                        // FIXED: Horizontal collision at correct height
                        var hitX = check(nx, py, pz, playerRadius);
                        if (hitX) { 
                            nx = px; 
                            vx = 0; 
                        }
                        
                        var hitZ = check(nx, py, nz, playerRadius);
                        if (hitZ) { 
                            nz = pz; 
                            vz = 0; 
                        }
                        
                        px = nx; 
                        py = nextY; 
                        pz = nz;
                        
                        // --- WALKING SOUND SYSTEM WITH BLOCK DETECTION ---
                        const isMoving = mag > 0 && ground;
                        if (isMoving) {
                            stepTimer += dt;
                            if (stepTimer >= stepInterval) {
                                const blockUnderPlayer = getBlockUnderPlayer();
                                playStepSound(blockUnderPlayer);
                                stepTimer = 0;
                            }
                            wasMoving = true;
                        } else {
                            stepTimer = 0;
                            wasMoving = false;
                        }
                    }
                    
                    camera.position.set(px, py, pz);
                    camera.rotation.set(rx, ry, 0, 'YXZ');

                    if (py < -50) { 
                        resetPlayer();
                    }
                } else {
                    camera.position.set(px, py, pz);
                    camera.rotation.set(rx, ry, 0, 'YXZ');
                }
            } else { last = now; }
            
            // --- Sand Falling Physics ---
            if (!paused && dt > 0) { 
                sandFallTimer += dt;
                if (sandFallTimer >= SAND_FALL_CHECK_INTERVAL) {
                    sandFallTimer = 0;

                    const fallingBlocks = [];
                    for (const k in world) {
                        const mesh = world[k];
                        if (mesh.userData.blockType === SAND_TYPE) { // 4 is SAND
                            const [bx, by, bz] = k.split(',').map(Number);
                            
                            if (by > 1 && !world[key(bx, by - 1, bz)]) {
                                fallingBlocks.push({ oldKey: k, x: bx, y: by, z: bz, type: SAND_TYPE });
                            }
                        }
                    }
                    
                    for (const block of fallingBlocks) {
                        const { oldKey, x, y, z, type } = block;
                        
                        const meshToRemove = world[oldKey];
                        if (meshToRemove) {
                            scene.remove(meshToRemove);
                            if (meshToRemove.geometry) meshToRemove.geometry.dispose(); 
                            delete world[oldKey];
                        }

                        add(x, y - 1, z, type); 
                    }
                }
            }
            
            // --- NEW: Grass Spreading Physics ---
            if (!paused && dt > 0) {
                grassSpreadTimer += dt;
                
                if (grassSpreadTimer >= GRASS_SPREAD_CHECK_INTERVAL) {
                    grassSpreadTimer = 0;

                    // Calculate the chance of growth for this interval (1/300 for an average 5 minute spread)
                    const spreadChance = GRASS_SPREAD_CHECK_INTERVAL / GRASS_SPREAD_CHANCE_MAX_SECONDS; 

                    // Only process a small, random number of dirt blocks for performance
                    const dirtBlocks = [];
                    for (const k in world) {
                        const mesh = world[k];
                        if (mesh.userData.blockType === DIRT_TYPE) { // 1 is DIRT
                            dirtBlocks.push(k);
                        }
                    }
                    
                    // Shuffle the dirt blocks and only check a fraction (e.g., 50 max)
                    dirtBlocks.sort(() => Math.random() - 0.5);
                    const maxChecks = Math.min(dirtBlocks.length, 50); 
                    
                    for (let i = 0; i < maxChecks; i++) {
                        const k = dirtBlocks[i];
                        const [bx, by, bz] = k.split(',').map(Number);
                        
                        // 1. Check for light (Air/Non-solid block above it)
                        const hasLight = !world[key(bx, by + 1, bz)]; 
                        
                        if (hasLight) {
                            let hasGrassNeighbor = false;
                            
                            // 2. Check for an adjacent Grass block (source) in a 3x3 horizontal area
                            for (let dx = -1; dx <= 1; dx++) {
                                for (let dz = -1; dz <= 1; dz++) {
                                    if (dx === 0 && dz === 0) continue; // Skip self

                                    const neighbor = world[key(bx + dx, by, bz + dz)];
                                    if (neighbor && neighbor.userData.blockType === GRASS_TYPE) {
                                        hasGrassNeighbor = true;
                                        break;
                                    }
                                }
                                if (hasGrassNeighbor) break;
                            }
                            
                            if (hasGrassNeighbor) {
                                // 3. Random chance check
                                if (Math.random() < spreadChance) {
                                    
                                    // Remove old dirt block
                                    const meshToRemove = world[k];
                                    if (meshToRemove) {
                                        scene.remove(meshToRemove);
                                        if (meshToRemove.geometry) meshToRemove.geometry.dispose(); 
                                        delete world[k];
                                    }
                                    
                                    // Add new grass block (type 0) silently
                                    const grassKey = key(bx, by, bz);
                                    var m = mats[GRASS_TYPE];
                                    var mesh = new THREE.Mesh(blockGeometry, Array.isArray(m) ? m : [m, m, m, m, m, m]); 
                                    mesh.position.set(bx * bs, by * bs, bz * bs);
                                    mesh.castShadow = true;
                                    mesh.receiveShadow = true;
                                    mesh.userData.blockType = GRASS_TYPE;
                                    mesh.userData.silentPlace = true; // Flag to prevent sound
                                    scene.add(mesh);
                                    world[grassKey] = mesh;
                                }
                            }
                        }
                    }
                }
            }
            // --- END NEW: Grass Spreading Physics ---
            
            renderer.render(scene, camera);
        }
        
        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Reset fake cursor on resize
            fakeCursorX = window.innerWidth / 2;
            fakeCursorY = window.innerHeight / 2;
        });
    </script>
</body>
</html>